# HG changeset patch
# User Gonzalo Tornar√≠a <tornaria@math.utexas.edu>
# Date 1235358913 18000
# Node ID 4631ee986dba35165e35c3896f512141c576435b
# Parent  05d19caf606f595a943b624b985424424bfce294
#4470: Initial commit of Jon Hanke's quadratic forms code

diff --git a/module_list.py b/module_list.py
--- a/module_list.py
+++ b/module_list.py
@@ -793,6 +793,18 @@
 
     ################################
     ## 
+    ## sage.quadratic_forms
+    ##
+    ################################
+
+    Extension('sage.quadratic_forms.count_local_2',
+              sources = ['sage/quadratic_forms/count_local_2.pyx']),
+
+    Extension('sage.quadratic_forms.quadratic_form__evaluate',
+              sources = ['sage/quadratic_forms/quadratic_form__evaluate.pyx']),
+
+    ################################
+    ## 
     ## sage.rings
     ##
     ################################
diff --git a/sage/quadratic_forms/all.py b/sage/quadratic_forms/all.py
--- a/sage/quadratic_forms/all.py
+++ b/sage/quadratic_forms/all.py
@@ -1,1 +1,15 @@
 from binary_qf import BinaryQF, BinaryQF_reduced_representatives
+
+from quadratic_form import QuadraticForm, DiagonalQuadraticForm
+
+from random_quadraticform import random_quadraticform, random_quadraticform_with_conditions
+
+from extras import sgn, IsPadicSquare, random_int_upto, extend_to_primitive, is_triangular_number, hilbert_symbol_rational
+
+from special_values import gamma__exact, zeta__exact, QuadraticBernoulliNumber, \
+      quadratic_L_function__exact, quadratic_L_function__numerical
+
+from genera.genus import is_GlobalGenus, is_2_adic_genus, is_trivial_symbol
+
+from constructions import BezoutianQuadraticForm, HyperbolicPlane_quadratic_form
+
diff --git a/sage/quadratic_forms/constructions.py b/sage/quadratic_forms/constructions.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/constructions.py
@@ -0,0 +1,78 @@
+##
+## Some extra routines to make the QuadraticForm class more useful.
+##
+
+from sage.rings.integer import is_Integer
+from sage.rings.all import ZZ
+from sage.rings.polynomial.polynomial_element import is_Polynomial
+from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
+from sage.quadratic_forms.quadratic_form import QuadraticForm
+
+
+
+def BezoutianQuadraticForm(f, g):
+    """
+    Compute the Bezoutian of two polynomials defined over a common base ring.  This is defined by
+
+        Bez(f, g) := (f(x)*g(y) - f(y)*g(x)) / (y-x)
+
+    and has size defined by the maximum of the degrees of f and g.
+
+    INPUT:
+        f, g -- polynomials in R[x]
+
+    OUTPUT:
+        a quadratic form over R
+
+    EXAMPLES:
+        sage: R = PolynomialRing(ZZ, 'x')
+        sage: f = R([1,2,3])
+        sage: g = R([2,5])        
+        sage: BezoutianQuadraticForm(f, g)
+
+    AUTHORS:
+        Fernando Rodriguez-Villegas, Jonathan Hanke -- added on 11/9/2008
+
+    """
+    ## Check that f and g are polynomials with a common base ring
+    if not is_Polynomial(f) or not is_Polynomial(g):
+        raise TypeError, "Oops!  One of your inputs is not a polynomial. =("
+    if f.base_ring() != g.base_ring():                   ## TO DO:  Change this to allow coercion!
+        raise TypeError, "Oops!  These polynomials are not defined over the same coefficient ring."
+
+    ## Initialize the quadratic form
+    R = f.base_ring()
+    P = PolynomialRing(R, ['x','y'])
+    a, b = P.gens()
+    n = max(f.degree(), g.degree())
+    Q = QuadraticForm(R, n)
+
+    ## Set the coefficients of Bezoutian
+    bez_poly = (f(a) * g(b) - f(b) * g(a)) // (b - a)    ## Trucated (exact) division here
+    for i in range(n):
+        for j in range(i, n):
+            Q[i,j] = bez_poly.coefficient({a:i,b:j})
+
+    return Q
+
+
+def HyperbolicPlane_quadratic_form(R, r=1):
+    """
+    Constructs the direct sum of r copies of the quadratic form xy
+    representing a hyperbolic plane defined over the base ring R.
+
+    EXAMPLES:
+        sage: HyperbolicPlane_quadratic_form(ZZ)
+
+        Quadratic form in 2 variables over Integer Ring with coefficients:
+        [ 0 1 ]
+        [ * 0 ]
+
+    """
+    r = ZZ(r)
+    ## Check that the multiplicity is a natural number
+    if r < 1:
+        raise TypeError, "The multiplicity r must be a natural number."
+
+    H = QuadraticForm(R, 2, [0, 1, 0])  
+    return sum([H  for i in range(r-1)], H)
diff --git a/sage/quadratic_forms/count_local_2.pyx b/sage/quadratic_forms/count_local_2.pyx
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/count_local_2.pyx
@@ -0,0 +1,268 @@
+
+include "../ext/cdefs.pxi"
+include "../ext/gmp.pxi"
+
+from sage.rings.arith import valuation
+from sage.rings.integer_mod import IntegerMod, Mod
+from sage.rings.integer_mod_ring import IntegerModRing
+
+from sage.rings.integer_ring import ZZ
+
+from sage.rings.integer_mod cimport IntegerMod_gmp
+
+
+
+
+
+cdef CountAllLocalTypesNaive_cdef(Q, p, k, m, zvec, nzvec):
+    """
+    ///////////////////////////////////////////////////////////////////
+    /// Naively counts the number of solutions of Q(x) = m mod p^k   //
+    /// of type solntype, satisfying the mod p congruence conditions //
+    /// at the indices of the vectors "zero" and "nonzero"           //
+    ///////////////////////////////////////////////////////////////////
+
+    valarray <mpz_class> Matrix_mpz::CountAllLocalTypesNaive(const mpz_class & p, unsigned long k, const mpz_class & m, 
+                                             const valarray<size_t> & zero, const valarray<size_t> & nonzero) const
+    """
+
+    ## DIAGNOSTIC
+    #print "   --> CountAllLocalTypesNaive is using the form Q \n" + str(Q)
+    #print "       p = " + str(p) + "  and   m = " + str(m)
+
+    #cdef mpz_t* v 
+    cdef long n, i
+    cdef long a, b    ## Used to quickly evaluate Q(v)
+    cdef long ptr     ## Used to increment the vector
+    cdef long solntype    ## Used to store the kind of solution we find
+
+
+
+
+    n = Q.dim()
+    R = p ** k
+
+    ## Cython Variables
+    cdef IntegerMod_gmp zero, one
+    zero = IntegerMod_gmp(IntegerModRing(R), 0)
+    one = IntegerMod_gmp(IntegerModRing(R), 1)
+
+
+    Q1 = Q.base_change_to(IntegerModRing(R))
+
+
+
+    ########################################### 
+    #v = <mpz_t*> sage_malloc(sizeof(mpz_t)*n)
+    #for i from 0 <= i < n:
+    #    mpz_init(v[i])        
+    ###########################################
+
+    ## Initialize the counting vector
+    count_vector = [0  for i in range(6)]
+
+    ## Initialize v = (0, ... , 0)
+    v = [Mod(0, R)  for i in range(n)]
+    #v = []
+    #for i in 1 <= i < n:
+    #    v.append(zero)
+
+
+    ## Some declarations to speed up the loop
+    R_n = R ** n
+    m1 = Mod(m, R)
+
+    ## Count the local solutions
+    for i from 0 <= i < R_n:
+
+        ## Perform a carry (when value = R-1) until we can increment freely
+        ptr = len(v)
+        while ((ptr > 0) and (v[ptr-1] == R-1)):
+            v[ptr-1] += 1
+            ptr += -1
+
+        ## Only increment if we're not already at the zero vector =)
+        if (ptr > 0):
+            v[ptr-1] += 1
+
+
+        ## Evaluate Q(v) quickly
+        tmp_val = Mod(0, R)
+        for a from 0 <= a < n:
+            for b from a <= b < n:
+                tmp_val += Q1[a,b] * v[a] * v[b]
+
+        ## Sort the solution by it's type
+        #if (Q1(v) == m1):      
+        if (tmp_val == m1):      
+            solntype = local_solution_type_cdef(Q1, p, v, zvec, nzvec)
+            if (solntype != 0):
+                count_vector[solntype] += 1
+
+
+
+    ## Generate the Bad-type and Total counts
+    count_vector[3] = count_vector[4] + count_vector[5]
+    count_vector[0] = count_vector[1] + count_vector[2] + count_vector[3]
+
+
+    ## DIAGNOSTIC
+    #cout << "R = " << R << "\n";
+    #cout << "n = " << n << "\n";
+    #cout << "R_n = " << R_n << "\n";
+    #
+    #for(i=1; i<=25; i++) {
+    #    cout << "v = " << v << "\n"; 
+    #    Increment(v,R);
+    #}
+    #
+    #cout << "Q1 = " << Q1 << "\n";
+    #cout << "v = " << v << "\n";
+    #cout << "Q1 * v = " << Q1 * v<< "\n";
+
+    ###########################
+    #for i from 0 <= i < n:
+    #    mpz_clear(v[i])
+    #sage_free(v)
+    ###########################
+
+    return count_vector    
+
+
+
+def CountAllLocalTypesNaive(Q, p, k, m, zvec, nzvec):
+    """
+    Python wrapper function for this (now) cython function.
+    """
+    return CountAllLocalTypesNaive_cdef(Q, p, k, m, zvec, nzvec)
+
+
+
+
+
+
+
+cdef local_solution_type_cdef(Q, p, w, zvec, nzvec):
+    """
+    ////////////////////////////////////////////////////////////////////////////////////
+    /// Private routine to check if a given solution vector w (of Q(w) = m mod p^k)   //
+    /// is of a certain local type and satisfies certain congruence conditions mod p. //
+    ///   (Personal Note: For p=2, we should still use p=2 and not p=8.)              //
+    ////////////////////////////////////////////////////////////////////////////////////
+
+    size_t Matrix_mpz::local_solution_type(const mpz_class & p, const valarray<mpz_class> & w, 
+               const valarray<size_t> & zero, const valarray<size_t> & nonzero) const
+
+    """
+
+    ## Note: Here p is assumed to be a prime >= 2, though the routine still works if not...
+
+    ## ToDo?: Add a check that Q is square and has the same size as w.
+
+    cdef long i
+    cdef long n  
+
+    n = Q.dim()
+
+    zero_flag = False        ## Tests the zero mod p congruence conditions
+    nonzero_flag = False     ## Tests the nonzero congruence conditions
+
+
+    ## Check if the solution satisfies the zvec "zero" congruence conditions
+    ## (either zvec is empty or its components index the zero vector mod p)
+    if (len(zvec) == 0): 
+        zero_flag = True
+    else:
+        i = 0
+        while ( (i < len(zvec)) and ((w[zvec[i]] % p) == 0) ):
+            i += 1
+        if (i == len(zvec)):
+            zero_flag = True
+
+
+    ## DIAGNOSTIC
+    #print "IsLocalSolutionType: Finished the Zero congruence condition test \n"
+
+    if (zero_flag == False):
+        return 0
+
+    ## DIAGNOSTIC
+    #print "IsLocalSolutionType: Passed the Zero congruence condition test \n"
+
+
+    ## Check if the solution satisfies the nzvec "nonzero" congruence conditions
+    ## (either nzvec is empty or its components index a non-zero vector mod p)
+    if (len(nzvec) == 0): 
+        nonzero_flag = True 
+    else:
+        i = 0
+        while ((nonzero_flag == False) and (i < len(nzvec))):
+            if ((w[nzvec[i]] % p) != 0):
+                nonzero_flag = True
+            i += 1
+  
+    if (nonzero_flag == False):
+        return <long> 0
+  
+  
+    ## Check if the solution has the appropriate (local) type
+  
+  
+    ## 1: Check Good-type
+    for i from 0 <= i < n:
+        if (((w[i] % p) != 0)  and ((Q[i,i] % p) != 0)):
+            return <long> 1
+    if (p == 2):
+        for i from 0 <= i < (n - 1):
+            if (((Q[i,i+1] % p) != 0) and (((w[i] % p) != 0) or ((w[i+1] % p) != 0))):
+                return <long> 1  
+
+
+    ## 2: Check Zero-type
+    Zero_flag = True
+    for i from 0 <= i < n:
+        if ((w[i] % p) != 0):
+            Zero_flag = False
+    if (Zero_flag == True):
+        return <long> 2
+
+
+    ## Check if wS1 is zero or not
+    wS1_nonzero_flag = False
+    for i from 0 <= i < n:      
+  
+        ## Compute the valuation of each index, allowing for off-diagonal terms
+        if (Q[i,i] == 0):
+            if (i == 0):
+                val = valuation(Q[i,i+1], p)    ## Look at the term to the right
+            elif (i == n - 1):
+                val = valuation(Q[i-1,i], p)    ## Look at the term above
+            else:
+                val = valuation(Q[i,i+1] + Q[i-1,i], p)    ## Finds the valuation of the off-diagonal term since only one isn't zero
+        else:
+            val = valuation(Q[i,i], p)  
+
+        ## Test each index
+        if ((val == 1) and ((w[i] % p) != 0)):
+            wS1_nonzero_flag = True
+
+      
+    ## 4: Check Bad-type I
+    if (wS1_nonzero_flag == True):
+        #print " Bad I Soln :  " + str(w)
+        return <long> 4
+
+
+    ##    cout << " Bad II Soln :  " << w << "  wS1_nonzero_flag = " << wS1_nonzero_flag << endl;
+
+    ## 5: Check Bad-type II
+    if (wS1_nonzero_flag == False):
+        #print " Bad II Soln :  " + str(w)
+        return <long> 5
+
+
+    ## Error if we get here! =o
+    print "   Solution vector is " + str(w) 
+    print "   and Q is \n" + str(Q) + "\n" 
+    raise RuntimeError, "Error in IsLocalSolutionType: Should not execute this line... =( \n"
+
diff --git a/sage/quadratic_forms/extras.py b/sage/quadratic_forms/extras.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/extras.py
@@ -0,0 +1,265 @@
+
+from random import random
+from sage.calculus.calculus import floor
+from sage.matrix.constructor import matrix
+from sage.matrix.matrix import is_Matrix
+from sage.rings.arith import valuation, kronecker_symbol, legendre_symbol, hilbert_symbol
+from sage.rings.rational_field import QQ
+from sage.rings.integer_ring import ZZ
+from sage.rings.infinity import infinity
+from sage.calculus.calculus import sqrt
+from sage.misc.functional import squarefree_part
+
+
+
+def hilbert_symbol_rational(a, b, p):
+    """
+    Extend the usual Hilbert symbol to allow rational entries a and b.
+
+    TO DO: This should really be incorporated into the hilbert_symbol()
+    routine.
+    """
+    return hilbert_symbol(squarefree_part(a), squarefree_part(b), p)
+    
+
+
+def sgn(x):
+    """
+    Returns the sign of x. defined as:
+
+                   /  1  if  x > 0,
+        sgn(x) =   |  0  if  x = 0,
+                   \ -1  if  x < 0.
+
+    INPUT:
+        a real number
+
+    OUTPUT:
+        1, 0, or -1.
+
+    EXAMPLES:
+    
+    """
+    if x > 0:
+        return ZZ(1)
+    elif x == 0:
+        return ZZ(0)
+    elif x < 0:
+        return ZZ(-1)
+    else:
+        raise RuntimeError, "Oops!  We should not be here! =o"
+
+
+
+def is_triangular_number(n):
+    """
+    Determines if the integer n is a triangular number.
+    (I.e. determine if n = a*(a+1)/2 for some natural number a.)
+    If so, return the number a, otherwise return False.
+
+    Note: As a convetion, n=0 is consigered triangular for the
+    number a=0 only (and not for a=-1).
+
+    WARNING: Any non-zero value will return True, so this will test as
+    True iff n is truangular and not zero.  If n is zero, then this
+    will return the integer zero, which tests as False, so one must test
+
+        if is_triangular_number(n) != False:
+
+    instead of
+
+        if is_triangular_number(n):
+
+    to get zero to appear triangular.
+
+
+    INPUT:
+        an integer
+
+    OUTPUT:
+        either False or a non-negative integer
+
+    EXAMPLES:
+        sage: is_triangular_number(3)
+        2
+        sage: is_triangular_number(1)
+        1
+        sage: is_triangular_number(2)
+        False
+        sage: is_triangular_number(0)
+        0
+        sage: is_triangular_number(-1)
+        False
+        sage: is_triangular_number(-11)
+        False
+        sage: is_triangular_number(-1000)
+        False
+        sage: is_triangular_number(-0)
+        0
+        sage: is_triangular_number(10^6 * (10^6 +1)/2)
+        1000000
+    """
+    if n < 0:
+        return False
+    elif n == 0:
+        return ZZ(0)
+    else:
+        ## Try to solve for the integer a
+        try:
+            disc_sqrt = ZZ(sqrt(1+8*n))
+            a = ZZ( (ZZ(-1) + disc_sqrt) / ZZ(2) )
+            return a
+        except:
+            return False
+    
+
+
+def extend_to_primitive(A_input):
+    """
+    Given a matrix (resp. list of vectors), extend it to a square
+    matrix (resp. list of vectors), such that its determinant is the
+    gcd of its minors (i.e. extend the basis of a lattice to a
+    "maximal" one in Z^n).
+
+    Author(s): Gonzalo Tornaria and Jonathan Hanke.
+
+    INPUT:
+        a matrix, or a list of length n vectors (in the same space)
+
+    OUTPUT:
+        a square matrix, or a list of n vectors (resp.)
+
+    EXAMPLES:
+        sage: A = Matrix(ZZ, 3, 2, range(6))
+        sage: extend_to_primitive(A)
+        [ 0  1  0]
+        [ 2  3  0]
+        [ 4  5 -1]
+
+        sage: extend_to_primitive([vector([1,2,3])])
+        [(1, 2, 3), (0, 1, 0), (0, 0, 1)]
+
+    """
+    ## Deal with a list of vectors
+    if not is_Matrix(A_input):
+        A = matrix(A_input)      ## Make a matrix A with the given rows.
+        vec_output_flag = True
+    else:
+        A = A_input
+        vec_output_flag = False
+
+
+    ## Arrange for A  to have more columns than rows.
+    if A.is_square():
+        return A
+    if A.nrows() > A.ncols():
+        return extend_to_primitive(A.transpose()).transpose()
+
+    ## Setup
+    k = A.nrows()
+    n = A.ncols()
+    R = A.base_ring()
+
+    # Smith normal form transformation, assuming more columns than rows
+    V = A.smith_form()[2]
+
+    ## Extend the matrix in new coordinates, then switch back.
+    B = A * V
+    B_new = matrix(R, n-k, n)
+    for i in range(n-k):
+        B_new[i, i] = 1
+    C = B.stack(B_new)
+    D = C * V**(-1)
+
+    ## DIAGNOSTIC
+    #print "A = ", A, "\n"
+    #print "B = ", B, "\n"
+    #print "C = ", C, "\n"
+    #print "D = ", D, "\n"
+
+    # Normalize for a positive determinant
+    if D.det() < 0:
+        D.rescale_row(n-1, -1)
+
+    ## Return the corrent information
+    if  vec_output_flag:
+        return D.rows()    
+    else:
+        return D
+
+    
+
+
+def random_int_upto(n):
+    """
+    Returns a random integer x satisfying 0 <= x < n.
+    """
+    return floor(n * random())
+
+
+
+def sgn(x):
+    """
+    Returns the sign of a real number x.
+    """
+    if x > 0:
+        return 1
+    elif x == 0:
+        return 0
+    else:
+        return -1
+
+
+def quadratic_nonresidue(p):
+    """
+    Returns the smalest positive integer quadratic non-residue in Z/pZ for primes p>2.    """
+    p1 = abs(p)
+
+    ## Deal with the prime p = 2 and |p| <= 1.
+    if p1 == 2:
+        raise TypeError, "Oops!  There are no quadratic non-residues in Z/2Z."
+    if p1 < 2:
+        raise TypeError, "Oops!  p must be a prime number > 2."
+
+    ## TO DO: Test that p is prime???
+
+    ## Find the smallest non-residue mod p
+    for r in range(2,p):
+        if legendre_symbol(r, p) == -1:
+            return r
+    
+
+def IsPadicSquare(m, p):
+    """
+    Determines whether the (non-zero) rational number m is a square in Q_p.
+    When p = infinity this returns the answer for the real numbers.
+    """
+    ## Make sure m is non-zero
+    if m == 0:
+        raise TypeError, "Oops!  We're not allowed to ask about zero right now..."
+
+    ## TO DO:  Check that p is prime
+
+    ## Deal with p = infinity (i.e. the real numbers)
+    if p == infinity:
+        return (m > 0)
+
+    ## Deal with finite primes
+    v1 = valuation(QQ(m).numer(), p) 
+    v2 = valuation(QQ(m).denom(), p)
+    v = v1 - v2
+    other = m / (p**v)
+
+    #print "p =", p
+    #print "m =", m
+    #print "val(m,p) =", v
+ 
+    if ((v % 2) == 0):
+
+        if ((p == 2) and ((other % 8) == 1)):
+            return True
+
+        if ((p > 2) and (kronecker_symbol(other, p) == 1)):
+            return True
+
+    return False
diff --git a/sage/quadratic_forms/genera/genus.py b/sage/quadratic_forms/genera/genus.py
--- a/sage/quadratic_forms/genera/genus.py
+++ b/sage/quadratic_forms/genera/genus.py
@@ -30,7 +30,7 @@
     """
     val = A.determinant().valuation(p)
     symbol = p_adic_symbol(A, p, val = val)
-    return GenusSymbol_p_adic_ring(p, symbol)
+    return Genus_Symbol_p_adic_ring(p, symbol)
 
 def is_GlobalGenus(G):
     """
@@ -38,7 +38,7 @@
     True in G represents the genus of a global quadratic form or lattice.
     """
     D = G.determinant()
-    r, s = G.signature()
+    r, s = G.signature_of_matrix()
     oddity = r - s
     for loc in G._local_symbols:
         p = loc._prime
@@ -48,19 +48,19 @@
         b = Integer(misc.prod([ s[2] for s in sym ]))
         if p == 2:
             if not is_2_adic_genus(sym):
-   	        # print "False in is_2_adic_genus(sym)"
-	        return False   
- 	    if (a*b).kronecker(p) != 1:
-	        # print "False in (%s*%s).kronecker(%s)"%(a,b,p)
+                # print "False in is_2_adic_genus(sym)"
+                return False   
+            if (a*b).kronecker(p) != 1:
+                # print "False in (%s*%s).kronecker(%s)"%(a,b,p)
                 return False
             oddity -= loc.excess()    
-	else:      
- 	    if a.kronecker(p) != b:
-	        # print "False in %s.kronecker(%s) != *%s"%(a,p,b)
+        else:      
+            if a.kronecker(p) != b:
+                # print "False in %s.kronecker(%s) != *%s"%(a,p,b)
                 return False
             oddity += loc.excess()    
     if oddity%8 != 0:
-  	# print "False in oddity"
+        # print "False in oddity"
         return False
     return True
     
@@ -71,19 +71,19 @@
     """
     for s in symbol:
         if s[1] == 1:
-	    if s[3] == 0 or s[2] != s[4]:
-	        return False
+            if s[3] == 0 or s[2] != s[4]:
+                return False
         if s[1] == 2 and s[3] == 1:
-	    if s[2] in (1,-1):
-	       if not s[4] in (0,2,6):
-	          return False
-	    if s[2] in (3,-3):
-	       if not s[4] in (2,4,6):
-	          return False
+            if s[2] in (1,-1):
+               if not s[4] in (0,2,6):
+                  return False
+            if s[2] in (3,-3):
+               if not s[4] in (2,4,6):
+                  return False
         if (s[1] - s[4])% 2 == 1:
-	    return False
-	if s[3] == 0 and s[4] != 0:
-	    return False
+            return False
+        if s[3] == 0 and s[4] != 0:
+            return False
     return True
 
 def canonical_2_adic_compartments(symbol):
@@ -97,14 +97,14 @@
         s = symbol[i]
         if s[3] == 1:
             v = s[0]
-	    c = []
-  	    while i < r and symbol[i][3] == 1 and symbol[i][0] == v:
-	    	c.append(i)
- 	        i += 1 
+            c = []
+            while i < r and symbol[i][3] == 1 and symbol[i][0] == v:
+                c.append(i)
+                i += 1 
                 v += 1
             compartments.append(c)
-        else:	
-	    i += 1
+        else:   
+            i += 1
     return compartments 
     
 def canonical_2_adic_trains(symbol, compartments):
@@ -117,7 +117,7 @@
         flag = True
         train = [ ]
         while flag:
-	    ci = compartments[i]
+            ci = compartments[i]
             j = ci[0]
             if j == 0 or symbol[j-1][0] != symbol[j][0] - 1:
                 train += ci
@@ -129,13 +129,13 @@
             else:
                 if act < len(symbol) and symbol[act][0] == symbol[act-1][0] +1: 
                     train += [act]
-	        flag = False
+                flag = False
             if flag and symbol[ci[len(ci)-1]][0]+2 != symbol[ci_plus[0]][0]:
                 if act != ci_plus[0] and symbol[act][0] == symbol[act-1][0] +1:
                     train += [act]
                 flag = False
             i += 1
-	trains.append(train)
+        trains.append(train)
     return trains
 
 def canonical_2_adic_reduction(symbol):
@@ -145,31 +145,31 @@
     # Canonical determinants:
     for i in range(len(symbol)):
         d = symbol[i][2]
-	if d in (1,7):
+        if d in (1,7):
             canonical_symbol[i][2] = 1 
-	else:
+        else:
             canonical_symbol[i][2] = -1 
     # Oddity fusion:
     compartments = canonical_2_adic_compartments(symbol)
     for compart in compartments:
         oddity = sum([ symbol[i][4] for i in compart ]) % 8
-	for i in compart:
-	    symbol[i][4] = 0
+        for i in compart:
+            symbol[i][4] = 0
         symbol[compart[0]][4] = oddity
     #print "End oddity fusion:", canonical_symbol
-    # Sign walking:	
+    # Sign walking:     
     trains = canonical_2_adic_trains(symbol, compartments)
     for train in trains:
         t = len(train)
-	for i in range(t-1):
-	    t1 = train[t-i-1]
-	    if canonical_symbol[t1][2] == -1:
-	        canonical_symbol[t1][2] = 1
-	        canonical_symbol[t1-1][2] *= -1
-		for compart in compartments:
-		    if t1-1 in compart or t1 in compart:
-		        o = canonical_symbol[compart[0]][4]
-		        canonical_symbol[compart[0]][4] = (o+4) % 8
+        for i in range(t-1):
+            t1 = train[t-i-1]
+            if canonical_symbol[t1][2] == -1:
+                canonical_symbol[t1][2] = 1
+                canonical_symbol[t1-1][2] *= -1
+                for compart in compartments:
+                    if t1-1 in compart or t1 in compart:
+                        o = canonical_symbol[compart[0]][4]
+                        canonical_symbol[compart[0]][4] = (o+4) % 8
     #print "End sign walking:", canonical_symbol
     return canonical_symbol
 
@@ -178,25 +178,25 @@
     Given an echelonized basis matrix (over a field), 
     calculate a matrix whose rows form a basis complement.
     """
-    F = B.parent().base_ring()	
-    m = B.nrows()	
-    n = B.ncols()	
+    F = B.parent().base_ring()  
+    m = B.nrows()       
+    n = B.ncols()       
     C = MatrixSpace(F,n-m,n,sparse=True)(0)
-    k = 0	
-    l = 0	
+    k = 0       
+    l = 0       
     for i in range(m):
         for j in range(k,n):
              if B[i,j] == 0:
                  C[l,j] = 1
-	         l += 1
-	     else:
+                 l += 1
+             else:
                  k = j+1
                  break
     for j in range(k,n):
-	C[l+j-k,j] = 1
+        C[l+j-k,j] = 1
     return C
 
-def signature(A):
+def signature_of_matrix(A):
     """
     The signature of a non-degenerate symmetric matrix.
 
@@ -207,11 +207,11 @@
     e0 = 1
     for i in range(A.nrows()):
         # Argh!...
-	e1 = RealField()(A[0:i+1, 0:i+1].determinant()).sign()
-	if e0*e1 == 1:
-	   r += 1
-        else:		
-	   s += 1
+        e1 = RealField()(A[0:i+1, 0:i+1].determinant()).sign()
+        if e0*e1 == 1:
+           r += 1
+        else:           
+           s += 1
         e0 = e1
     return (r, s)
 
@@ -222,27 +222,27 @@
     needed to obtain enough precision 
     calculation is modulo p to the val+3 
     TODO: Some description of the definition of the genus symbol.
-    """	
+    """ 
     if p % 2 == 0:
         return two_adic_symbol(A, val)
     m0 = min([ c.valuation(p) for c in A.list() ])
     q = p**m0
     n = A.nrows()
-    A = MatrixSpace(IntegerRing(),n,n)([ c // q for c in A.list() ])	
-    A_p = MatrixSpace(FiniteField(p),n,n)(A)	
+    A = MatrixSpace(IntegerRing(),n,n)([ c // q for c in A.list() ])    
+    A_p = MatrixSpace(FiniteField(p),n,n)(A)    
     B_p = A_p.kernel().echelonized_basis_matrix()
     if B_p.nrows() == 0:
-        e0 = Integer(A_p.det()).kronecker(p)	
-        n0 = A.nrows()	
+        e0 = Integer(A_p.det()).kronecker(p)    
+        n0 = A.nrows()  
         return [ [m0,n0,e0] ]
     else:
         C_p = basis_complement(B_p)    
         e0 = Integer((C_p*A_p*C_p.transpose()).det()).kronecker(p)
         n0 = C_p.nrows()
         sym = [ [0,n0,e0] ]
-    r = B_p.nrows()	
-    B = MatrixSpace(IntegerRing(),r,n)(B_p)	
-    C = MatrixSpace(IntegerRing(),n-r,n)(C_p)	
+    r = B_p.nrows()     
+    B = MatrixSpace(IntegerRing(),r,n)(B_p)     
+    C = MatrixSpace(IntegerRing(),n-r,n)(C_p)   
     # Construct the blocks for the Jordan decomposition [F,X;X,A_new]
     F = MatrixSpace(RationalField(),n-r,n-r)(C*A*C.transpose())
     U = F**-1
@@ -261,7 +261,7 @@
 def is_even(A):
     for i in range(A.nrows()):
         if A[i,i]%2 == 1:
-	    return False, i
+            return False, i
     return True, -1
 
 def split_odd(A):
@@ -278,38 +278,38 @@
     u = A[i,i]
     for j in range(n0-1):
         if j < i:
-	    C[j,j] = 1
-	    C[j,i] = -A[j,i]*u 
+            C[j,j] = 1
+            C[j,i] = -A[j,i]*u 
         else:
-	    C[j,j+1] = 1
-	    C[j,i] = -A[j+1,i]*u 
+            C[j,j+1] = 1
+            C[j,i] = -A[j+1,i]*u 
         B = C*A*C.transpose()
     even, j = is_even(B)
     if even:
         I = A.parent()(1)
-	# TODO: we could manually (re)construct the kernel here...
-	if i == 0:
-	    I[1,0] = 1 - A[1,0]*u
-	    i = 1
-	else:
-	    I[0,i] = 1 - A[0,i]*u
-	    i = 0
-	A = I*A*I.transpose()
-	u = A[i,i]    
+        # TODO: we could manually (re)construct the kernel here...
+        if i == 0:
+            I[1,0] = 1 - A[1,0]*u
+            i = 1
+        else:
+            I[0,i] = 1 - A[0,i]*u
+            i = 0
+        A = I*A*I.transpose()
+        u = A[i,i]    
         C = MatrixSpace(R,n0-1,n0)(0)
-	for j in range(n0-1):
-	    if j < i:
-	       C[j,j] = 1
-	       C[j,i] = -A[j,i]*u 
+        for j in range(n0-1):
+            if j < i:
+               C[j,j] = 1
+               C[j,i] = -A[j,i]*u 
             else:
-		C[j,j+1] = 1
-		C[j,i] = -A[j+1,i]*u 
-	    B = C*A*C.transpose()
+                C[j,j+1] = 1
+                C[j,i] = -A[j+1,i]*u 
+            B = C*A*C.transpose()
     even, j = is_even(B)
     if even:
         print "B:"
         print B
-	assert False
+        assert False
     return u, B
 
 def trace_diag(A):
@@ -333,56 +333,56 @@
     where 
         m = valuation of the component
         n = dimension of f
-	d = det(f) in {1,3,5,7}
+        d = det(f) in {1,3,5,7}
         s = 0 (or 1) if even (or odd)
-	o = oddity of f (= 0 if s = 0) in Z/8Z
-    """	
+        o = oddity of f (= 0 if s = 0) in Z/8Z
+    """ 
     m0 = min([ c.valuation(2) for c in A.list() ])
     q = 2**m0
     A = A.parent()([ c // q for c in A.list() ])
     ZZ = IntegerRing()
     n = A.nrows()
-    A_2 = MatrixSpace(FiniteField(2),n,n)(A)	
+    A_2 = MatrixSpace(FiniteField(2),n,n)(A)    
     K_2 = A_2.kernel()
     R_8 = ZZ.quotient_ring(Integer(8))
     if K_2.dimension() == 0:
-	A_8 = MatrixSpace(R_8,n)(A)
-        n0 = A.nrows()	
+        A_8 = MatrixSpace(R_8,n)(A)
+        n0 = A.nrows()  
         # d0 = ZZ(A_8.determinant()) # no determinant over Z/8Z
         d0 = ZZ(R_8(MatrixSpace(ZZ,n)(A_8).determinant()))
-	if d0 == 0:
-	    print "A:"
-	    print A
-	    assert False
-	even, i = is_even(A_2)
-	if even:
-	    return [ [m0,n0,d0,0,0] ]
-	else:
-	    tr8 = trace_diag(A_8)
-	    return [ [m0,n0,d0,1,tr8] ]
+        if d0 == 0:
+            print "A:"
+            print A
+            assert False
+        even, i = is_even(A_2)
+        if even:
+            return [ [m0,n0,d0,0,0] ]
+        else:
+            tr8 = trace_diag(A_8)
+            return [ [m0,n0,d0,1,tr8] ]
     else:
         B_2 = K_2.echelonized_basis_matrix()
         C_2 = basis_complement(B_2)    
-	n0 = C_2.nrows()
-	C = MatrixSpace(ZZ,n0,n)(C_2)
+        n0 = C_2.nrows()
+        C = MatrixSpace(ZZ,n0,n)(C_2)
         A_new = C*A*C.transpose()
-	# compute oddity modulo 8:
+        # compute oddity modulo 8:
         A_8 = MatrixSpace(R_8,n0,n0)(A_new)
-	# d0 = A_8.det() # no determinant over Z/8Z
+        # d0 = A_8.det() # no determinant over Z/8Z
         d0 = ZZ(R_8(MatrixSpace(ZZ,n0,n0)(A_8).determinant()))
-	if d0 == 0:
-	    print "A:"
-	    print A_new
-	    assert False
-	even, i = is_even(A_new)
-	if even:
-	    sym = [ [0,n0,d0,0,0] ]
-	else:
-	    tr8 = trace_diag(A_8)
-	    sym = [ [0,n0,d0,1,tr8] ]
+        if d0 == 0:
+            print "A:"
+            print A_new
+            assert False
+        even, i = is_even(A_new)
+        if even:
+            sym = [ [0,n0,d0,0,0] ]
+        else:
+            tr8 = trace_diag(A_8)
+            sym = [ [0,n0,d0,1,tr8] ]
     r = B_2.nrows()
     B = MatrixSpace(ZZ,r,n)(B_2)
-    C = MatrixSpace(IntegerRing(),n-r,n)(C_2)	
+    C = MatrixSpace(IntegerRing(),n-r,n)(C_2)   
     F = MatrixSpace(RationalField(),n-r,n-r)(C*A*C.transpose())
     U = F**-1
     d = LCM([ c.denominator() for c in U.list() ])
@@ -410,12 +410,12 @@
     """
     def __init__(self, prime, symbol, check = True):
         """
-	Create the local genus symbol of given prime and local invariants.
+        Create the local genus symbol of given prime and local invariants.
 
-	INPUT:
-	     prime -- the prime 
-	     symbol -- the list of invariants for Jordan blocks A_t,...,A_t 
-	     
+        INPUT:
+             prime -- the prime 
+             symbol -- the list of invariants for Jordan blocks A_t,...,A_t 
+             
         The genus symbol of a component p^m*A for odd prime = p is of the 
         form (m,n,d), where 
 
@@ -431,26 +431,26 @@
             d = det(A) in {1,3,5,7}
             s = 0 (or 1) if even (or odd)
             o = oddity of A (= 0 if s = 0) in Z/8Z
-	      = the trace of the diagonalization of A
+              = the trace of the diagonalization of A
 
-	The genus symbol is a list of such symbols (ordered by m) for each 
+        The genus symbol is a list of such symbols (ordered by m) for each 
         of the Jordan blocks A_1,...,A_t.
 
-	Reference: Conway and Sloane, Chapter 9.
-	"""
-	if check:
-	   pass
-	self._prime = prime
-	self._symbol = symbol
-	self._canonical_symbol = None
+        Reference: Conway and Sloane, Chapter 9.
+        """
+        if check:
+           pass
+        self._prime = prime
+        self._symbol = symbol
+        self._canonical_symbol = None
 
     def __repr__(self):
         return "Genus symbol at %s : %s"%(self._prime, self._symbol)
 
     def __eq__(self,other):
         p = self._prime
-	if p != other._prime:
-	    return False
+        if p != other._prime:
+            return False
         return self.canonical_symbol() == other.canonical_symbol()
 
     def __ne__(self,other):
@@ -459,11 +459,11 @@
     def canonical_symbol(self):
         symbol = self._symbol
         if self._prime == 2:
-	    if self._canonical_symbol is None:
-  	        self._canonical_symbol = canonical_2_adic_reduction(symbol)
-	    return self._canonical_symbol 
-	else:
-	    return self._symbol
+            if self._canonical_symbol is None:
+                self._canonical_symbol = canonical_2_adic_reduction(symbol)
+            return self._canonical_symbol 
+        else:
+            return self._symbol
 
     def symbol(self):
         return self._symbol
@@ -483,31 +483,31 @@
 
     def excess(self):
         """
-	The p-excesss in the notation of Conway & Sloane, and the oddity for p = 2.  
+        The p-excesss in the notation of Conway & Sloane, and the oddity for p = 2.  
         """
-	p = self._prime
+        p = self._prime
         if self._prime == 2:
-	   k = 0
-	   for s in self._symbol:
-	       if s[0]%2 == 1 and s[2] in (3,5):
-	           k += 1
+           k = 0
+           for s in self._symbol:
+               if s[0]%2 == 1 and s[2] in (3,5):
+                   k += 1
            return Integer(sum([ s[4] for s in self._symbol ]) + 4*k).mod(8)
         else:
-	   k = 0
-	   for s in self._symbol:
-	       if s[0]%2 == 1 and s[2] == -1:
-	           k += 1
+           k = 0
+           for s in self._symbol:
+               if s[0]%2 == 1 and s[2] == -1:
+                   k += 1
            return Integer(sum([ s[1]*(p**s[0]-1) for s in self._symbol ]) + 4*k).mod(8)
 
     def trains(self):
         assert self._prime == 2
-	symbol = self._symbol
+        symbol = self._symbol
         compartments = canonical_2_adic_compartments(symbol)
         return canonical_2_adic_trains(symbol, compartments)
 
     def compartments(self):
         assert self._prime == 2
-	symbol = self._symbol
+        symbol = self._symbol
         return canonical_2_adic_compartments(symbol)
 
 
@@ -517,41 +517,41 @@
     """
     def __init__(self, A, max_elem_divisors=None):
         """
-	Input precision max_elem_divisors for valuation of maximal p-elementary divisor.
+        Input precision max_elem_divisors for valuation of maximal p-elementary divisor.
         """
         D = A.determinant()
         D = 2*D
         prms = [ p[0] for p in D.factor() ]
-	self._representative = A
-	self._signature = signature(A)
-	self._local_symbols = []
-	for p in prms:
-	    if max_elem_divisors is None:
-	        val = D.valuation(p)
-	    symbol = p_adic_symbol(A, p, val = val)
- 	    G = Genus_Symbol_p_adic_ring(p, symbol)	        
-      	    self._local_symbols.append(G)
+        self._representative = A
+        self._signature = signature_of_matrix(A)
+        self._local_symbols = []
+        for p in prms:
+            if max_elem_divisors is None:
+                val = D.valuation(p)
+            symbol = p_adic_symbol(A, p, val = val)
+            G = Genus_Symbol_p_adic_ring(p, symbol)             
+            self._local_symbols.append(G)
 
     def __repr__(self):
         return "Genus of %s"%self._representative
 
     def __eq__(self, other):
         if self is other:
-	    return True 
-	t = len(self._local_symbols)
+            return True 
+        t = len(self._local_symbols)
         if t != len(other._local_symbols):
-	    return False
-	for i in range(t):
-	    if self._local_symbols[i] != other._local_symbols[i]:
-	        return False
+            return False
+        for i in range(t):
+            if self._local_symbols[i] != other._local_symbols[i]:
+                return False
         return True
 
     def __ne__(self, other):
         return not self.__eq__(other)
 
-    def signature(self):
+    def signature_of_matrix(self):
         return self._signature
 
     def determinant(self):
-        r, s = self.signature()
+        r, s = self.signature_of_matrix()
         return (-1)**s*misc.prod([ G.determinant() for G in self._local_symbols ])
diff --git a/sage/quadratic_forms/quadratic_form.py b/sage/quadratic_forms/quadratic_form.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form.py
@@ -0,0 +1,1106 @@
+"""
+Quadratic Forms
+
+AUTHORS:
+    -- Jon Hanke (2007-06-19): 
+
+"""
+
+#*****************************************************************************
+#       Copyright (C) 2007 William Stein and Jonathan Hanke
+#
+#  Distributed under the terms of the GNU General Public License (GPL)
+#
+#    This code is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#    General Public License for more details.
+#
+#  The full text of the GPL is available at:
+#
+#                  http://www.gnu.org/licenses/
+#*****************************************************************************
+
+from warnings import warn
+from copy import deepcopy
+
+from sage.matrix.constructor import matrix
+from sage.matrix.matrix_space import MatrixSpace
+from sage.matrix.matrix import Matrix, is_Matrix
+from sage.rings.integer import is_Integer
+from sage.rings.integer_ring import IntegerRing, ZZ
+from sage.rings.rational_field import RationalField, QQ
+from sage.rings.ring import Ring
+from sage.misc.functional import ideal, denominator
+from sage.rings.arith import GCD, LCM, valuation, kronecker_symbol
+from sage.rings.fraction_field import FractionField
+from sage.quadratic_forms.extras import IsPadicSquare
+from sage.rings.principal_ideal_domain import is_PrincipalIdealDomain
+from sage.rings.ring import is_Ring
+from sage.matrix.matrix import is_Matrix
+from sage.structure.element import is_Vector
+
+from sage.quadratic_forms.quadratic_form__evaluate import QFEvaluateVector, QFEvaluateMatrix
+
+
+
+def QuadraticForm__constructor(R, n=None, entries=None):
+    """
+    Wrapper for the QuadraticForm class constructor.  This is meant
+    for internal use within the QuadraticForm class code only.  You
+    should instead directly call QuadraticForm().
+    """
+    return QuadraticForm(R, n, entries)
+
+
+def is_QuadraticForm(Q):
+    """
+    Determines if the object Q is an element of the QuadraticForm class.
+    """
+    return isinstance(Q, QuadraticForm)
+
+
+
+class QuadraticForm():
+    """
+    QuadraticForm() -- a quadratic form in n variables with coefficients in the ring R.
+    """
+
+    ## Import specialized methods:
+    ## ---------------------------
+    #from sage.quadratic_forms.hi import *    ## This is just a test, but it works! =) 
+
+    from sage.quadratic_forms.quadratic_form__local_normal_form \
+    import find_entry_with_minimal_scale_at_prime, local_normal_form, jordan_blocks_by_scale_and_unimodular, \
+        jordan_blocks_in_unimodular_list_by_scale_power              ## Routines to compute the p-adic local normal form.
+
+    from sage.quadratic_forms.quadratic_form__variable_substitutions \
+    import swap_variables, multiply_variable, divide_variable, scale_by_factor, \
+        extract_variables, elementary_substitution, add_symmetric    ## Routines to perform elementary variable substitutions.
+
+    from sage.quadratic_forms.quadratic_form__local_field_invariants \
+    import rational_diagonal_form, signature, local_diagonal, hasse_invariant, hasse_invariant__OMeara, \
+        is_anisotropic, is_isotropic, anisotropic_primes, compute_definiteness, \
+        is_positive_definite, is_negative_definite, is_indefinite, is_definite    ## Routines to compute p-adic field invariants
+
+    from sage.quadratic_forms.quadratic_form__local_density_congruence \
+    import *                                         ## Routines to compute local densities by the reduction procedure
+
+    from sage.quadratic_forms.quadratic_form__count_local_2 \
+    import *                                         ## Routines to compute local densities by counting solutions of various types
+        
+    from sage.quadratic_forms.quadratic_form__local_density_interfaces \
+    import *                                         ## Routines to be called by the user to compute local densities
+
+    from sage.quadratic_forms.quadratic_form__ternary_Tornaria \
+    import *                                         ## Routines for computing with ternary forms
+
+    from sage.quadratic_forms.quadratic_form__theta \
+    import *                                         ## Routines to compute the theta function
+
+    from sage.quadratic_forms.quadratic_form__siegel_product \
+    import *                                         ## Routines to compute the product of all local densities
+
+    from sage.quadratic_forms.quadratic_form__neighbors import \
+    find_primitive_p_divisible_vector__random, \
+    find_primitive_p_divisible_vector__all, \
+    find_primitive_p_divisible_vector__next, \
+    find_p_neighbor_from_vec                       ## Routines to compute p-neighbors
+
+    from sage.quadratic_forms.quadratic_form__reduction_theory \
+    import *                                       ## Routines to reduce a given quadratic form
+ 
+    from sage.quadratic_forms.quadratic_form__genus \
+    import global_genus_symbol, local_genus_symbol, CS_genus_symbol_list   ## Wrappers for Conway-Sloane genus routines (in ./genera/)
+
+    from sage.quadratic_forms.quadratic_form__mass \
+    import *                                       ## Routines to compute local masses for ZZ.
+
+    from sage.quadratic_forms.quadratic_form__local_representation_conditions \
+    import *                                       ## Routines to check local representatbility of numbers
+
+    from sage.quadratic_forms.quadratic_form__split_local_covering \
+    import *                                       ## Routines to make a split local covering of the given quadratic form.
+
+    from sage.quadratic_forms.quadratic_form__automorphisms \
+    import *                                       ## Routines to make automorphisms of the given quadratic form.
+
+    from sage.quadratic_forms.quadratic_form__equivalence_testing \
+    import *                                       ## Routines to test the local and global equivalence/isometry of two quadratic forms.
+
+
+ 
+
+    def __init__(self, R, n=None, entries=None, unsafe_initialization=False, number_of_automorphisms=None, determinant=None):
+        """
+        INPUT:
+            R -- ring for which the quadratic form is defined
+            n -- an integer >= 0 
+            entries -- a list of n(n+1)/2 coefficients of the quadratic form in R 
+                (given lexographically, or equivalently, by rows of the matrix)
+    
+                ** OR **
+    
+            R -- a ring
+            n -- a symmetric n x n matrix with even diagonal (relative to n)
+    
+                ** OR **
+    
+            R -- a symmetric n x n matrix with even diagonal (relative to its base_ring)
+
+            If unsafe_initialize is True, then the subsequent fields
+            may by used to force the external initialization of
+            various fields of the quadratic form.  Currently the only
+            fields which can be set are:
+
+                number_of_automorphisms
+                determinant
+
+
+    
+        OUTPUT:
+            quadratic form
+    
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 3, [1,2,3,4,5,6])
+            sage: Q
+            Quadratic form in 3 variables over Integer Ring with coefficients: 
+            [ 1 2 3 ]
+            [ * 4 5 ]
+            [ * * 6 ]
+    
+            sage: Q = QuadraticForm(QQ, 3, [1,2,3,4/3 ,5,6])
+            sage: Q
+            Quadratic form in 3 variables over Rational Field with coefficients: 
+            [ 1 2 3 ]
+            [ * 4/3 5 ]
+            [ * * 6 ]
+            sage: Q[0,0]
+            1
+            sage: Q[0,0].parent()
+            Rational Field
+    
+            sage: Q = QuadraticForm(QQ, 7, range(28))
+            sage: Q
+            Quadratic form in 7 variables over Rational Field with coefficients: 
+            [ 0 1 2 3 4 5 6 ]
+            [ * 7 8 9 10 11 12 ]
+            [ * * 13 14 15 16 17 ]
+            [ * * * 18 19 20 21 ]
+            [ * * * * 22 23 24 ]
+            [ * * * * * 25 26 ]
+            [ * * * * * * 27 ]
+    
+            sage: Q = QuadraticForm(QQ, 2, range(1,4))
+            sage: A = Matrix(ZZ,2,2,[-1,0,0,1])
+            sage: Q(A)
+            Quadratic form in 2 variables over Rational Field with coefficients: 
+            [ 1 -2 ]
+            [ * 3 ]
+    
+    
+            sage: m = matrix(2,2,[1,2,3,4])
+            sage: m + m.transpose() 
+            [2 5]
+            [5 8]
+            sage: QuadraticForm(m + m.transpose())
+            Quadratic form in 2 variables over Integer Ring with coefficients: 
+            [ 1 5 ]
+            [ * 4 ]
+    
+
+            sage: QuadraticForm(ZZ, m + m.transpose())
+            Quadratic form in 2 variables over Integer Ring with coefficients: 
+            [ 1 5 ]
+            [ * 4 ]
+    
+            sage: QuadraticForm(QQ, m + m.transpose())
+            Quadratic form in 2 variables over Rational Field with coefficients: 
+            [ 1 5 ]
+            [ * 4 ]
+    
+        """
+        ## Deal with:  QuadraticForm(ring, matrix)
+        matrix_init_flag = False
+        if isinstance(R, Ring):
+            if is_Matrix(n):
+                ## Test if n is symmetric and has even diagonal
+                if not self._is_even_symmetric_matrix_(n, R):
+                    raise TypeError, "Oops!  The matrix is not a symmetric with even diagonal defined over R."
+        
+                ## Rename the matrix and ring
+                M = n  
+                M_ring = R
+                matrix_init_flag = True
+    
+
+        ## Deal with:  QuadraticForm(matrix) 
+        if is_Matrix(R) and (n == None):
+
+            ## Test if R is symmetric and has even diagonal
+            if not self._is_even_symmetric_matrix_(R):
+                raise TypeError, "Oops!  The matrix is not a symmetric with even diagonal."
+    
+            ## Rename the matrix and ring
+            M = R  
+            M_ring = R.base_ring()
+            matrix_init_flag = True
+    
+        ## Perform the quadratic form initialization
+        if matrix_init_flag == True:
+            self.__n = M.nrows()
+            self.__base_ring = M_ring
+            self.__coeffs = []
+            for i in range(M.nrows()):
+                for j in range(i, M.nrows()):
+                    if (i == j):
+                        self.__coeffs += [ M_ring(M[i,j] / 2) ]
+                    else:
+                        self.__coeffs += [ M_ring(M[i,j]) ]    
+        
+            return
+    
+        ## -----------------------------------------------------------
+
+        ## Verify the size of the matrix is an integer >= 0
+        try:
+            n = int(n)    
+        except:
+            raise TypeError, "Oops! The size " + str(n) + " must be an integer."
+            if (n < 0):
+                raise TypeError, "Oops! The size " + str(n) + " must be a non-negative integer."
+    
+        ## TODO: Verify that R is a ring...
+    
+        ## Store the relevant variables
+        N = int(n*(n+1))/2
+        self.__n = int(n)
+        self.__base_ring = R
+        self.__coeffs = [self.__base_ring(0)  for i in range(N)]
+    
+        ## Check if entries is a list for the current size, and if so, write the upper-triangular matrix
+        if isinstance(entries, list) and (len(entries) == N):
+            for i in range(N):
+                self.__coeffs[i] = self.__base_ring(entries[i])
+        elif (entries != None):
+            raise TypeError, "Oops! The entries " + str(entries) + "must be a list of size n(n+1)/2."
+
+        ## -----------------------------------------------------------
+
+        ## Process possible forced initialization of various fields
+        self._external_initialization_list = []
+        if unsafe_initialization:
+
+            ## Set the number of automorphisms
+            if number_of_automorphisms != None:
+                self.set_number_of_automorphisms(number_of_automorphisms)
+                #self.__number_of_automorphisms = number_of_automorphisms
+                #self.__external_initialization_list.append('number_of_automorphisms')
+
+            ## Set the determinant
+            if determinant != None:
+                self.__det = determinant
+                self._external_initialization_list.append('determinant')
+
+
+    def list_external_initializations(self):
+        """
+        Returns a list of the fields which were set externally at
+        creation, and not created through the usual QuadraticForm
+        methods.  These fields are as good as the external process
+        that made them, and are thus not guaranteed to be correct.
+        """
+        return deepcopy(self._external_initialization_list)
+
+
+    def _pari_(self):
+        return self.matrix()._pari_()
+
+    def __repr__(self):
+        """
+        Print the matrix.
+        """
+        n = self.dim()
+        out_str = "Quadratic form in " + str(n) + " variables over " + str(self.base_ring()) + " with coefficients: \n"
+        for i in range(n):
+            out_str += "[ "
+            for j in range(n):
+                if (i > j):
+                    out_str += "* "
+                else:
+                    out_str += str(self[i,j]) + " "
+            out_str += "]\n"
+        return out_str
+
+
+    def _latex_(self):
+        """
+        Gives a LaTeX representation.
+        """
+        n = self.dim()
+        out_str = ""
+        out_str += "Quadratic form in " + str(n) + " variables over " + str(self.base_ring()) 
+        out_str += " with coefficients: \\newline"
+        out_str += "\\left[ \\begin{array}{" + n * "c" + "}"
+        for i in range(n):
+            for j in range(n):
+                if (i > j):
+                    out_str += " * & "
+                else:
+                    out_str += str(self[i,j]) + " & "
+#            if i < (n-1):
+#                out_str += "\\"
+        out_str += "\\end{array} \\right]"
+        return out_str
+
+
+
+    def __getitem__(self, ij):
+        """
+        Return the coefficient a_{ij} of x_i * x_j.
+    
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 3, [1,2,3,4,5,6])
+            sage: matrix(ZZ, 3, 3, [Q[i,j]  for i in range(3) for j in range(3)])
+            [1 2 3]
+            [2 4 5]
+            [3 5 6]
+    
+        """
+        ## Unpack the list of indices
+        i, j =  ij
+        i = int(i)
+        j = int(j)
+    
+        ## Ensure we're using upper-triangular coordinates
+        if i > j:
+            tmp = i
+            i = j
+            j = tmp
+    
+        return self.__coeffs[i*self.__n - i*(i-1)/2 + j - i] 
+
+
+    def __setitem__(self, ij, coeff):
+        """
+        Set the coefficient a_{ij} in front of x_i * x_j.
+    
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 3, [1,2,3,4,5,6])
+            sage: Q
+            Quadratic form in 3 variables over Integer Ring with coefficients: 
+            [ 1 2 3 ]
+            [ * 4 5 ]
+            [ * * 6 ] 
+            sage: Q[2,1] = 17
+            sage: Q
+            Quadratic form in 3 variables over Integer Ring with coefficients: 
+            [ 1 2 3 ]
+            [ * 4 17 ]
+            [ * * 6 ]
+    
+        """
+        ## Unpack the list of indices
+        i, j =  ij
+        i = int(i)
+        j = int(j)
+    
+        ## TO DO:  Verify that 0 <= i, j <= (n-1)
+    
+        ## Ensure we're using upper-triangular coordinates
+        if i > j:
+            tmp = i
+            i = j
+            j = tmp
+
+        ## Set the entry
+        try:
+            self.__coeffs[i*self.__n - i*(i-1)/2 + j -i] = self.__base_ring(coeff) 
+        except:
+            raise RuntimeError, "Oops!  This coefficient can't be coerced to an element of the base ring for the quadratic form."
+
+
+######################################
+# TO DO:    def __cmp__(self, other):
+######################################
+
+    def __eq__(self, right):
+        """
+        Determines if two quadratic forms are equal.
+    
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [1,4,10])
+            sage: Q == Q
+            True
+    
+            sage: Q1 = QuadraticForm(QQ, 2, [1,4,10])
+            sage: Q == Q1
+            False
+    
+            sage: Q2 = QuadraticForm(ZZ, 2, [1,4,-10])
+            sage: Q == Q1
+            False
+            sage: Q == Q2
+            False
+            sage: Q1 == Q2
+            False
+    
+        """    
+        if not isinstance(right, QuadraticForm):
+            return False
+        return (self.__base_ring == right.__base_ring) and (self.__coeffs == right.__coeffs)
+
+
+    def __add__(self, right):
+          """
+          Returns the direct sum of two quadratic forms.
+      
+          EXAMPLES:
+              sage: Q = QuadraticForm(ZZ, 2, [1,4,10])
+              sage: Q
+              Quadratic form in 2 variables over Integer Ring with coefficients: 
+              [ 1 4 ]
+              [ * 10 ]      
+              sage: Q2 = QuadraticForm(ZZ, 2, [1,4,-10])
+              sage: Q + Q2
+              Quadratic form in 4 variables over Integer Ring with coefficients: 
+              [ 1 4 0 0 ]
+              [ * 10 0 0 ]
+              [ * * 1 4 ]
+              [ * * * -10 ]
+      
+          """
+          if not isinstance(right, QuadraticForm):    
+              raise TypeError, "Oops!  Can't add these objects since they're not both quadratic forms. =("
+          elif (self.base_ring() != right.base_ring()):
+              raise TypeError, "Oops!  Can't add these since the quadratic forms don't have the same base rings... =("
+          else:
+              Q = QuadraticForm(self.base_ring(), self.dim() + right.dim())
+              n = self.dim()
+              m = right.dim()
+
+              for i in range(n):
+                  for j in range(i,n):
+                      Q[i,j] = self[i,j]
+
+              for i in range(m):
+                  for j in range(i,m):
+                      Q[n+i,n+j] = right[i,j]
+                      
+              return Q
+
+
+    def sum_by_coefficients_with(self, right):
+          """
+          Returns the sum (on coefficients) of two quadratic forms of the same size.
+      
+          EXAMPLES:
+              sage: Q = QuadraticForm(ZZ, 2, [1,4,10])
+              sage: Q
+              Quadratic form in 2 variables over Integer Ring with coefficients: 
+              [ 1 4 ]
+              [ * 10 ]
+              sage: Q+Q
+              Quadratic form in 4 variables over Integer Ring with coefficients: 
+              [ 1 4 0 0 ]
+              [ * 10 0 0 ]
+              [ * * 1 4 ]
+              [ * * * 10 ]
+
+              sage: Q2 = QuadraticForm(ZZ, 2, [1,4,-10])
+              sage: Q.sum_by_coefficients_with(Q2)
+              Quadratic form in 2 variables over Integer Ring with coefficients: 
+              [ 2 8 ]
+              [ * 0 ]
+      
+          """
+          if not isinstance(right, QuadraticForm):    
+              raise TypeError, "Oops!  Can't add these objects since they're not both quadratic forms. =("
+          elif (self.__n != right.__n):
+              raise TypeError, "Oops!  Can't add these since the quadratic forms don't have the same sizes... =("
+          elif (self.__base_ring != right.__base_ring):
+              raise TypeError, "Oops!  Can't add these since the quadratic forms don't have the same base rings... =("
+          else:
+              return QuadraticForm(self.__base_ring, self.__n, [self.__coeffs[i] + right.__coeffs[i]  for i in range(len(self.__coeffs))])
+
+
+## ========================  CHANGE THIS TO A TENSOR PRODUCT?!?  Even in Characteristic 2?!?  =======================
+#    def __mul__(self, right):
+#        """
+#        Multiply (on the right) the quadratic form Q by an element of the ring that Q is defined over.
+#    
+#        EXAMPLES:
+#            sage: Q = QuadraticForm(ZZ, 2, [1,4,10])
+#            sage: Q*2
+#            Quadratic form in 2 variables over Integer Ring with coefficients: 
+#            [ 2 8 ]
+#            [ * 20 ]
+#    
+#            sage: Q+Q == Q*2
+#            True
+#    
+#        """
+#        try:
+#            c = self.base_ring()(right)
+#        except:
+#            raise TypeError, "Oh no! The multiplier cannot be coerced into the base ring of the quadratic form. =("
+#    
+#        return QuadraticForm(self.base_ring(), self.dim(), [c * self.__coeffs[i]  for i in range(len(self.__coeffs))])
+# =========================================================================================================================
+
+
+
+    def __call__(self, v):
+        """
+        Evaluate this quadratic form Q on a vector or matrix of elements
+        coercible to the base ring of the quadratic form.  If a vector
+        is given then the output will be the ring element Q(v), but if a
+        matrix is given then the output will be the quadratic form Q'
+        which in matrix notation is given by:
+        
+                Q' = v^t * Q * v.
+    
+    
+        EXAMPLES:
+            ## Evaluate a quadratic form at a vector:
+            ## --------------------------------------
+            sage: Q = QuadraticForm(QQ, 3, range(6))
+            sage: Q
+            Quadratic form in 3 variables over Rational Field with coefficients: 
+            [ 0 1 2 ]
+            [ * 3 4 ]
+            [ * * 5 ]
+            sage: Q([1,2,3])
+            89
+            sage: Q([1,0,0])
+            0
+            sage: Q([1,1,1])
+            15
+
+            ## Evaluate a quadratic form using a column matrix:
+            ## ------------------------------------------------
+            sage: Q = QuadraticForm(QQ, 2, range(1,4))
+            sage: A = Matrix(ZZ,2,2,[-1,0,0,1])
+            sage: Q(A)
+            Quadratic form in 2 variables over Rational Field with coefficients: 
+            [ 1 -2 ]
+            [ * 3 ]
+            sage: Q([1,0])
+            1
+            sage: type(Q([1,0]))
+            <type 'sage.rings.rational.Rational'>
+            sage: Q = QuadraticForm(QQ, 2, range(1,4))
+            sage: Q(matrix(2, [1,0]))
+            Quadratic form in 1 variables over Rational Field with coefficients: 
+            [ 1 ]
+
+            ## Simple 2x2 change of variables:
+            ## -------------------------------
+            sage: Q = QuadraticForm(ZZ, 2, [1,0,1])
+            sage: Q
+            Quadratic form in 2 variables over Integer Ring with coefficients: 
+            [ 1 0 ]
+            [ * 1 ]
+            sage: M = Matrix(ZZ, 2, 2, [1,1,0,1])
+            sage: M
+            [1 1]
+            [0 1]
+            sage: Q(M)
+            Quadratic form in 2 variables over Integer Ring with coefficients: 
+            [ 1 2 ]
+            [ * 2 ]
+
+            ## Some more tests:
+            ## ----------------
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1])
+            sage: Q([1,2,3])
+            14
+            sage: v = vector([1,2,3])
+            sage: Q(v)
+            14
+            sage: t = tuple([1,2,3])
+            sage: Q(v)
+            14    
+            sage: M = Matrix(ZZ, 3, [1,2,3])
+            sage: Q(M)
+
+            Quadratic form in 1 variables over Integer Ring with coefficients: 
+            [ 14 ]
+
+        """
+        ## If we are passed a matrix A, return the quadratic form Q(A(x)) 
+        ## (In matrix notation: A^t * Q * A) 
+        n = self.dim()
+    
+        if is_Matrix(v):
+            ## Check that v has the correct number of rows
+            if v.nrows() != n:
+                raise TypeError, "Oops!  The matrix must have " + str(n) + " rows. =("  
+    
+            ## Create the new quadratic form
+            m = v.ncols()
+            Q2 = QuadraticForm(self.base_ring(), m)
+            return QFEvaluateMatrix(self, v, Q2)
+
+        elif (is_Vector(v) or isinstance(v, (list, tuple))):    
+            ## Check the vector/tuple/list has the correct length
+            if not (len(v) == n):
+                raise TypeError, "Oops!  Your vector needs to have length " + str(n) + " ." 
+    
+            ## TO DO:  Check that the elements can be coerced into the base ring of Q -- on first elt.
+            if len(v) > 0:
+                try:
+                    x = self.base_ring()(v[0])
+                except:
+                    raise TypeError, "Oops!  Your vector is not coercible to the base ring of the quadratic form... =("
+    
+            ## Attempt to evaluate Q[v]
+            return QFEvaluateVector(self, v)
+
+        else:
+            raise(TypeError, "Oops! Presently we can only evaluate a quadratic form on a list, tuple, vector or matrix.")
+
+
+
+
+## =====================================================================================================
+
+    def _is_even_symmetric_matrix_(self, A, R=None):
+        """
+        Tests if a matrix is symmetric, defined over R, and has even diagonal in R.
+    
+        INPUT:
+            A -- matrix
+            R -- ring
+        """
+        if not is_Matrix(A):
+            raise TypeError, "A is not a matrix."
+    
+        ring_coerce_test = True
+        if R == None:            ## This allows us to omit the ring from the variables, and take it from the matrix
+            R = A.base_ring()
+            ring_coerce_test = False
+    
+        if not isinstance(R, Ring):
+            raise TypeError, "R is not a ring."
+        
+        if not A.is_square():
+            return False
+    
+        ## Test that the matrix is symmetric
+        n = A.nrows()
+        for i in range(n):
+            for j in range(i+1, n):
+                if A[i,j] != A[j,i]:
+                    return False
+    
+        ## Test that all entries coerce to R
+        if not ((A.base_ring() == R) or (ring_coerce_test == True)):
+            try:
+                for i in range(n):
+                    for j in range(i, n):
+                        x = R(A[i,j])
+            except:
+                return False
+    
+        ## Test that the diagonal is even (if 1/2 isn't in R)
+        try:
+            x = R(1/2)
+        except:
+            for i in range(n):
+                if not is_even(R(A[i,i])):
+                    return False 
+    
+        return True
+
+
+## =====================================================================================================
+
+    def matrix(self):
+        """
+        Returns the Hessian matrix A for which Q(X) = (1/2) * X^t * A * X.
+        """
+        return self.Hessian_matrix()
+
+
+    def Hessian_matrix(self):
+        """
+        Returns the Hessian matrix A for which Q(X) = (1/2) * X^t * A * X.
+    
+        EXAMPLES:
+            sage: Q = QuadraticForm(QQ, 2, range(1,4))
+            sage: Q
+            Quadratic form in 2 variables over Rational Field with coefficients: 
+            [ 1 2 ]
+            [ * 3 ]
+            sage: Q.matrix()
+            [2 2]
+            [2 6]
+            sage: Q.matrix().base_ring()
+            Rational Field
+    
+        """
+        mat_entries = []
+        for i in range(self.dim()):
+            for j in range(self.dim()):
+                if (i == j):
+                    mat_entries += [ 2 * self[i,j] ]
+                else:
+                    mat_entries += [ self[i,j] ]
+    
+        return matrix(self.base_ring(), self.dim(), self.dim(), mat_entries)
+
+
+    def Gram_matrix_rational(self):
+        """ 
+        Returns a (symmetric) Gram matrix A for the quadratic form Q,
+        meaning that
+    
+            Q(x) = x^t * A * x,
+    
+        defined over the fraction field of the base ring.  
+    
+        EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+        sage: A = Q.Gram_matrix_rational(); A
+        [1 0 0 0]
+        [0 3 0 0]
+        [0 0 5 0]
+        [0 0 0 7]
+        sage: A.base_ring()
+        Rational Field
+        """
+        return (ZZ(1) / ZZ(2)) * self.matrix()
+
+
+    def Gram_matrix(self):
+        """ 
+        Returns a (symmetric) Gram matrix A for the quadratic form Q,
+        meaning that
+    
+            Q(x) = x^t * A * x,
+    
+        defined over the base ring of Q.  If this is not possible,
+        then a TypeError is raised.
+    
+        EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+        sage: A = Q.Gram_matrix(); A
+        [1 0 0 0]
+        [0 3 0 0]
+        [0 0 5 0]
+        [0 0 0 7]
+        sage: A.base_ring()
+        Integer Ring
+        """
+        A = (ZZ(1) / ZZ(2)) * self.matrix()
+        n = self.dim()
+    
+        ## Test to see if it has an integral Gram matrix
+        Int_flag = True
+        for i in range(n):
+            for j in range(i,n):
+                Int_flag = Int_flag and A[i,j] in self.base_ring()
+    
+        ## Return the Gram matrix, or an error
+        if Int_flag: 
+            return MatrixSpace(self.base_ring(), n, n)(A)
+        else:
+            raise TypeError, "Oops!  This form does not have an integral Gram matrix. =("
+
+
+    def has_integral_Gram_matrix(self):
+        """
+        Returns whether the quadratic form has an integral Gram matrix (with respect to its base ring).
+    
+        A warning is issued if the form is defined over a field, since in that case the return is trivially true.
+        """
+        ## Warning over fields
+        if is_field(self.base_ring()):
+           warn("Warning -- A quaratic form over a field always has integral Gram matrix.  Do you really want to do this?!?")
+    
+        ## Determine integrality of the Gram matrix
+        flag = True
+        try:
+            self.Gram_matrix()
+        except:
+            flag = False
+    
+        return flag
+
+
+    def gcd(self):
+        """
+        Returns the greatest common divisor of the coefficients of the
+        quadratic form (as a polynomial).
+        """
+        if self.base_ring() != ZZ:
+            raise TypeError, "Oops! The given quadratic form must be defined over ZZ."
+
+        return gcd(self.coefficients())
+
+
+    def is_primitive(self):
+        """
+        Determines if the given integer-valued form is primitive
+        (i.e. not an integer (>1) multiple of another integer-valued
+        quadratic form).
+        """
+        return (self.gcd() == 1)
+
+
+    def primitive(self):
+        """
+        Returns a primitive version of an integer-valued quadratic form, defined over ZZ.
+        """
+        if self.base_ring() != ZZ:
+            raise TypeError, "Oops! The given quadratic form must be defined over ZZ."
+
+        g = self.gcd()
+        return QuadraticForm(self.base_ring(), self.dim(), [ZZ(x/g)  for x in self.coefficients()])
+
+
+
+    def adjoint_primitive(self):
+        """
+        Returns the primitive adjoint of the quadratic form, which is
+        the smallest discriminant integer-valued quadratic form whose
+        matrix is a scalar multiple of the inverse of the matrix of
+        the given quadratic form.
+        """
+        return QuadraticForm(self.Hessian_matrix().adjoint()).primitive()        
+    
+
+
+    def dim(self):
+        """
+        Gives the number of variables of the quadratic form.
+        """
+        return self.__n
+
+
+    def base_ring(self):
+        """
+        Gives the ring over which the quadratic form is defined.
+        """
+        return self.__base_ring
+
+
+    def coefficients(self):
+        """
+        Gives the matrix of upper triangular coefficients, 
+        by reading across the rows from the main diagonal.
+        """
+        return self.__coeffs
+
+    
+    def det(self):
+        """
+        Gives the determinant of the Gram matrix of 2*Q, or
+        equivalently the determinant of the Hessian matrix of Q.
+
+        (Note: This is always defined over the same ring as the
+        quadratic form.)
+        """
+        try:
+            return self.__det
+        except:
+            ## Compute the determinant
+            if self.dim() == 0:
+                new_det = self.base_ring()(1)
+            else:
+                new_det = self.matrix().det() 
+
+            ## Cache and return the determinant
+            self.__det = new_det
+            return new_det
+
+        
+    def Gram_det(self):
+        """
+        Gives the determinant of the Gram matrix of 2*Q.
+
+        (Note: This is defined over the fraction field of the ring of
+        the quadratic form, but is oftewn not defined over the same
+        ring as the quadratic form.)
+        """
+        return self.det() / ZZ(2**self.dim())
+            
+
+    def base_change_to(self, R):
+        """
+        Alters the quadratic form to have all coefficients 
+        defined over the new base_ring R.  Here R must be 
+        coercible to from the current base ring.
+        
+        Note: This is preferable to performing an explicit 
+        coercion through the base_ring() method, which does 
+        not affect the individual coefficients.  This is 
+        particularly useful for performing fast modular 
+        arithmetic evaluations.
+
+        INPUT:
+            R -- a ring
+        
+        OUTPUT:
+            quadratic form 
+
+        EXAMPLES:
+            sage: Q = DiagonalQuadraticForm(ZZ,[1,1]); Q
+            Quadratic form in 2 variables over Integer Ring with coefficients: 
+            [ 1 0 ]
+            [ * 1 ]
+
+            sage: Q1 = Q.base_change_to(IntegerModRing(5)); Q1
+            Quadratic form in 2 variables over Ring of integers modulo 5 with coefficients: 
+            [ 1 0 ]
+            [ * 1 ]
+
+            sage: Q1([35,11])
+            1
+
+        """
+        ## Check that a canonical coercion is possible
+        if not is_Ring(R):
+            raise TypeError, "Oops!  R is not a ring. =("
+        if not R.has_coerce_map_from(self.base_ring()):
+            raise TypeError, "Oops!  There is no canonical coercion from " + str(self.base_ring()) + " to R."
+        
+        ## Return the coerced form
+        return QuadraticForm(R, self.dim(), [R(x) for x in self.coefficients()])
+
+
+    def level(self):
+        """
+        Determines the level of the quadratic form over a PID, which
+            is a generator for the smallest ideal N of R such that N *
+        (the matrix of 2*Q)^(-1) is in R with diagonal in 2*R. 
+    
+        Over ZZ this returns a non-negative number.
+    
+        (Caveat: This always returns the principal ideal when working over a field!)
+    
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, range(1,4))
+            sage: Q.level()
+            8
+
+            sage: Q1 = QuadraticForm(QQ, 2, range(1,4))
+            sage: Q1.level()      # random
+            UserWarning: Warning -- The level of a quadratic form over a field is always 1.  Do you really want to do this?!?
+            1
+    
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+            sage: Q.level()
+            420
+    
+        """
+        ## Try to return the cached level
+        try:
+            return self.__level
+        except:
+        
+            ## Check that the base ring is a PID
+            if not is_PrincipalIdealDomain(self.base_ring()):
+                raise TypeError, "Oops!  The level (as a number) is only defined over a Principal Ideal Domain.  Try using level_ideal()."
+    
+    
+            ## Warn the user if the form is defined over a field!
+            if self.base_ring().is_field():
+                warn("Warning -- The level of a quadratic form over a field is always 1.  Do you really want to do this?!?")
+                #raise RuntimeError, "Warning -- The level of a quadratic form over a field is always 1.  Do you really want to do this?!?"
+         
+    
+            ## Check invertibility and find the inverse
+            try:
+                mat_inv = self.matrix()**(-1)
+            except:
+                raise TypeError, "Oops!  The quadratic form is degenerate (i.e. det = 0). =("
+    
+            ## Compute the level        
+            inv_denoms = []
+            for i in range(self.dim()):
+                for j in range(i, self.dim()):
+                    if (i == j):
+                        inv_denoms += [denominator(mat_inv[i,j] / 2)]
+                    else:
+                        inv_denoms += [denominator(mat_inv[i,j])]
+            lvl = LCM(inv_denoms)
+            lvl = ideal(self.base_ring()(lvl)).gen()
+            ##############################################################
+            ## To do this properly, the level should be the inverse of the
+            ## fractional ideal (over R) generated by the entries whose
+            ## denominators we take above. =)
+            ##############################################################
+    
+            ## Normalize the result over ZZ
+            if self.base_ring() == IntegerRing():
+                lvl = abs(lvl)
+
+            ## Cache and return the level
+            self.__level = lvl
+            return lvl
+            
+
+
+    def level_ideal(self):
+        """
+        Determines the level of the quadratic form (over R), which is the
+        smallest ideal N of R such that N * (the matrix of 2*Q)^(-1) is
+        in R with diagonal in 2*R. 
+        (Caveat: This always returns the principal ideal when working over a field!)
+    
+        WARNING:  THIS ONLY WORKS OVER A PID RING OF INTEGERS FOR NOW!  
+              (Waiting for SAGE fractional ideal support.)
+    
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, range(1,4))
+            sage: Q.level_ideal()
+            Principal ideal (8) of Integer Ring
+
+            sage: Q1 = QuadraticForm(QQ, 2, range(1,4))
+            sage: Q1.level_ideal()
+            Principal ideal (1) of Rational Field
+    
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+            sage: Q.level_ideal()
+            Principal ideal (420) of Integer Ring
+    
+        """
+        ##############################################################
+        ## To do this properly, the level should be the inverse of the
+        ## fractional ideal (over R) generated by the entries whose
+        ## denominators we take above. =)
+        ##############################################################
+    
+        return ideal(self.base_ring()(self.level()))
+
+
+
+## =====================================================================================================
+
+def DiagonalQuadraticForm(R, diag):
+    """
+    Returns a quadratic form over R which is a sum of squares.
+
+    INPUT:
+    R -- ring
+    diag -- list/tuple of elements coercible to R
+
+    OUPUT:
+    quadratic form
+
+    EXAMPLES:
+    sage: Q = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+    sage: Q
+    Quadratic form in 4 variables over Integer Ring with coefficients: 
+    [ 1 0 0 0 ]
+    [ * 3 0 0 ]
+    [ * * 5 0 ]
+    [ * * * 7 ]
+
+    """
+    Q = QuadraticForm(R, len(diag))
+    for i in range(len(diag)):
+        Q[i,i] = diag[i]
+    return Q
diff --git a/sage/quadratic_forms/quadratic_form__automorphisms.py b/sage/quadratic_forms/quadratic_form__automorphisms.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__automorphisms.py
@@ -0,0 +1,470 @@
+
+from sage.interfaces.gp import gp
+from sage.matrix.constructor import Matrix
+from sage.rings.rational_field import QQ
+from sage.rings.integer_ring import ZZ
+from sage.misc.mrange import mrange
+
+from sage.modules.free_module_element import vector
+from sage.rings.arith import GCD
+from sage.misc.sage_eval import sage_eval
+from sage.misc.misc import SAGE_ROOT
+
+import tempfile, os
+from random import random
+
+
+def basis_of_short_vectors(self, show_lengths=False, safe_flag=True):
+    """
+    Return a basis for ZZ^n made of vectors with minimal lengths Q(v).
+
+    The safe_flag allows us to select whether we want a copy of the
+    output, or the original output.  By default safe_flag = True, so
+    we return a copy of the cached information.  If this is set to
+    False, then the routine is much faster but the return values are
+    vulnerable to being corrupted by the user.
+
+    OUTPUT:
+        a list of vectors, and optionally a list of values for each vector.
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+        sage: Q.basis_of_short_vectors()
+        [(1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1)]
+        sage: Q.basis_of_short_vectors(True)
+        ([(1, 0, 0, 0), (0, 1, 0, 0), (0, 0, 1, 0), (0, 0, 0, 1)], [1, 3, 5, 7])
+    """
+    ## Try to use the cached results
+    try:
+        ## Return the appropriate result
+        if show_lengths:
+            if safe_flag:
+                return deep_copy(self.__basis_of_short_vectors), deepcopy(self.__basis_of_short_vectors_lengths)
+            else:
+                return self.__basis_of_short_vectors, self.__basis_of_short_vectors_lengths
+        else:
+            if safe_flag:
+                return deepcopy(self.__basis_of_short_vectors)
+            else:
+                return deepcopy(self.__basis_of_short_vectors)
+    except:
+        pass
+
+
+    ## Set an upper bound for the number of vectors to consider
+    Max_number_of_vectors = 10000
+
+    ## Generate a PARI matrix string for the associated Hessian matrix
+    M_str = str(gp(self.matrix()))
+
+    
+    ## Run through all possible minimal lengths to find a spanning set of vectors
+    n = self.dim()
+    #MS = MatrixSpace(QQ, n)
+    M1 = Matrix([[0]])
+    vec_len = 0
+    while M1.rank() < n:
+
+        ## DIAGONSTIC
+        #print
+        #print "Starting with vec_len = ", vec_len
+        #print "M_str = ", M_str
+
+        vec_len += 1
+        gp_mat = gp.qfminim(M_str, vec_len, Max_number_of_vectors)[3].mattranspose()
+        number_of_vecs = ZZ(gp_mat.matsize()[1])
+        vector_list = []
+        for i in range(number_of_vecs):
+            #print "List at", i, ":", list(gp_mat[i+1,])
+            new_vec = vector([ZZ(x)  for x in list(gp_mat[i+1,])])
+            vector_list.append(new_vec)
+
+
+        ## DIAGNOSTIC
+        #print "number_of_vecs = ", number_of_vecs
+        #print "vector_list = ", vector_list       
+
+
+        ## Make a matrix from the short vectors
+        if len(vector_list) > 0:
+            M1 = Matrix(vector_list)
+
+
+        ## DIAGNOSTIC
+        #print "matrix of vectors = \n", M1
+        #print "rank of the matrix = ", M1.rank()
+            
+
+
+    #print " vec_len = ", vec_len
+    #print M1
+
+
+    ## Organize these vectors by length (and also introduce their negatives)
+    max_len = vec_len/2
+    vector_list_by_length = [[]  for _ in range(max_len + 1)]
+    for v in vector_list:
+        l = self(v)
+        vector_list_by_length[l].append(v)
+        vector_list_by_length[l].append(vector([-x  for x in v]))
+
+
+    ## Make a matrix from the column vectors (in order of ascending length).
+    sorted_list = []
+    for i in range(len(vector_list_by_length)):
+        for v in vector_list_by_length[i]:
+            sorted_list.append(v)
+    sorted_matrix = Matrix(sorted_list).transpose()  
+
+
+    ## Determine a basis of vectors of minimal length
+    pivots = sorted_matrix.pivots()
+    basis = [sorted_matrix.column(i) for i in pivots]
+    pivot_lengths = [self(v)  for v in basis]
+
+
+    ## DIAGNOSTIC
+    #print "basis = ", basis
+    #print "pivot_lengths = ", pivot_lengths
+
+
+    ## Cache the result
+    self.__basis_of_short_vectors = basis
+    self.__basis_of_short_vectors_lenghts = pivot_lengths
+
+
+    ## Return the appropriate result
+    if show_lengths:
+        return basis, pivot_lengths
+    else:
+        return basis
+
+
+
+
+def short_vector_list_up_to_length(self, len_bound, up_to_sign_flag=False):
+    """
+    Return a list of lists of short vectors v, sorted by length, with
+    Q(v) < len_bound.  The list in output[i] indexes all vectors of
+    length i.  If the up_to_sign_flag is set to True, then only one of
+    the vectors of the pair [v, -v] is listed.
+
+    Note:  This processes the PARI/GP output to always give elements of type ZZ.
+
+    OUTPUT:
+        a list of lists of vectors.
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+        sage: Q.short_vector_list_up_to_length(3)
+        [[(0, 0, 0, 0)], [(1, 0, 0, 0), [-1, 0, 0, 0]], []]
+        sage: Q.short_vector_list_up_to_length(4)
+        [[(0, 0, 0, 0)],
+         [(1, 0, 0, 0), [-1, 0, 0, 0]],
+         [],
+         [(0, 1, 0, 0), [0, -1, 0, 0]]]
+        sage: Q.short_vector_list_up_to_length(5)
+        [[(0, 0, 0, 0)],
+         [(1, 0, 0, 0), [-1, 0, 0, 0]],
+         [],
+         [(0, 1, 0, 0), [0, -1, 0, 0]],
+         [(1, 1, 0, 0),
+         [-1, -1, 0, 0],
+         (-1, 1, 0, 0),
+         [1, -1, 0, 0],
+         (2, 0, 0, 0),
+         [-2, 0, 0, 0]]]
+        sage: Q.short_vector_list_up_to_length(5, True)
+        [[(0, 0, 0, 0)],
+         [(1, 0, 0, 0)],
+         [],
+         [(0, 1, 0, 0)],
+         [(1, 1, 0, 0), (-1, 1, 0, 0), (2, 0, 0, 0)]]
+         
+    """
+    ## Set an upper bound for the number of vectors to consider
+    Max_number_of_vectors = 10000
+
+    ## Generate a PARI matrix string for the associated Hessian matrix
+    M_str = str(gp(self.matrix()))
+
+    ## Generate the short vectors
+    gp_mat = gp.qfminim(M_str, 2*len_bound-2, Max_number_of_vectors)[3].mattranspose()
+    number_of_rows = gp_mat.matsize()[1]
+    gp_mat_vector_list = [vector([ZZ(x)  for x in gp_mat[i+1,]])  for i in range(number_of_rows)]
+
+    ## Sort the vectors into lists by their length
+    vec_list = [[]  for i in range(len_bound)]
+    for v in gp_mat_vector_list:
+        vec_list[self(v)].append(v)
+        if up_to_sign_flag == False:
+            vec_list[self(v)].append([-x  for x in v])
+
+    ## Add the zero vector by hand
+    zero_vec = vector([ZZ(0)  for _ in range(self.dim())])
+    vec_list[0].append(zero_vec)  
+
+    ## Return the sorted list
+    return vec_list
+
+
+
+def short_primitive_vector_list_up_to_length(self, len_bound, up_to_sign_flag=False):
+    """
+    Return a list of lists of short primitive vectors v, sorted by length, with
+    Q(v) < len_bound.  The list in output[i] indexes all vectors of
+    length i.  If the up_to_sign_flag is set to True, then only one of
+    the vectors of the pair [v, -v] is listed.
+
+    Note:  This processes the PARI/GP output to always give elements of type ZZ.
+
+    OUTPUT:
+        a list of lists of vectors.
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+        sage: Q.short_vector_list_up_to_length(5, True)
+        [[(0, 0, 0, 0)],
+         [(1, 0, 0, 0)],
+         [],
+         [(0, 1, 0, 0)],
+         [(1, 1, 0, 0), (-1, 1, 0, 0), (2, 0, 0, 0)]]
+        sage: Q.short_primitive_vector_list_up_to_length(5, True)
+        [[], [(1, 0, 0, 0)], [], [(0, 1, 0, 0)], [(1, 1, 0, 0), (-1, 1, 0, 0)]]
+
+         
+    """
+    ## Get a list of short vectors
+    full_vec_list = self.short_vector_list_up_to_length(len_bound, up_to_sign_flag)
+
+    ## Make a new list of the primitive vectors
+    prim_vec_list = [[v  for v in L  if GCD(list(v)) == 1]   for L in full_vec_list]                 ## TO DO:  Arrange for GCD to take a vector argument!
+    
+    ## Return the list of primitive vectors
+    return prim_vec_list
+
+
+
+
+## ----------------------------------------------------------------------------------------------------
+
+
+def automorphisms(self):
+    """
+    Return a list of the automorphisms of the quadratic form.
+
+    sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1])
+    sage: Q.number_of_automorphisms()
+    48
+    sage: 2^3 * factorial(3)
+    48
+
+    sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+    sage: Q.number_of_automorphisms()
+    384
+    sage: 2^4 * factorial(4)
+    384
+
+    sage: Q = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+    sage: Q.number_of_automorphisms()
+    16
+
+    #sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1,1])
+    #sage: time Q.number_of_automorphisms()
+    #CPU times: user 119.44 s, sys: 0.87 s, total: 120.31 s
+    #Wall time: 121.80
+    #3840
+    #sage: 2^5 * factorial(5)
+    #3840
+    """
+    ## Check for a cached value
+    try:
+        return self.__automorphisms
+    except:
+        pass
+
+
+    ## Find a basis of short vectors, and their lengths
+    basis, pivot_lengths = self.basis_of_short_vectors(show_lengths=True)
+
+    ## List the relevant vectors by length
+    max_len = max(pivot_lengths)
+    vector_list_by_length = self.short_primitive_vector_list_up_to_length(max_len + 1)
+
+
+    ## Make the matrix A:e_i |--> v_i to our new basis.
+    A = Matrix(basis).transpose()
+    #A1 = A.inverse() * A.det()
+    #Q1 = A1.transpose() * self.matrix() * A1       ## This is the matrix of Q
+    #Q = self.matrix() * A.det()**2
+    Q2 = A.transpose() * self.matrix() * A       ## This is the matrix of Q in the new basis
+    Q3 = self.matrix()
+
+
+    ## Determine all automorphisms
+    n = self.dim()
+    Auto_list = []
+    #ct = 0
+
+    ## DIAGNOSTIC
+    #print "n = " + str(n)
+    #print "pivot_lengths = " + str(pivot_lengths)
+    #print "vector_list_by_length = " + str(vector_list_by_length)
+    #print "length of vector_list_by_length = " + str(len(vector_list_by_length))
+
+    for index_vec in mrange([len(vector_list_by_length[pivot_lengths[i]])  for i in range(n)]):
+        M = Matrix([vector_list_by_length[pivot_lengths[i]][index_vec[i]]   for i in range(n)]).transpose()
+        #Q1 = self.matrix()
+        #if self(M) == self:
+        #ct += 1
+        #print "ct = ", ct, "   M = "
+        #print M
+        #print
+        if M.transpose() * Q3 * M == Q2:       ## THIS DOES THE SAME THING! =(
+            Auto_list.append(M)
+
+
+    ## Cache the answer and return the list
+    self.__automorphisms = Auto_list
+    self.__number_of_automorphisms = len(Auto_list)
+    return Auto_list
+
+
+
+
+def number_of_automorphisms(self, recompute=False):
+    """
+    Return a list of the number of automorphisms (of det 1 and -1) of
+    the quadratic form.
+
+    If recompute is True, then we will recompute the cached result.
+
+    OUTPUT:
+        an integer >= 2.
+
+    EXAMPLES:
+        sage: Q = QuadraticForm(ZZ, 3, [1, 0, 0, 1, 0, 1], unsafe_initialization=True, number_of_automorphisms=-1)
+        sage: Q.list_external_initializations()
+        ['number_of_automorphisms']
+        sage: Q.number_of_automorphisms()
+        -1
+        sage: Q.number_of_automorphisms(recompute=True)
+        48
+        sage: Q.list_external_initializations()
+        []
+    """
+    ## Try to use the cached version if we can
+    if not recompute:
+        try:
+            #print "Using the cached number of automorphisms."
+            #print "We stored", self.__number_of_automorphisms
+            return self.__number_of_automorphisms
+        except:
+            pass
+        
+    ## Otherwise cache and return the result
+    #print "Recomputing the number of automorphisms based on the list of automorphisms."
+    #self.__number_of_automorphisms = len(self.automorphisms())                                     ## This is now deprecated.
+    self.__number_of_automorphisms = self.number_of_automorphisms__souvigner()        
+    try:
+        self._external_initialization_list.remove('number_of_automorphisms')
+    except:
+        pass  ## Do nothing if the removal fails, since it might not be in the list (causing an error)!
+    return self.__number_of_automorphisms
+
+
+
+def number_of_automorphisms__souvigner(self):
+    """
+    Uses the Souvigner code to compute the number of automorphisms.    
+    """
+    ## Write an input text file
+    F_filename = '/tmp/tmp_isom_input' + str(random()) + ".txt"
+    F = open(F_filename, 'w')
+    #F = tempfile.NamedTemporaryFile(prefix='tmp_auto_input', suffix=".txt")   ## This fails because the Souvigner code doesn't like random filenames (hyphens are bad...)!
+    F.write("#1 \n")
+    n = self.dim()
+    F.write(str(n) + "x0 \n")      ## Use the lower-triangular form
+    for i in range(n):
+        for j in range(i+1):
+            if i == j:
+                F.write(str(2 * self[i,j]) + " ")
+            else:
+                F.write(str(self[i,j]) + " ")
+        F.write("\n")
+    F.flush()
+    #print "Input filename = ", F.name
+    #os.system("less " + F.name)
+
+    ## Call the Souvigner automorphism code
+    souvigner_auto_path = SAGE_ROOT + "/local/bin/Souvigner_AUTO"                 ## FIX THIS LATER!!!
+    G1 = tempfile.NamedTemporaryFile(prefix='tmp_auto_ouput', suffix=".txt")
+    #print "Output filename = ", G1.name
+    os.system(souvigner_auto_path + " '" +  F.name + "' > '" + G1.name +"'")
+
+
+    ## Read the output
+    G2 = open(G1.name, 'r')
+    for line in G2:
+        if line.startswith("|Aut| = "):
+            num_of_autos = sage_eval(line.lstrip("|Aut| = "))
+            F.close()
+            G1.close()
+            G2.close()
+            os.system("rm -f " + F_filename)
+            #os.system("rm -f " + G1.name)
+            return num_of_autos
+
+    ## Raise and error if we're here:
+    raise RuntimeError, "Oops! There is a problem..."
+
+
+
+def set_number_of_automorphisms(self, num_autos):
+    """
+    Set the number of automorphisms to be the value given.  No error
+    checking is performed, to this may lead to erroneous results.
+
+    The fact that this result was set externally is recorded in the
+    internal list of external initializations, accessible by the
+    method list_external_initializations().
+
+    Return a list of the number of
+    automorphisms (of det 1 and -1) of the quadratic form.
+
+    OUTPUT:
+        None
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, 1, 1])
+        sage: Q.list_external_initializations()
+        []
+        sage: Q.set_number_of_automorphisms(-3)
+        sage: Q.number_of_automorphisms()
+        -3
+        sage: Q.list_external_initializations()
+        ['number_of_automorphisms']
+
+    """
+    self.__number_of_automorphisms = num_autos
+    text = 'number_of_automorphisms'    
+    if not text in self._external_initialization_list:
+        self._external_initialization_list.append(text)
+
+
+
+
+def Nipp_automorphism_testing(self):
+    """
+    Testing the automorphism routine agains Nipp's Tables
+
+        --- MOVE THIS ELSEWHERE!!! ---
+
+    """
+    for i in range(20):
+        Q = QuadraticForm(ZZ, 4, Nipp[i][2])
+        my_num = Q.number_of_automorphisms()
+        nipp_num = Nipp.number_of_automorphisms(i)
+        print "    i = " + str(i) + "  my_num = " + str(my_num) + "  nipp_num = " + str(nipp_num)
+    
+    
diff --git a/sage/quadratic_forms/quadratic_form__count_local_2.py b/sage/quadratic_forms/quadratic_form__count_local_2.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__count_local_2.py
@@ -0,0 +1,308 @@
+
+
+from sage.quadratic_forms.count_local_2 import CountAllLocalTypesNaive
+
+from sage.rings.arith import valuation
+
+
+
+
+
+def VecIncrement__deprecated(self, v, R):
+    """
+    Performs an in-place imcrement operation on the vector v, whose
+    entries are satisfy 0 <= v[i] <= R-1.  No values are returned.
+
+void Matrix_mpz::Increment(valarray<mpz_class> & v, const mpz_class & R) const
+00008 {
+00009     size_t i;
+00010     i = v.size();
+00011 
+00012     // Do the carry operations
+00013     while ((i > 0) && (v[i-1] == R-1))   // Assumes that all components satisfy 0 <= v[i] <= R-1
+00014       {
+00015         v[i-1] = 0;
+00016         i--;
+00017       }
+00018 
+00019     // Only increment if we're not already at the zero vector =)
+00020     if (i > 0)
+00021       v[i-1]++;
+00022 }
+    """
+    i = len(v)
+
+    ## Do the carry operations
+    while ((i > 0) and (v[i-1] == R-1)):   ## Assumes that all components satisfy 0 <= v[i] <= R-1
+        v[i-1] = 0
+        i += -1
+
+    ## Only increment if we're not already at the zero vector =)
+    if (i > 0):
+        v[i-1] += 1
+
+
+
+
+def local_solution_type__deprecated(self, p, w, zvec, nzvec):
+    """
+    ////////////////////////////////////////////////////////////////////////////////////
+    /// Private routine to check if a given solution vector w (of Q(w) = m mod p^k)   //
+    /// is of a certain local type and satisfies certain congruence conditions mod p. //
+    ///   (Personal Note: For p=2, we should still use p=2 and not p=8.)              //
+    ////////////////////////////////////////////////////////////////////////////////////
+
+    size_t Matrix_mpz::local_solution_type(const mpz_class & p, const valarray<mpz_class> & w, 
+               const valarray<size_t> & zero, const valarray<size_t> & nonzero) const
+
+    """
+
+    ## Note: Here p is assumed to be a prime >= 2, though the routine still works if not...
+
+    ## ToDo?: Add a check that Q is square and has the same size as w.
+  
+
+    zero_flag = False        ## Tests the zero mod p congruence conditions
+    nonzero_flag = False     ## Tests the nonzero congruence conditions
+
+
+    ## Check if the solution satisfies the zvec "zero" congruence conditions
+    ## (either zvec is empty or its components index the zero vector mod p)
+    if (len(zvec) == 0): 
+        zero_flag = True
+    else:
+        i = 0
+        while ( (i < len(zvec)) and ((w[zvec[i]] % p) == 0) ):
+            i += 1
+        if (i == len(zvec)):
+            zero_flag = True
+
+
+    ## DIAGNOSTIC
+    #print "IsLocalSolutionType: Finished the Zero congruence condition test \n"
+
+    if (zero_flag == False):
+        return 0
+
+    ## DIAGNOSTIC
+    #print "IsLocalSolutionType: Passed the Zero congruence condition test \n"
+
+
+    ## Check if the solution satisfies the nzvec "nonzero" congruence conditions
+    ## (either nzvec is empty or its components index a non-zero vector mod p)
+    if (len(nzvec) == 0): 
+        nonzero_flag = True 
+    else:
+        i = 0
+        while ((nonzero_flag == False) and (i < len(nzvec))):
+            if ((w[nzvec[i]] % p) != 0):
+                nonzero_flag = True
+            i += 1
+  
+    if (nonzero_flag == False):
+        return 0
+  
+  
+    ## Check if the solution has the appropriate (local) type
+  
+  
+    ## 1: Check Good-type
+    for i in range(len(w)):
+        if (((w[i] % p) != 0)  and ((self[i,i] % p) != 0)):
+            return 1
+    if (p == 2):
+        for i in range(len(w) - 1):
+            if (((self[i,i+1] % p) != 0) and (((w[i] % p) != 0) or ((w[i+1] % p) != 0))):
+                return 1  
+
+
+    ## 2: Check Zero-type
+    Zero_flag = True
+    for i in range(len(w)):
+        if ((w[i] % p) != 0):
+            Zero_flag = False
+    if (Zero_flag == True):
+        return 2
+
+
+    ## Check if wS1 is zero or not
+    wS1_nonzero_flag = False
+    for i in range(self.dim()):      
+  
+        ## Compute the valuation of each index, allowing for off-diagonal terms
+        if (self[i,i] == 0):
+            if (i == 0):
+                val = valuation(self[i,i+1], p)    ## Look at the term to the right
+            elif (i == self.dim() - 1):
+                val = valuation(self[i-1,i], p)    ## Look at the term above
+            else:
+                val = valuation(self[i,i+1] + self[i-1,i], p)    ## Finds the valuation of the off-diagonal term since only one isn't zero
+        else:
+            val = valuation(self[i,i], p)  
+
+        ## Test each index
+        if ((val == 1) and ((w[i] % p) != 0)):
+            wS1_nonzero_flag = True
+
+      
+    ## 4: Check Bad-type I
+    if (wS1_nonzero_flag == True):
+        #print " Bad I Soln :  " + str(w)
+        return 4
+
+
+    ##    cout << " Bad II Soln :  " << w << "  wS1_nonzero_flag = " << wS1_nonzero_flag << endl;
+
+    ## 5: Check Bad-type II
+    if (wS1_nonzero_flag == False):
+        #print " Bad II Soln :  " + str(w)
+        return 5
+
+
+    ## Error if we get here! =o
+    print "   Solution vector is " + str(w) 
+    print "   and Q is \n" + str(self) + "\n" 
+    raise RuntimeError, "Error in IsLocalSolutionType: Should not execute this line... =( \n"
+
+
+
+
+
+
+def CountAllLocalTypesNaive__deprecated(self, p, k, m, zvec, nzvec):
+    """
+    ///////////////////////////////////////////////////////////////////
+    /// Naively counts the number of solutions of Q(x) = m mod p^k   //
+    /// of type solntype, satisfying the mod p congruence conditions //
+    /// at the indices of the vectors "zero" and "nonzero"           //
+    ///////////////////////////////////////////////////////////////////
+
+    valarray <mpz_class> Matrix_mpz::CountAllLocalTypesNaive(const mpz_class & p, unsigned long k, const mpz_class & m, 
+                                             const valarray<size_t> & zero, const valarray<size_t> & nonzero) const
+    """
+
+    ## DIAGNOSTIC
+    #print "   --> CountAllLocalTypesNaive is using the form Q \n" + str(Q)
+    #print "       p = " + str(p) + "  and   m = " + str(m)
+
+
+    if (True or (p == 2)):          ##  <----------------- THIS IS WIERD...
+
+        n = self.dim()
+        R = p ** k
+
+        ## Initialize the counting vector
+        count_vector = [0  for i in range(6)]
+
+        ## Initialize v = (0, ... , 0)
+        v = [0  for i in range(n)]
+
+
+        ## Some declarations to speed up the loop
+        R_n = R ** n
+        m1 = m % R
+
+        ## Count the local solutions
+        #for(size_t i=1; i<=(R_n).get_ui(); i++):
+        for i in range(R_n):
+#            self.VecIncrement(v, R)                          ## Increments the vector v in-place.
+            VecIncrement_cdef(v, R)                          ## Increments the vector v in-place.
+            if (self(v) % R  == m1):                        ## Evaluates the quadratic form (mod R) at the vector v -- can be sped up!
+                solntype = self.local_solution_type(p, v, zvec, nzvec)
+                if (solntype != 0):
+                    count_vector[solntype] += 1
+
+
+
+        ## Generate the Bad-type and Total counts
+        count_vector[3] = count_vector[4] + count_vector[5]
+        count_vector[0] = count_vector[1] + count_vector[2] + count_vector[3]
+
+
+        ## DIAGNOSTIC
+        #cout << "R = " << R << "\n";
+        #cout << "n = " << n << "\n";
+        #cout << "R_n = " << R_n << "\n";
+        #
+        #for(i=1; i<=25; i++) {
+        #    cout << "v = " << v << "\n"; 
+        #    Increment(v,R);
+        #}
+        #
+        #cout << "Q1 = " << Q1 << "\n";
+        #cout << "v = " << v << "\n";
+        #cout << "Q1 * v = " << Q1 * v<< "\n";
+        
+
+        return count_vector    
+
+    else:
+        raise RuntimeError, "Error in count_local_typeNaive: Matrix \n" + str(self) + "\n is not symmetric!"
+
+
+
+
+
+##///////////////////////////////////////////
+##/// Front-ends for our counting routines //
+##///////////////////////////////////////////
+
+def count_local_type(self, p, k, m, solntype, zvec, nzvec):
+    """
+    mpz_class Matrix_mpz::count_local_type(const mpz_class & p, long k, const mpz_class & m, size_t solntype, 
+                         const valarray<size_t> & zero, const valarray<size_t> & nonzero) const
+
+    // Ideally this would use the count_local_typeWithSymmetry routine, but this is fine for now. =)
+    """
+    #return self.CountAllLocalTypesNaive(p, k, m, zvec, nzvec)[0]
+    return CountAllLocalTypesNaive(self, p, k, m, zvec, nzvec)[0]
+
+
+def count_local_good_type(self, p, k, m, zvec, nzvec):
+    """
+    mpz_class Matrix_mpz::count_local_good_type(const mpz_class & p, long k, const mpz_class & m, 
+                             const valarray<size_t> & zero, const valarray<size_t> & nonzero) const 
+
+    """
+    #return self.CountAllLocalTypesNaive(p, k, m, zvec, nzvec)[1]
+    return CountAllLocalTypesNaive(self, p, k, m, zvec, nzvec)[1]
+
+
+def count_local_zero_type(self, p, k, m, zvec, nzvec):
+    """
+    mpz_class Matrix_mpz::count_local_zero_type(const mpz_class & p, long k, const mpz_class & m, 
+                             const valarray<size_t> & zero, const valarray<size_t> & nonzero) const 
+
+    """
+    #return self.CountAllLocalTypesNaive(p, k, m, zvec, nzvec)[2]
+    return CountAllLocalTypesNaive(self, p, k, m, zvec, nzvec)[2]
+
+
+def count_local_bad_type(self, p, k, m, zvec, nzvec):
+    """
+    mpz_class Matrix_mpz::count_local_bad_type(const mpz_class & p, long k, const mpz_class & m, 
+                             const valarray<size_t> & zero, const valarray<size_t> & nonzero) const 
+
+    """
+    #return self.CountAllLocalTypesNaive(p, k, m, zvec, nzvec)[3]
+    return CountAllLocalTypesNaive(self, p, k, m, zvec, nzvec)[3]
+
+
+def count_local_bad_typeI(self, p, k, m, zvec, nzvec):
+    """
+    mpz_class Matrix_mpz::count_local_bad_typeI(const mpz_class & p, long k, const mpz_class & m, 
+                             const valarray<size_t> & zero, const valarray<size_t> & nonzero) const 
+
+    """
+    #return self.CountAllLocalTypesNaive(p, k, m, zvec, nzvec)[4]
+    return CountAllLocalTypesNaive(self, p, k, m, zvec, nzvec)[4]
+
+
+def count_local_bad_typeII(self, p, k, m, zvec, nzvec):
+    """
+    mpz_class Matrix_mpz::count_local_bad_typeII(const mpz_class & p, long k, const mpz_class & m, 
+                             const valarray<size_t> & zero, const valarray<size_t> & nonzero) const 
+
+    """
+    #return self.CountAllLocalTypesNaive(p, k, m, zvec, nzvec)[5]
+    return CountAllLocalTypesNaive(self, p, k, m, zvec, nzvec)[5]
diff --git a/sage/quadratic_forms/quadratic_form__equivalence_testing.py b/sage/quadratic_forms/quadratic_form__equivalence_testing.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__equivalence_testing.py
@@ -0,0 +1,358 @@
+from sage.matrix.constructor import Matrix
+from sage.misc.mrange import mrange
+from sage.rings.arith import hilbert_symbol, prime_divisors, is_prime, valuation, GCD, legendre_symbol
+from sage.rings.integer_ring import ZZ
+
+from extras import hilbert_symbol_rational
+from quadratic_form__genus import CS_genus_symbol_list
+
+from sage.misc.misc import SAGE_ROOT
+
+import tempfile, os
+
+from random import random
+
+
+################################################################################
+## Routines to test if two quadratic forms over ZZ are globally equivalent.   ##
+## (For now, we require both forms to be positive definite.)                  ##
+################################################################################
+
+def is_globally_equivalent__souvigner(self, other, return_transformation=False):
+    """
+    Uses the Souvigner code to compute the number of automorphisms.    
+    """
+    ## Write an input text file
+    F_filename = '/tmp/tmp_isom_input' + str(random()) + ".txt"
+    F = open(F_filename, 'w')
+    #F = tempfile.NamedTemporaryFile(prefix='tmp_isom_input', suffix=".txt")  ## This failed because it may have hyphens, which are interpreted badly by the Souvigner code.
+    F.write("\n #1 \n")
+
+    ## Write the first form
+    n = self.dim()
+    F.write(str(n) + "x0 \n")      ## Use the lower-triangular form
+    for i in range(n):
+        for j in range(i+1):
+            if i == j:
+                F.write(str(2 * self[i,j]) + " ")
+            else:
+                F.write(str(self[i,j]) + " ")
+        F.write("\n")
+
+    ## Write the second form
+    F.write("\n")
+    n = self.dim()
+    F.write(str(n) + "x0 \n")      ## Use the lower-triangular form
+    for i in range(n):
+        for j in range(i+1):
+            if i == j:
+                F.write(str(2 * other[i,j]) + " ")
+            else:
+                F.write(str(other[i,j]) + " ")
+        F.write("\n")
+    F.flush()
+    #print "Input filename = ", F.name
+    #os.system("less " + F.name)
+
+    ## Call the Souvigner automorphism code
+    souvigner_isom_path = SAGE_ROOT + "/devel/sage-qfdevel/sage/quadratic_forms/automorphisms/ISOM32" 
+    G1 = tempfile.NamedTemporaryFile(prefix='tmp_isom_ouput', suffix=".txt")
+    #print "Output filename = ", G1.name
+    #print  "Executing the shell command:   " + souvigner_isom_path + " '" +  F.name + "' > '" + G1.name + "'"
+    os.system(souvigner_isom_path + " '" +  F.name + "' > '" + G1.name +"'")
+
+
+    ## Read the output
+    G2 = open(G1.name, 'r')
+    line = G2.readline()
+    if line.startswith("Error:"):
+        raise RuntimeError, "There is a problem using the souvigner code...  " + line
+    elif line.find("not isomorphic") != -1:     ## Checking if this text appears, if so then they're not isomorphic!
+        return False
+    else:
+        ## Decide whether to read the transformation matrix, and return true
+        if not return_transformation:
+            F.close()
+            G1.close()
+            G2.close()
+            os.system("rm -f " + F_filename)
+            return True
+        else:
+            ## Try to read the isomorphism matrix
+            M = Matrix(ZZ, n, n)
+            for i in range(n):
+                new_row_text = G2.readline().split()
+                #print new_row_text
+                for j in range(n):
+                    M[i,j] = new_row_text[j]
+
+            ## Remove temporary files and return the value
+            F.close()
+            G1.close()
+            G2.close()
+            os.system("rm -f " + F_filename)
+            return True, M
+
+    ## Raise and error if we're here:
+    raise RuntimeError, "Oops! There is a problem..."
+
+
+
+def is_globally_equivalent_to(self, other, return_matrix=False, check_theta_to_precision='sturm', check_local_equivalence=True):
+    """
+    Determines if the current quadratic form is equivalent to the
+    given form over ZZ.  If return_matrix is True, then we also return
+    the transformation matrix M so that self(M) == other.
+
+    INPUT:
+        a QuadraticForm
+
+    OUTPUT:
+        boolean, and optionally a matrix
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+        sage: M = Matrix(ZZ, 4, 4, [1,2,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1])
+        sage: Q1 = Q(M)
+        sage: Q.is_globally_equivalent_to(Q1)
+        True
+        sage: Q.is_globally_equivalent_to(Q1, return_matrix=True)
+        [1 2 0 0]
+        [0 1 0 0]
+        [0 0 1 0]
+        [0 0 0 1]
+        sage: Q.is_globally_equivalent_to(Q1, return_matrix=True) == M
+        True
+    """
+    ## Now use the Souvigner code by default! =)
+    return self.is_globally_equivalent__souvigner(other)
+
+    ## ----------------------------------  Unused Code below  ---------------------------------------------------------
+
+    ## Check if the forms are locally equivalent
+    if (check_local_equivalence == True):
+        if not self.is_locally_equivalent_to(other):
+            return False
+
+    ## Check that the forms have the same theta function up to the desired precision (this can be set so that it determines the cusp form)
+    if check_theta_to_precision != None:
+        if self.theta_series(check_theta_to_precision, var_str='', safe_flag=False) != other.theta_series(check_theta_to_precision, var_str='', safe_flag=False):
+            return False
+
+
+    ## Make all possible matrices which give an isomorphism -- can we do this more intelligently?
+    ## ------------------------------------------------------------------------------------------
+
+    ## Find a basis of short vectors for one form, and try to match them with vectors of that length in the other one.
+    basis_for_self, self_lengths = self.basis_of_short_vectors(show_lengths=True)
+    max_len = max(self_lengths)
+    short_vectors_of_other = other.short_vector_list_up_to_length(max_len + 1)
+
+    ## Make the matrix A:e_i |--> v_i to our new basis.
+    A = Matrix(basis_for_self).transpose()
+    Q2 = A.transpose() * self.matrix() * A       ## This is the matrix of 'self' in the new basis
+    Q3 = other.matrix()
+        
+    ## Determine all automorphisms
+    n = self.dim()
+    Auto_list = []
+    
+    ## DIAGNOSTIC
+    #print "n = " + str(n)
+    #print "pivot_lengths = " + str(pivot_lengths)
+    #print "vector_list_by_length = " + str(vector_list_by_length)
+    #print "length of vector_list_by_length = " + str(len(vector_list_by_length))
+    
+    for index_vec in mrange([len(short_vectors_of_other[self_lengths[i]])  for i in range(n)]):
+        M = Matrix([short_vectors_of_other[self_lengths[i]][index_vec[i]]   for i in range(n)]).transpose()
+        if M.transpose() * Q3 * M == Q2:
+            if return_matrix:
+                return A * M.inverse()
+            else:
+                return True
+                        
+    ## If we got here, then there is no isomorphism
+    return False
+
+    
+def is_locally_equivalent_to(self, other, check_primes_only=False, force_jordan_equivalence_test=False):
+    """
+    Determines if the current quadratic form (defined over ZZ) is
+    locally equivalent to the given form over the real numbers and the
+    p-adic integers for every prime p.
+
+    This works by comparing the local Jordan decompositions at every
+    prime, and the dimension and signarure at the real place.
+    
+    """
+    ## TO IMPLEMENT:
+    if self.det() == 0:
+        raise NotImplementedError, "OOps!  We need to think about whether this still works for degenerate forms...  especially check the signature."
+
+    ## Check that both forms have the same dimension and base ring
+    if (self.dim() != other.dim()) or (self.base_ring() != other.base_ring()):
+        return False
+
+    ## Check that the determinant and level agree
+    if (self.det() != other.det()) or (self.level() != other.level()):
+        return False
+
+    ## -----------------------------------------------------
+
+    ## Test equivalence over the real numbers
+    if self.signature() != other.signature():
+        return False    
+
+    ## Test equivalence over Z_p for all primes
+    if (self.base_ring() == ZZ) and (force_jordan_equivalence_test == False):
+
+        ## Test equivalence with Conway-Sloane genus symbols (default over ZZ)
+        if self.CS_genus_symbol_list() != other.CS_genus_symbol_list():
+            return False
+    else:
+        ## Test equivalence via the O'Meara criterion.
+        for p in prime_divisors(ZZ(2) * self.det()):
+            #print "checking the prime p = ", p
+            if not self.has_equivalent_Jordan_decomposition_at_prime(other, p):
+                return False
+
+    ## All tests have passed!
+    return True
+
+
+
+
+def has_equivalent_Jordan_decomposition_at_prime(self, other, p):
+    """
+    Determines if the given quadratic form has a Jordan decomposition
+    equivalent to that of self.
+    """
+    ## Sanity Checks
+    #if not isinstance(other, QuadraticForm):
+    if type(other) != type(self):
+        raise TypeError, "Oops!  The first argument must be of type QuadraticForm."
+    if not is_prime(p):
+        raise TypeError, "Oops!  The second argument must be a prime number."
+
+    ## Get the relevant local normal forms quickly
+    self_jordan = self.jordan_blocks_by_scale_and_unimodular(p, safe_flag= False)
+    other_jordan = other.jordan_blocks_by_scale_and_unimodular(p, safe_flag=False)    
+
+    ## DIAGNOSTIC
+    #print "self_jordan = ", self_jordan
+    #print "other_jordan = ", other_jordan
+
+
+    ## Check for the same number of Jordan components
+    if len(self_jordan) != len(other_jordan):
+        return False
+
+
+    ## Deal with odd primes:  Check that the Jordan component scales, dimensions, and discriminants are the same
+    if p != 2:
+        for i in range(len(self_jordan)):
+            if (self_jordan[i][0] != other_jordan[i][0]) \
+               or (self_jordan[i][1].dim() != other_jordan[i][1].dim()) \
+               or (legendre_symbol(self_jordan[i][1].det() * other_jordan[i][1].det(), p) != 1):
+                return False
+
+        ## All tests passed for an odd prime.
+        return True
+
+
+    ## For p = 2:  Check that all Jordan Invariants are the same.
+    elif p == 2:
+
+        ## Useful definition
+        t = len(self_jordan)          ## Define t = Number of Jordan components
+
+
+        ## Check that all Jordan Invariants are the same (scale, dim, and norm)
+        for i in range(t):
+            if (self_jordan[i][0] != other_jordan[i][0]) \
+               or (self_jordan[i][1].dim() != other_jordan[i][1].dim()) \
+               or (valuation(GCD(self_jordan[i][1].coefficients()), p) != valuation(GCD(other_jordan[i][1].coefficients()), p)):
+                return False
+
+        ## DIAGNOSTIC
+        print "Passed the Jordan invariant test."
+
+
+        ## Use O'Meara's isometry test 93:29 on p277.
+        ## ------------------------------------------
+
+        ## List of norms, scales, and dimensions for each i
+        scale_list = [ZZ(2)**self_jordan[i][0]  for i in range(t)]
+        norm_list = [ZZ(2)**(self_jordan[i][0] + valuation(GCD(self_jordan[i][1].coefficients()), 2))  for i in range(t)]
+        dim_list = [GCD(self_jordan[i][1].dim())  for i in range(t)]
+
+        ## List of Hessian determinants and Hasse invariants for each Jordan (sub)chain
+        ## (Note: This is not the same as O'Meara's Gram determinants, but ratios are the same!)  -- NOT SO GOOD...
+        ## But it matters in condition (ii), so we multiply all by 2 (instead of dividing by 2 since only square-factors matter, and it's easier.)
+        j = 0
+        self_chain_det_list = [ self_jordan[j][1].Gram_det() * (scale_list[j]**dim_list[j])]
+        other_chain_det_list = [ other_jordan[j][1].Gram_det() * (scale_list[j]**dim_list[j])]
+        self_hasse_chain_list = [ self_jordan[j][1].scale_by_factor(ZZ(2)**self_jordan[j][0]).hasse_invariant__OMeara(2) ]
+        other_hasse_chain_list = [ other_jordan[j][1].scale_by_factor(ZZ(2)**other_jordan[j][0]).hasse_invariant__OMeara(2) ]
+                   
+        for j in range(1, t):
+            self_chain_det_list.append(self_chain_det_list[j-1] * self_jordan[j][1].Gram_det() * (scale_list[j]**dim_list[j]))
+            other_chain_det_list.append(other_chain_det_list[j-1] * other_jordan[j][1].Gram_det() * (scale_list[j]**dim_list[j]))
+            self_hasse_chain_list.append(self_hasse_chain_list[j-1] \
+                                         * hilbert_symbol_rational(self_chain_det_list[j-1], self_jordan[j][1].Gram_det(), 2) \
+                                         * self_jordan[j][1].hasse_invariant__OMeara(2))
+            other_hasse_chain_list.append(other_hasse_chain_list[j-1] \
+                                          * hilbert_symbol_rational(other_chain_det_list[j-1], other_jordan[j][1].Gram_det(), 2) \
+                                          * other_jordan[j][1].hasse_invariant__OMeara(2))
+
+
+        ## SANITY CHECK -- check that the scale powers are strictly increasing        
+        for i in range(1, len(scale_list)):
+            if scale_list[i-1] >= scale_list[i]:
+                   raise RuntimeError, "Oops!  There is something wrong with the Jordan Decomposition -- the given scales are not strictly increasing!"
+
+
+        ## DIAGNOSTIC
+        print "scale_list = ", scale_list
+        print "norm_list = ", norm_list
+        print "dim_list = ", dim_list
+        print
+        print "self_chain_det_list = ", self_chain_det_list
+        print "other_chain_det_list = ", other_chain_det_list
+        print "self_hasse_chain_list = ", self_hasse_chain_list
+        print "other_hasse_chain_det_list = ", other_hasse_chain_list
+
+        
+        ## Test O'Meara's two conditions
+        for i in range(t-1):
+
+            ## Condition (i): Check that their (unit) ratio is a square (but it suffices to check at most mod 8).
+            modulus = norm_list[i] * norm_list[i+1] / (scale_list[i] ** 2)
+            if modulus > 8:
+                   modulus = 8 
+            if (modulus > 1) and (((self_chain_det_list[i] / other_chain_det_list[i]) % modulus) != 1):
+                print "Failed when i =", i, " in condition 1."
+                return False
+            
+            ## Check O'Meara's conditon (ii) when appropriate
+            if norm_list[i+1] % (4 * norm_list[i]) == 0:
+                # 1st try # if self_hasse_chain_list[i] * other_hasse_chain_list[i] * hilbert_symbol(-self_chain_det_list[i], norm_list[i] * other_chain_det_list[i], 2) != 1:
+                ##  Corrected ## if self_hasse_chain_list[i] * other_hasse_chain_list[i] * hilbert_symbol(-self_chain_det_list[i], norm_list[i], 2) != 1:
+                if self_hasse_chain_list[i] * hilbert_symbol_rational(norm_list[i] * other_chain_det_list[i], -self_chain_det_list[i], 2) \
+                       != other_hasse_chain_list[i] * hilbert_symbol_rational(norm_list[i], -other_chain_det_list[i], 2):      ## Nipp conditions
+                    print "Failed when i =", i, " in condition 2."
+                    return False
+
+
+        ## All tests passed for the prime 2.
+        return True
+            
+    else:
+        raise TypeError, "Oops!  This should not have happened."
+
+
+
+
+    
+
+
diff --git a/sage/quadratic_forms/quadratic_form__evaluate.pyx b/sage/quadratic_forms/quadratic_form__evaluate.pyx
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__evaluate.pyx
@@ -0,0 +1,61 @@
+
+
+def QFEvaluateVector(Q, v):
+    """
+    Python wrapper for our fast evaluation routine.
+    """
+    return QFEvaluateVector_cdef(Q, v)
+
+
+
+cdef QFEvaluateVector_cdef(Q, v):
+    """
+    Evaluate this quadratic form Q on a vector or matrix of elements
+    coercible to the base ring of the quadratic form.  If a vector
+    is given then the output will be the ring element Q(v), but if a
+    matrix is given then the output will be the quadratic form Q'
+    which in matrix notation is given by:
+
+            Q' = v^t * Q * v.
+
+    """
+    ## If we are passed a matrix A, return the quadratic form Q(A(x)) 
+    ## (In matrix notation: A^t * Q * A) 
+    n = Q.dim()
+
+    tmp_val = Q.base_ring()(0)
+    for i from 0 <= i < n:
+        for j from i <= j < n:
+            tmp_val += Q[i,j] * v[i] * v[j]
+
+    ## Return the value (over R)
+    return Q.base_ring()._coerce_(tmp_val)
+    
+
+
+def QFEvaluateMatrix(Q, v, Q2):
+    """
+    Python wrapper for our fast evaluation routine.
+    """
+    return QFEvaluateMatrix_cdef(Q, v, Q2)
+
+
+
+cdef QFEvaluateMatrix_cdef(Q, v, Q2):
+    """
+    Fast evaluation on a matrix. 
+    """
+    ## Create the new quadratic form
+    n = Q.dim()
+    m = Q2.dim()
+    for k from 0 <= k < m:
+        for l from k <= l < m:
+            tmp_sum = Q2.base_ring()(0)
+            for i from 0 <= i < n:
+                for j from i <= j < n:
+                    if (k == l):
+                        tmp_sum += Q[i,j] * (v[i,k] * v[j,l])
+                    else:
+                        tmp_sum += Q[i,j] * (v[i,k] * v[j,l] + v[i,l] * v[j,k])
+            Q2[k,l] = tmp_sum
+    return Q2
diff --git a/sage/quadratic_forms/quadratic_form__genus.py b/sage/quadratic_forms/quadratic_form__genus.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__genus.py
@@ -0,0 +1,92 @@
+
+
+#############################################################
+##                                                         ##
+##  Wrappers for the Genus/Genus Symbol Code in ../genera/ ##
+##                                                         ##
+#############################################################
+
+from sage.quadratic_forms.genera.genus import Genus, LocalGenusSymbol, \
+        is_GlobalGenus, is_2_adic_genus, canonical_2_adic_compartments, \
+        canonical_2_adic_trains, canonical_2_adic_reduction, \
+        basis_complement, signature_of_matrix, p_adic_symbol, is_even, \
+        split_odd,  trace_diag, two_adic_symbol, is_trivial_symbol
+        #GenusSymbol_p_adic_ring, GenusSymbol_global_ring
+## NOTE: Removed the signature routine here... and rewrote it for now.
+
+
+from sage.rings.integer_ring import IntegerRing
+from sage.rings.arith import is_prime, prime_divisors
+
+
+
+def global_genus_symbol(self):
+    """
+    Returns the genus of a two times a quadratic form over ZZ.  These
+    are defined by a collection of local genus symbols (a la Chapter
+    15 of Conway-Sloane), and a signature.
+
+    EXAMPLES:
+    """
+    ## Check that the form is defined over ZZ
+    if not self.base_ring() == IntegerRing():
+        raise TypeError, "Oops!  The quadratic form is not defined over the integers."
+
+    ## Return the result
+    try:
+        return Genus(self.Hessian_matrix())      
+    except:
+        raise TypeError, "Oops!  There is a problem computing the genus symbols for this form."
+
+
+
+def local_genus_symbol(self, p):
+    """
+    Returns the Conway-Sloane genus symbol of 2 times a quadratic form defined
+    over ZZ at a prime number p.
+
+    INPUT:
+        p -- a prime number > 0
+
+    OUTPUT:
+        Returns a Conway-Sloane genus symbol.
+
+    EXAMPLES:
+    """
+    ## Check that p is prime and that the form is defined over ZZ.
+    if not is_prime(p):
+        raise TypeError, "Oops!  The number " + str(p) + " isn't prime."
+    if not self.base_ring() == IntegerRing():
+        raise TypeError, "Oops!  The quadratic form is not defined over the integers."
+
+    ## Return the result
+    try:
+        M = self.Hessian_matrix()
+        return LocalGenusSymbol(M, p)      
+    except:
+        raise TypeError, "Oops!  There is a problem computing the local genus symbol at the prime " + str(p) + " for this form."
+
+
+
+
+
+
+def CS_genus_symbol_list(self, force_recomputation=False):
+    """
+    Returns the list of Conway-Sloane genus symbols in increasing order of primes dividing 2*det.
+    """    
+    ## Try to use the cached list
+    if force_recomputation == False:
+        try:
+            return self.__CS_genus_symbol_list
+        except:
+            pass
+
+    ## Otherwise recompute and cache the list
+    list_of_CS_genus_symbols = [ ]
+
+    for p in prime_divisors(2 * self.det()):
+        list_of_CS_genus_symbols.append(self.local_genus_symbol(p))
+
+    self.__CS_genus_symbol_list = list_of_CS_genus_symbols
+    return list_of_CS_genus_symbols
diff --git a/sage/quadratic_forms/quadratic_form__local_density_congruence.py b/sage/quadratic_forms/quadratic_form__local_density_congruence.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__local_density_congruence.py
@@ -0,0 +1,792 @@
+
+## Include headers from the front-end (repeated execution) routines.
+#include <assert.h>
+
+
+
+#####################################################
+## Historical Note:
+## ----------------
+## (Much) Older versions of the NTL code can be found at
+## Old-Laptop-Odyssues_Extended-Home-directory_8-28-2003/home/jonhanke/TEMP/C++/Modular_Project/
+##
+##  Updated for GMP libraries on 1/21/04
+#####################################################
+
+from copy import deepcopy
+
+from sage.sets.set import Set
+from sage.rings.rational_field import QQ 
+from sage.rings.arith import valuation, kronecker_symbol 
+from sage.rings.integer_ring import ZZ
+from sage.misc.misc import prod, verbose
+
+##############################################################################
+### Creates a new index vector which points to the extracted rows/columns
+### in the extracted matrix where the ...?
+###
+### This is used internally in our reduction procedure which allows us
+### to keep track of a list of (row/column) indices through the
+### process of extracting a submatrix corresponding to some other set
+### of (row/column) indices.
+###
+### (Note: This is probably not very efficient, 
+### and could be improved by using vectors, 
+### but we're using valarrays for now...)  
+#############################################################################
+
+
+def reindex_vector_from_extraction(self, Original, Extracted):
+    """
+    This takes a vector of indices, and applies a  truncated permutation to them,
+    defined by Extracted.
+
+    TO DO: Please revisit this routine, and eliminate it!
+
+    valarray<size_t> Matrix_mpz::reindex_vector_from_extraction(const valarray<size_t> & Original, const valarray<size_t> & Extracted) const
+    """
+    ## Set some default values (all to be overwritten)
+    Reindex = [-1  for i in range(len(Original))]
+  
+    ## Replace all Original indices entries with the position of the matching Extraced index
+    ind = 0
+    for i in range(len(Original)):
+        for i in range(len(Extracted)):
+            if (Original[i] == Extracted[j]):
+                Reindex[ind] = j
+                ind += 1 
+  
+    ## Copy these to a new vecarray of the appropriate length -- Since Reindex may be too big
+    Final = [Reindex[i]  for i in range(ind)] 
+  
+    return Final
+
+
+
+
+def count_modp__by_gauss_sum(self, n, p, m, Qdet):
+    """
+    Returns the number of solutions of Q(x) = m over the finite field F_p, 
+    where p is a prime number > 2 and Q has determinant Qdet.
+
+    These are defined in Table 1 on p363 of Hanke's "Local Densities..." paper.
+    """
+    neg1 = -1
+
+    ## DIAGNOSTIC
+    verbose(" n = " + str(n)) 
+    verbose(" neg1 = " + str(neg1))
+    verbose(" p**(n-1) = " + str(p**(n-1)))
+    
+    if ((p != 2) and (n >= 1)):   ## TO DO: Check that p is an odd prime and n >= 1  --  To Do: Need to check if p is a prime...
+
+        if (m % p == 0):
+            if (n % 2 != 0):
+                count = (p**(n-1))
+            else:
+                count = (p**(n-1)) + (p-1) * (p**((n-2)/2)) * kronecker_symbol(((neg1**(n/2)) * Qdet) % p, p)
+        else:
+            if (n % 2 != 0):
+                count = (p**(n-1)) + (p**((n-1)/2)) * kronecker_symbol(((neg1**((n-1)/2)) * Qdet * m) % p, p)
+            else:
+                count = (p**(n-1)) - (p**((n-2)/2)) * kronecker_symbol(((neg1**(n/2)) * Qdet) % p, p)
+
+    else:
+        raise RuntimeError, "\n Error in count_modp__by_gauss_sum: Either p is not prime or n<1. \n"
+  
+    return count
+
+
+
+
+
+def local_good_density_congruence_odd(self, p, m, Zvec, NZvec):
+    """
+    Finds the Good-type local density of Q representing m at p.  
+    (Assuming that p > 2 and Q is given in local diagonal form.) 
+
+    mpq_class Matrix_mpz::local_good_density_congruence_odd(const mpz_class & p, const mpz_class & m, 
+                                            const valarray<size_t> & Zvec, const valarray<size_t> & NZvec) const
+    """
+
+    ## To Do: Check to see if Q_int is diagonal (only ok for p>2)
+  
+
+    n = self.dim()
+  
+  
+    ## Assuming Q is diagonal, find the indices of the p-unit (diagonal) entries
+    Qtrimvec = [i  for i in range(n)  if (self.__getitem__((i,i)) % p) != 0]
+    
+
+
+    ## DEBUGGING:  Check the matrix is primitive -- 
+    ##   (WARNING: We may be passed imprimitive form from the BI-reduction...)  <==  This should be fixed now. =)
+    if (Qtrimvec == []):
+        raise RuntimeError, "Uh oh.  There should be some p-unit diagonal elements at this stage...  but Qtrimvec is empty. =("
+
+
+
+    ## DIAGNOSTIC
+    #print " Stage 1" 
+    #print " Q = " + str(Q)
+    #print " n = " + str(n) + "  and  Qtrimvec = " + str(Qtrimvec)
+
+
+    Qtrim = self.extract_variables(Qtrimvec)
+
+
+    ## print "We're here now..." << endl;
+
+  
+    ## Construct the big and small matrices: 
+    ## -------------------------------------
+
+    ## Construct new congruence condition indices for the trimmed matrix
+    trimZvec = self.reindex_vector_from_extraction(Zvec, Qtrimvec)
+
+
+    ## DIAGNOSTIC
+    #print "\n Zvec = " + str(Zvec) 
+    #print " NZvec = " + str(NZvec) 
+    #print " Qtrim = " + str(Qtrim) 
+    #print " Qtrimvec = " + str(Qtrimvec) 
+    #print " trimZvec = " + str(trimZvec)
+    #####  print " Vector indexing Qtrim = " << range(len(Qtrimvec))
+    #####  print " and its complement by trimZvec  = " << VectorComplement(range(len(Qtrimvec)), trimZvec) 
+
+
+
+    ## print "Getting closer..." 
+
+
+    ## Make the big trim vector (all trim indices not somewhere in Zvec) 
+    ##   and the big free vector (all non-trim indices not somewhere in Zvec) 
+    ##   [To Do: This could probably be faster if we assumed Zvec was ordered.]
+    bigtrimvec = [ i  for i in range(len(Qtrimvec))  if i not in trimZvec]
+    bigfreelength = (n - len(Qtrimvec)) - (len(Zvec) - len(trimZvec))
+
+
+
+
+    ## Make the small vector from the big one (all indices not somewhere in Zvec or NZvec) 
+    new_vec = list(Set(Zvec + NZvec))
+    trim_new_vec = self.reindex_vector_from_extraction(new_vec, Qtrimvec) 
+
+
+    smalltrimvec = [ i  for i in range(len(Qtrimvec))  if i not in new_vec]
+    smallfreelength = (n - len(Qtrimvec)) - (len(new_vec) - len(trim_new_vec))
+
+
+
+    ## Make the big and small matrices 
+    bigmatrix = Qtrim.extract_variables(bigtrimvec)
+    smallmatrix = Qtrim.extract_variables(smalltrimvec)
+
+
+    ## DIAGNOSTIC
+    #print "\n Q is : " + str(self) 
+    #print " m is : " + str(m) 
+    #print " p is : " + str(p) 
+    #print " Qtrim is : " + str(Qtrim) 
+    #print " bigtrimvec is : " + str(bigtrimvec) 
+    #print " bigfreelength is : " + str(bigfreelength) 
+    #print " smalltrimvec is : " + str(smalltrimvec) 
+    #print " smallfreelength is : " + str(smallfreelength) 
+    #print " bigmatrix is : \n" + str(bigmatrix) 
+    #print " smallmatrix is : \n" + str(smallmatrix)
+
+
+    ## print "And closer still..." 
+
+  
+    ## Number of representations
+  
+
+    ## Adjust the local solutions to count only the good-type ones
+    if (bigtrimvec == []):    ## Check if we have the empty matrix...
+        big_factor = 0
+
+    else:
+        big_dim = bigmatrix.dim()
+        big_det = prod([bigmatrix[i,i]  for i in range(bigmatrix.dim())])   ## This gives the product of the diagonal entries, not the Gram matrix det
+
+        if (m % p != 0):
+            big_factor = (p**bigfreelength) \
+                * self.count_modp__by_gauss_sum(big_dim, p, m, big_det)
+        else:
+            big_factor = (p**bigfreelength) \
+                * (self.count_modp__by_gauss_sum(big_dim, p, m, big_det) - 1)
+
+
+    ## Similarly for the smallmatrix if it exists
+    if (smalltrimvec == []):    ## Check if we have the empty matrix...
+        small_factor = 0
+
+    else:
+        if (len(NZvec) > 0): 
+            small_dim = smallmatrix.dim()
+            small_det = prod([smallmatrix[i,i]  for i in range(smallmatrix.dim())])   ## This gives the product of the diagonal entries, not the Gram matrix det
+
+            if (m % p != 0):
+                small_factor = (p**smallfreelength) \
+                    * self.count_modp__by_gauss_sum(small_dim, p, m, small_det) 
+            else:
+                small_factor = (p**smallfreelength) \
+                    * (self.count_modp__by_gauss_sum(small_dim, p, m, small_det) - 1) 
+  
+        else:
+            small_factor = 0
+  
+    total = big_factor - small_factor
+    good_density = QQ(total / p**(n-1))
+  
+  
+    ## DIAGNOSTIC
+    #print "\n big factor = " + str(big_factor)
+    #print " small factor = " + str(small_factor) 
+    #print " big_det = " + str(prod([bigmatrix[i,i]  for i in range(bigmatrix.dim())]))
+    #print " smal_det = " + str(prod([smallmatrix[i,i]  for i in range(smallmatrix.dim())]))
+    #print " total = " + str(total) 
+    #print " denominator = " + str(p**(n-1)) 
+    #print " Good Density = " + str(good_density) 
+    #print " count_modp__by_gauss_sum output = " + str(self.count_modp__by_gauss_sum(big_dim, p, m, prod([bigmatrix[i,i]  for i in range(bigmatrix.dim())])))
+
+    return good_density 
+
+
+
+
+
+def local_good_density_congruence_even(self, p, m, Zvec, NZvec):
+    """
+    Finds the Good-type local density of Q representing m at p.  
+    (Assuming that p = 2 and Q is given in local normal form.) 
+
+    mpq_class Matrix_mpz::local_good_density_congruence_even(const mpz_class & p, const mpz_class & m, 
+                                             const valarray<size_t> & Zvec, const valarray<size_t> & NZvec) const
+    """
+    #print " Break 0" 
+    #print "\n Q is : " + str(Q)
+
+    n = self.dim()
+  
+  
+    ## Assuming Q is diagonal, trim it to ensure it's non-degenerate mod 8      <--- ??? Do we really assume that Q is diagonal?!?!?  =(
+    Qtrimvec = [] 
+
+    #print " Break 0.1" 
+
+    ## Find the indices of the non-zero blocks mod 8
+    for i in range(n):
+ 
+        ## DIAGNOSTIC
+        verbose(" i = " + str(i))
+        verbose(" n = " + str(n))
+        verbose(" Qtrimvec = " + str(Qtrimvec))
+
+        nz_flag = False
+
+        if  ((self[i,i] % 8) != 0):  
+            nz_flag = True
+        else:
+            #print " here 1" 
+            if ((i == 0) and ((self[i,i+1] % 8) != 0)):
+                nz_flag = True
+            else:
+                #print " here 2" << endl;
+                if ((i == n-1) and ((self[i-1,i] % 8) != 0)):
+                    nz_flag = True
+                else:
+                    #print " here 3" << endl;
+                    if ( (i > 0)  and  (i < n-1)  and  (((self[i,i+1] % 8) != 0) or ((self[i-1,i] % 8) != 0)) ):
+                        nz_flag = True
+
+      
+        if (nz_flag == True):
+            Qtrimvec += [i]
+
+
+    #print " Break 1" 
+
+
+    ## DEBUGGING: Quick tests to make sure the form isn't zero mod 8
+    if (Qtrimvec == []):
+        raise RuntimeError, "Oh no!  The quadratic form should always be non-degenerate mod 8... =("
+  
+
+    Qtrim = self.extract_variables(Qtrimvec) 
+
+
+    ## DEBUGGING: Quick tests to make sure the extracted form isn't zero mod 8
+    assert(Qtrim.dim() > 0);
+
+    #print " Break 2" 
+
+
+    ## Construct the big and small matrices: 
+    ## -------------------------------------
+
+    ## Construct new congruence condition indices for the trimmed matrix
+    trimZvec = self.reindex_vector_from_extraction(Zvec, Qtrimvec) 
+    trimNZvec = self.reindex_vector_from_extraction(NZvec, Qtrimvec)
+
+    ## Make the trimmed congruence vector 
+    new_vec = list(Set(Zvec + NZvec))
+    trim_vec = self.reindex_vector_from_extraction(new_vec, Qtrimvec)
+
+    ## DIAGNOSTIC
+    verbose("")
+    verbose("Zvec = " + str(Zvec))
+    verbose("NZvec = " + str(NZvec))
+    verbose("new_vec = " + str(new_vec))
+    verbose("")
+
+
+    ## DIAGNOSTIC
+    verbose("\n Q is : " + str(self))
+    verbose(" m is : " + str(m))
+    verbose(" Qtrim is : " + str(Qtrim))
+    verbose(" Qtrimvec is : " + str(Qtrimvec))
+    verbose(" trimZvec is : " + str(trimZvec))
+    verbose(" trimNZvec is : " + str(trimNZvec))
+
+
+    ## DEBUGGING: Check that partlyfreenum is in range...
+    if not (len(new_vec) >= len(trim_vec)):
+        raise RuntimeError, "Oh no!  Some variable called 'partlyfreenum' is out of range. =("
+
+  
+    ## Compute the number of different free components 
+    partlyfreenum = len(new_vec) - len(trim_vec)
+    veryfreenum = (n - len(Qtrimvec)) - partlyfreenum
+
+
+    ## In the free part, each component with a congruence condition contrubite a factor of 4, 
+    ## while components with no congruence conditions contribute a factor of 8.
+
+    total = (4 ** partlyfreenum) * (8 ** veryfreenum) \
+        * Qtrim.count_local_good_type(2, 3, m, trimZvec, trimNZvec) 
+    good_density = ZZ(total) / ZZ(8**(n-1))
+  
+  
+    ## DIAGNOSTIC
+    verbose(" partlyfreenum = " + str(partlyfreenum))
+    verbose(" veryfreenum = " + str(veryfreenum))
+    verbose(" Qtrim.count_local_good_type(2, 3, m, trimZvec, trimNZvec) = " + str(Qtrim.count_local_good_type(2, 3, m, trimZvec, trimNZvec)))
+    verbose(" total = " + str(total))
+    verbose("    total has type ", type(total))
+    verbose(" denominator = " + str(8**(n-1)))
+    verbose(" Good Density = " + str(good_density))
+
+    return good_density 
+
+
+
+    ############################################
+     ## Note: Assumes all forms are primitive       <== What does this mean?!?
+    ############################################
+
+
+
+def local_good_density_congruence(self, p, m, Zvec, NZvec):
+    """
+    Finds the Good-type local density of Q representing m at p.  
+    (Front end routine for parity specific routines for p.)      
+
+    mpq_class Matrix_mpz::local_good_density_congruence(const mpz_class & p, const mpz_class & m,
+                                        const valarray<size_t> & Zvec, const valarray<size_t> & NZvec) const
+    """
+    ## DIAGNOSTIC
+    verbose(" In local_good_density_congruence with ") 
+    verbose(" Q is: \n" + str(self)) 
+    verbose(" p = " + str(p))
+    verbose(" m = " + str(m)) 
+    verbose(" Zvec = " + str(Zvec)) 
+    verbose(" NZvec = " + str(NZvec))
+
+
+    ## Check that Q is in local normal form -- should replace this with a diagonalization check?
+    ##   (it often may not be since the reduction procedure 
+    ##   often mixes up the order of the valuations...)
+    #
+    #if (self != self.local_normal_form(p))
+    #    print "Warning in local_good_density_congruence: Q is not in local normal form! \n";
+
+
+
+    ## Check that the congruence conditions don't overlap
+    if (len(Set(Zvec).intersection(Set(NZvec))) != 0):
+        return QQ(0)
+
+    #print "We're here!" 
+  
+
+    ## Decide which routine to use to compute the Good-type density
+    if (p > 2): 
+        return self.local_good_density_congruence_odd(p, m, Zvec, NZvec)
+
+    if (p == 2):
+        #print "\n Using the (p=2) Local_Good_Density_Even routine! \n"
+        return self.local_good_density_congruence_even(p, m, Zvec, NZvec)
+
+    raise RuntimeError, "\n Error in Local_Good_Density: The 'prime' p = " + str(p) + " is < 2. \n"
+
+
+
+
+
+
+
+def local_zero_density_congruence(self, p, m, Zvec, NZvec):
+    """
+    Finds the Zero-type local density of Q representing m at p,
+    allowing certain congruence conditions mod p.
+
+    mpq_class Matrix_mpz::local_zero_density_congruence(const mpz_class & p, const mpz_class & m,
+                                        const valarray<size_t> & Zvec, const valarray<size_t> & NZvec) const
+    """
+    ## DIAGNOSTIC
+    #print " In local_zero_density_congruence with " 
+    #print " Q is: \n" + str(self) 
+    #print " p = " + str(p) 
+    #print " m = " + str(m) 
+    #print " Zvec = " + str(Zvec) 
+    #print " NZvec = " + str(NZvec) 
+
+    p2 = p * p
+
+    if ((m % (p2) != 0) or (len(NZvec) > 0)):
+        return 0
+    else:
+        ## Need 2 steps since we can't take negative powers... =|
+        EmptyVec = []
+        if (self.dim() > 2): 
+            return QQ(1 / p**(self.dim() - 2)) \
+                * self.local_density_congruence(p, m / (p2), EmptyVec, EmptyVec); 
+        else:
+            return QQ(p**(2 - self.dim())) \
+                * self.local_density_congruence(p, m / (p2), EmptyVec, EmptyVec); 
+
+
+
+
+
+
+def local_badI_density_congruence(self, p, m, Zvec, NZvec):
+    """
+    Finds the Bad-type I local density of Q representing m at p.
+    (Assuming that p > 2 and Q is given in local diagonal form.)
+
+    mpq_class Matrix_mpz::local_badI_density_congruence(const mpz_class & p, const mpz_class & m,
+                                        const valarray<size_t> & Zvec, const valarray<size_t> & NZvec) const
+    """
+    ## DIAGNOSTIC
+    #print " In local_badI_density_congruence with " 
+    #print " Q is: \n" + str(self) 
+    #print " p = " + str(p) 
+    #print " m = " + str(m) 
+    #print " Zvec = " + str(Zvec) 
+    #print " NZvec = " + str(NZvec) 
+
+
+    n = self.dim()
+    if n == 0:
+        raise RuntimeException, "Oops!  We don't currently allow 0-dim'l forms... =( " 
+
+
+    ## Define the indexing sets S_i
+    S0 = []
+    S1_empty_flag = True    ## This is used to check if we should be computing BI solutions at all! 
+                            ## (We should really to this earlier, but S1 must be non-zero to proceed.)
+
+
+    ## Find the valuation of each variable (which will be the same over 2x2 blocks),
+    ## remembering those of valuation 0 and if an entry of valuation 1 exists.
+    for i in range(n):
+
+        ## Compute the valuation of each index, allowing for off-diagonal terms
+        if (self[i,i] == 0):
+            if (i == 0):
+                val = valuation(self[i,i+1], p)    ## Look at the term to the right
+            else:
+                if (i == n-1):
+                    val = valuation(self[i-1,i], p)    ## Look at the term above
+                else:
+                    val = valuation(self[i,i+1] + self[i-1,i], p)    ## Finds the valuation of the off-diagonal term since only one isn't zero    
+        else:
+            val = valuation(self[i,i], p)
+
+        if (val == 0):
+            S0 += [i]       
+        elif (val == 1):
+            S1_empty_flag = False    ## Need to have a non-empty S1 set to proceed with Bad-type I reduction...
+      
+    ## Check that S1 is non-empty to proceed, otherwise return no solutions.
+    if (S1_empty_flag == True):
+        return 0
+
+
+    ## Check that the form is primitive...
+    if (S0 == []):
+        print " Using Q = " + str(self)
+        print " and p = " + str(p)
+        raise RuntimeError, "Oops! The form is not primitive!"
+
+
+    S0New = S0    ## REDUNDANT ALERT!!
+
+
+
+    ## Note: The following lines assume that NZvec is an ordered vector.  Should check this here...
+
+    ## DIAGNOSTIC
+    #print " m = " + str(m) + "   p = " + str(p) 
+    #print " S0 = " + str(S0) + "   NZvec = " str(NZvec) "   IsDisjoint = " + str(IsDisjointOrdered(S0, NZvec))
+    #print " len(S0) = " + str(len(S0))
+
+
+    ## Make the form Qnew for the reduction procedure
+    if ((m % p == 0) and (len(Set(S0New).intersection(Set(NZvec))) == 0) and (len(S0New) != n)):
+        #print "Test 1.1 "
+        Qnew = deepcopy(self)
+        #Qnew = QuadraticForm(self.base_ring(), self.dim(), self.entries)
+
+
+        ## Run over all indices with i, while keeping track of the next index in S0 as S0[j].
+        j = 0       ## The index for following the increasing set (of indices) S0
+        for i in range(n):
+            ## Note: Short circuit && is necessary here:
+            if ((j < len(S0New)) and (i == S0New[j])):                 ## i is in S0
+                j += 1
+                Qnew[i,i] = p * Qnew[i,i] 
+                if ((p == 2) and (i < n)):
+                    Qnew[i+1,i] = p * Qnew[i+1,i] 
+                    Qnew[i,i+1] = p * Qnew[i,i+1] 
+            else:                             ## i not in S0;  Since S0 is increasing, we know i < S0(j)
+                Qnew[i,i] = Qnew[i,i] / p 
+
+                #print "  dividing in row " + str(i)
+
+                if ((p == 2) and (i < n-1)):
+                    Qnew[i+1,i] = Qnew[i+1,i] / p 
+                    Qnew[i,i+1] = Qnew[i,i+1] / p 
+
+        ## DIAGNOSTIC    
+        #print "\n\n Check of Bad-type I reduction: \n";
+        #print " Q is " + str(self) 
+        #print " Qnew is " + str(Qnew) 
+        #print " p = " + str(p) 
+        #print " m / p = " + str(m/p) 
+        #print " VectorComplement(Zvec, S0) is " + str(VectorComplement(Zvec, S0))       <------  FIX THIS!
+        #print " NZvec " << + str(NZvec)
+
+    
+        ## Do the reduction
+        ## (Need 2 steps since we can't take negative powers... =| )
+        VC = list(Set([i  for i in Zvec  if i not in S0New]))
+        if (len(S0New) > 1):
+            return QQ(1 / p**(len(S0New) - 1)) * Qnew.local_good_density_congruence(p, m / p, VC, NZvec)
+        else:
+            return QQ(p**(1 - len(S0New))) * Qnew.local_good_density_congruence(p, m / p, VC, NZvec)
+
+    else:
+        return 0
+
+
+
+def local_badII_density_congruence(self, p, m, Zvec, NZvec):
+    """
+    Finds the Bad-type II local density of Q representing m at p.
+    (Assuming that p > 2 and Q is given in local diagonal form.)
+
+    mpq_class Matrix_mpz::local_badII_density_congruence(const mpz_class & p, const mpz_class & m,
+                                        const valarray<size_t> & Zvec, const valarray<size_t> & NZvec) const
+    """
+    ## DIAGNOSTIC
+    #print " In local_badII_density_congruence with " 
+    #print " Q is: \n" + str(self) 
+    #print " p = " + str(p) 
+    #print " m = " + str(m) 
+    #print " Zvec = " + str(Zvec) 
+    #print " NZvec = " + str(NZvec) 
+
+
+    n = self.dim()
+
+    ## Define the indexing sets S_i
+    S0 = []
+    S1 = []
+    S2 = []
+
+    for i in range(n):
+
+        ## Compute the valuation of each index, allowing for off-diagonal terms
+        if (self[i,i] == 0):
+            if (i == 0):
+                val = valuation(self[i,i+1], p)    ## Look at the term to the right
+            elif (i == n-1):
+                val = valuation(self[i-1,i], p)    ## Look at the term above
+            else:
+                val = valuation(self[i,i+1] + self[i-1,i], p)    ## Finds the valuation of the off-diagonal term since only one isn't zero
+        else:
+            val = valuation(self[i,i], p)  
+
+        ## Sort the indices into disjoint sets by their valuation
+        if (val == 0):
+            S0 += [i]
+        elif (val == 1):
+            S1 += [i]
+        elif (val >= 2):
+            S2 += [i]
+
+
+
+    ## Check that the form is primitive...
+    if (S0 == []):
+        print " Using Q = " + str(self)
+        print " and p = " + str(p)
+        raise RuntimeError, "Oops! The form is not primitive!"
+
+
+    ## DIAGNOSTIC
+    #print "\n Entering BII routine " 
+    #print " S0 is " + str(S0) 
+    #print " S1 is " + str(S1) 
+    #print " S2 is " + str(S2) 
+
+
+
+    ## Note: The following lines assume that NZvec is an ordered vector.  Should check this here...
+
+    ## DIAGNOSTIC
+    #print " m = " + str(m) + "   p = " + str(p)
+    #print " S0 = " + str(S0) + "   NZvec = " str(NZvec) "   IsDisjoint = " + str(len(Set(S0 + S1).intersection(Set(NZvec))) == 0)
+    #print " len(S0) = " + str(len(S0))
+
+
+    p2 = p * p
+
+    ## Make the form Qnew for the reduction procedure
+    if ((m % (p2) == 0) and (S2 != []) and (len(Set(S0 + S1).intersection(Set(NZvec))) == 0)):   ##  <=====  CHECK THIS!!! ****  Should this be (S0 U S1) instead of S0 ???
+        #print "Test 1.1 "
+
+        Qnew = deepcopy(self)
+        #Qnew = QuadraticForm(self.base_ring(), self.dim(), self.entries)
+
+        ## Run over all indices with i, while keeping track of the next index in S2 as S2[j].
+        j = 0       ## The index for following the increasing set (of indices) S2
+        for i in range(n):
+            ## Note: Short circuit && is necessary here:
+            if ((j < len(S2)) and (i == S2[j])):                  ## i is in S2
+                j += 1
+                Qnew[i,i] = Qnew[i,i] / p2 
+                if ((p == 2) and (i < n-1)):
+                    Qnew[i+1,i] = Qnew[i+1,i] / p2
+                    Qnew[i,i+1] = Qnew[i,i+1] / p2
+
+        ## DIAGNOSTIC
+        #print "\n\n Check of Bad-type II reduction: \n";
+        #print " Q is " + str(self) 
+        #print " Qnew is " + str(Qnew) 
+
+
+        ## Do the reduction
+        ## (Need 2 steps for each case since we can't take negative powers... =| )
+        ## ------------------------------------------------------------------------
+        ##new_Zvec = VectorComplement(Zvec, list(Set(S0 + S1)))  
+        new_Zvec = list(Set([i  for i in Zvec  if i not in S0 + S1]))
+
+
+        ## DIAGNOSTIC
+        #print "  m = " << m << ",  m/p2 = " + str(m / p2) 
+        #print "  new_Zvec = " + str(new_Zvec) 
+        #print "  NZvec = " + str(NZvec) 
+        #print "  local_density_congruence(Qnew, p, m / p2, new_Zvec, NZvec) = " \
+        #   + str(local_density_congruence(Qnew, p, m / p2, new_Zvec, NZvec))
+        #print "  local_density_congruence(Qnew, p, m / p2, List(Set(S2 + new_Zvec)), NZvec)) = " \
+        #   + str(local_density_congruence(Qnew, p, m / p2, List(Set(S2 + new_Zvec)), NZvec))
+        #print "  count_local_type(Qnew, 2, 2, m=1, 0, trimZvec, trimNZvec) = " \
+        #   + str(count_local_type(Qnew, 2, 2, 1, 0, Zvec, NZvec)) 
+        #print "  count_local_type(Qnew, 2, 3, m=1, 0, trimZvec, trimNZvec) = " \
+        #   + str(count_local_type(Qnew, 2, 3, 1, 0, Zvec, NZvec))
+        #print "  count_local_type(Qnew, 2, 4, m=1, 0, trimZvec, trimNZvec) = " \
+        #   + str(count_local_type(Qnew, 2, 4, 1, 0, Zvec, NZvec))
+        #print "  count_local_type(Qnew, 2, 5, m=1, 0, trimZvec, trimNZvec) = " \
+        #   + str(count_local_type(Qnew, 2, 5, 1, 0, Zvec, NZvec))
+        #print "  count_local_type(Q, 2, 2, m=2, 0, trimZvec, trimNZvec) = " \
+        #   + str(count_local_type(Q, 2, 2, 2, 0, Zvec, NZvec))
+        #print "  count_local_type(Q, 2, 3, m=2, 0, trimZvec, trimNZvec) = " \
+        #   + str(count_local_type(Q, 2, 3, 2, 0, Zvec, NZvec))
+        #print "  count_local_type(Q, 2, 4, m=2, 0, trimZvec, trimNZvec) = " \
+        #   + str(count_local_type(Q, 2, 4, 2, 0, Zvec, NZvec))
+        #print "  count_local_type(Q, 2, 5, m=2, 0, trimZvec, trimNZvec) = " \
+        #   + str(count_local_type(Q, 2, 5, 2, 0, Zvec, NZvec))
+
+
+        if (n > len(S2) + 2):
+            return QQ(1 / p**(n - len(S2) - 2)) \
+                * (Qnew.local_density_congruence(p, m / p2, new_Zvec, NZvec) \
+                - Qnew.local_density_congruence(p, m / p2, List(Set(S2 + new_Zvec)), NZvec))
+        else:
+            return QQ(p**(len(S2) + 2 - n)) \
+                * (Qnew.local_density_congruence(p, m / p2, new_Zvec, NZvec) \
+                - Qnew.local_density_congruence(p, m / p2, List(Set(S2 + new_Zvec)), NZvec))
+
+    else:
+        return 0
+
+
+
+
+
+def local_bad_density_congruence(self, p, m, Zvec, NZvec):
+    """
+    Finds the Bad-type local density of Q representing
+    m at p, allowing certain congruence conditions mod p.
+    """
+    return self.local_badI_density_congruence(p, m, Zvec, NZvec) + self.local_badII_density_congruence(p, m, Zvec, NZvec)
+ 
+
+
+
+#########################################################
+## local_density and local_density_congruence routines ##
+#########################################################
+
+def local_density_congruence(self, p, m, Zvec, NZvec):
+    """
+    Finds the local density of Q representing m at p, 
+    allowing certain congruence conditions mod p.
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+        sage: Q.local_density_congruence(p=2, m=1, Zvec=[], NZvec=[])
+        1
+        sage: Q.local_density_congruence(p=3, m=1, Zvec=[], NZvec=[])
+        8/9
+        sage: Q.local_density_congruence(p=5, m=1, Zvec=[], NZvec=[])
+        24/25
+        sage: Q.local_density_congruence(p=7, m=1, Zvec=[], NZvec=[])
+        48/49
+        sage: Q.local_density_congruence(p=11, m=1, Zvec=[], NZvec=[])
+        120/121
+
+    """
+    return self.local_good_density_congruence(p, m, Zvec, NZvec) \
+                + self.local_zero_density_congruence(p, m, Zvec, NZvec) \
+                + self.local_bad_density_congruence(p, m, Zvec, NZvec)
+
+
+
+def local_primitive_density_congruence(self, p, m, Zvec, NZvec):
+    """
+    Finds the primitive local density of Q representing
+    m at p, allowing certain congruence conditions mod p.
+
+    Note: The following routine is not used internally, but is included for consistency.
+    """
+    return self.local_good_density_congruence(p, m, Zvec, NZvec) \
+                + self.local_bad_density_congruence(p, m, Zvec, NZvec)
+
+
diff --git a/sage/quadratic_forms/quadratic_form__local_density_interfaces.py b/sage/quadratic_forms/quadratic_form__local_density_interfaces.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__local_density_interfaces.py
@@ -0,0 +1,221 @@
+
+## // This is needed in the filter for primitivity...
+## #include "../max-min.h"
+
+from copy import deepcopy
+
+from sage.rings.arith import valuation
+from sage.rings.rational_field import QQ, RationalField
+
+
+#  ////////////////////////////////
+#  // Private Front-end Routines //
+#/////////////////////////////////////////////////////////////////////////////////////////////
+
+def local_good_density(self, p, m):
+    """
+    Finds the Good-type local density of Q representing m at p.  
+    (Front end routine for its congruence counterpart.)          
+    """
+    #print "Doing Good Density with p = " + str(p) +  " and m = " + str(m)
+    return self.local_good_density_congruence(p, m, [], [])
+
+
+def local_zero_density(self, p, m):
+    """
+    Finds the Zero-type local density of Q representing m at p.  
+    (Front end routine for its congruence counterpart.)          
+    """
+    #print "Doing Good Density with p = " + str(p) +  " and m = " + str(m)
+    return self.local_zero_density_congruence(p, m, [], [])
+
+
+def local_bad_density(self, p, m):
+    """
+    Finds the Bad-type local density of Q representing m at p.  
+    (Front end routine for its congruence counterpart.)          
+    """
+    #print "Doing Bad Density with p = " + str(p) +  " and m = " + str(m)
+    return self.local_bad_density_congruence(p, m, [], [])
+
+
+def local_badI_density(self, p, m):
+    """
+    Finds the Bad-type I local density of Q representing m at p.  
+    (Front end routine for its congruence counterpart.)          
+    """
+    #print "Doing Bad I Density with p = " + str(p) +  " and m = " + str(m)
+    return self.local_badI_density_congruence(p, m, [], [])
+
+
+def local_badII_density(self, p, m):
+    """
+    Finds the Bad-type II local density of Q representing m at p.  
+    (Front end routine for its congruence counterpart.)          
+    """
+    #print "Doing Bad II Density with p = " + str(p) +  " and m = " + str(m)
+    return self.local_badII_density_congruence(p, m, [], [])
+
+
+## ---------------  These are the important ones, which we'll filter for primitive forms!!!  ------------------
+
+
+### TODO:  THESE TWO ROUTINES HAVE **A LOT** OF CODE IN COMMON, BUT NEITHER PUTS THE FORM IN LOCAL NORMAL FORM FIRST!
+
+
+def local_density(self, p, m):
+    """
+    Gives the local density -- should be called by the user. =)
+
+    NOTE: This screens for imprimitive forms, but *doesn't* put the
+    quadratic form in local normal form, which is a *requirement* of
+    the routines performing the computations!
+
+    mpq_class Matrix_mpz::local_density(const mpz_class & p, const mpz_class & m) const {
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])   ## NOTE: This is already in local normal form for *all* primes p!
+        sage: Q.local_density(p=2, m=1)
+        1
+        sage: Q.local_density(p=3, m=1)
+        8/9
+        sage: Q.local_density(p=5, m=1)
+        24/25
+        sage: Q.local_density(p=7, m=1)
+        48/49
+        sage: Q.local_density(p=11, m=1)
+        120/121
+
+    """
+    n = self.dim()
+    if (n == 0):
+        raise TypeError, "Oops!  We currently don't handle 0-dim'l forms. =("
+
+
+    ## Set the modulus to check for imprimitive forms at p
+    no_val_flag = True
+
+    ## Check for imprimitive forms at p -- ASSUMES THE FORM IS UPPER TRIANGULAR! 
+    ## (NOTE: We could do better if we know it's normalized!)
+    for i in range(n):
+        for j in range(i, n):
+            if (self[i,j] != 0):
+                if (no_val_flag == True):
+                    no_val_flag = False
+                    p_valuation = valuation(self[i,j], p)
+                else:
+                    p_valuation = min(p_valuation, valuation(self[i,j], p))
+
+
+    ## DIAGNOSTIC
+    #cout << " Using the matrix: \n " << (*this) << endl;
+    #cout << "Valuation(m,p) = " << Valuation(m,p) << endl;
+    #cout << "p_valuation = " << p_valuation << endl;
+
+
+    ## If m is less p-divisible than the matrix, return zero  
+    if ((m != 0) and (valuation(m,p) < p_valuation)):   ## Note: The (m != 0) condition protects taking the valuation of zero.
+        return QQ(0)
+  
+    ## If the form is imprimitive, divide it (and m) by p-powers to get a primitive form
+    else:
+        if (p_valuation > 0):
+      
+            ## Make a new (primitive) matrix
+            Q1 = deepcopy(self)
+            #Q1 = QuadraticForm(self.base_ring(), self.dim())
+
+            ## DIAGNOSTIC
+            #print " p = " << p 
+            #print " p_valuation = " << p_valuation 
+            #print " p_mod = " << (p ** p_valuation) 
+      
+            p_mod = p ** p_valuation      ## This should give a power...
+            for i in range(n):
+                for j in range(i, n):
+                    Q1[i,j] = self[i,j] / p_mod
+      
+            ## Make a new number mm
+            mm = m / p_mod
+      
+            ## Then return the densities for the reduced problem
+            return Q1.local_good_density(p, mm) + Q1.local_zero_density(p, mm) + Q1.local_bad_density(p, mm)
+
+    
+        ## Otherwise, proceed as usual... =)
+        else:
+            return self.local_good_density(p, m) + self.local_zero_density(p, m) + self.local_bad_density(p, m)
+
+
+
+
+def local_primitive_density(self, p, m):
+    """
+    Gives the local primitive density -- should be called by the user. =)
+
+    NOTE: This screens for imprimitive forms, but *doesn't* put the
+    quadratic form in local normal form, which is a *requirement* of
+    the routines performing the computations!
+
+    mpq_class Matrix_mpz::local_density(const mpz_class & p, const mpz_class & m) const {
+    """
+
+    n = self.dim()
+    if (n == 0):
+        raise TypeError, "Oops!  We currently don't handle 0-dim'l forms. =("
+
+
+    ## Set the modulus to check for imprimitive forms at p
+    no_val_flag = True
+
+    ## Check for imprimitive forms at p -- ASSUMES THE FORM IS UPPER TRIANGULAR! 
+    ## (NOTE: We could do better if we know it's normalized!)
+    for i in range(n):
+        for j in range(i, n):
+            if (self[i,j] != 0):
+                if (no_val_flag == True):
+                    no_val_flag = False
+                    p_valuation = valuation(self[i,j], p)
+                else:
+                    p_valuation = min(p_valuation, valuation(self[i,j], p))
+
+
+    ## DIAGNOSTIC
+    #cout << " Using the matrix: \n " << (*this) << endl;
+    #cout << "Valuation(m,p) = " << Valuation(m,p) << endl;
+    #cout << "p_valuation = " << p_valuation << endl;
+
+
+    ## If m is less p-divisible than the matrix, return zero  
+    if ((m != 0) and (valuation(m,p) < p_valuation)):   ## Note: The (m != 0) condition protects taking the valuation of zero.
+        return QQ(0)
+  
+    ## If the form is imprimitive, divide it (and m) by p-powers to get a primitive form
+    else:
+        if (p_valuation > 0):
+      
+            ## Make a new (primitive) matrix
+            Q1 = deepcopy(self)  
+            #Q1 = QuadraticForm(self.base_ring(), self.dim())
+
+            ## DIAGNOSTIC
+            #print " p = " << p 
+            #print " p_valuation = " << p_valuation 
+            #print " p_mod = " << (p ** p_valuation) 
+      
+            p_mod = p ** p_valuation      ## This should give a power...
+            for i in range(n):
+                for j in range(i, n):
+                    Q1[i,j] = self[i,j] / p_mod
+      
+            ## Make a new number mm
+            mm = m / p_mod
+      
+            ## Then return the densities for the reduced problem
+            return Q1.local_good_density(p, mm) + Q1.local_bad_density(p, mm)
+
+    
+        ## Otherwise, proceed as usual... =)
+        else:
+            return self.local_good_density(p, m) + self.local_bad_density(p, m)
+
diff --git a/sage/quadratic_forms/quadratic_form__local_field_invariants.py b/sage/quadratic_forms/quadratic_form__local_field_invariants.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__local_field_invariants.py
@@ -0,0 +1,590 @@
+
+
+#*****************************************************************************
+#       Copyright (C) 2007 William Stein and Jonathan Hanke
+#
+#  Distributed under the terms of the GNU General Public License (GPL)
+#
+#    This code is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#    General Public License for more details.
+#
+#  The full text of the GPL is available at:
+#
+#                  http://www.gnu.org/licenses/
+#*****************************************************************************
+
+
+###########################################################################
+## TO DO: Add routines for hasse invariants at all places, anisotropic
+## places, is_semi_definite, and support for number fields.
+###########################################################################
+
+
+import copy
+
+from sage.rings.integer_ring import ZZ
+from sage.rings.rational_field import QQ
+from sage.rings.real_rqdf import RR
+from sage.rings.arith import prime_divisors, valuation, hilbert_symbol
+from sage.quadratic_forms.extras import IsPadicSquare, sgn
+from sage.rings.fraction_field import FractionField
+from sage.matrix.matrix_space import MatrixSpace
+from sage.rings.arith import GCD
+
+
+## Routines to compute local (p-adic) invariants of a quadratic form Q:
+## (Note: Here Q is the matrix so that Q(x) = x^t * Q * x.)
+## --------------------------------------------------------------------
+
+def rational_diagonal_form(self, return_matrix=False):
+    """
+    Returns a diagonal form equivalent to Q over the fraction field of
+    its defining ring.  If the return_matrix is True, then we return
+    the transformation matrix performing the diagonalization as the
+    second argument.
+
+    OUTPUT:
+        Q -- the diagonalized form of this quadratic form
+        (optional) T -- matrix which diagonalizes Q (over it's fraction field)
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+        sage: Q.rational_diagonal_form(return_matrix=True)
+        (Quadratic form in 4 variables over Rational Field with coefficients:
+        [ 1 0 0 0 ]
+        [ * 3 0 0 ]
+        [ * * 5 0 ]
+        [ * * * 7 ]
+        ,
+         [1 0 0 0]
+        [0 1 0 0]
+        [0 0 1 0]
+        [0 0 0 1])
+
+        sage: Q1 = QuadraticForm(ZZ, 4, [1, 1, 0, 0, 1, 0, 0, 1, 0, 18])
+        sage: Q1
+        Quadratic form in 4 variables over Integer Ring with coefficients:
+        [ 1 1 0 0 ]
+        [ * 1 0 0 ]
+        [ * * 1 0 ]
+        [ * * * 18 ]
+        sage: Q1.rational_diagonal_form(return_matrix=True)
+        (Quadratic form in 4 variables over Rational Field with coefficients:
+        [ 1 0 0 0 ]
+        [ * 3/4 0 0 ]
+        [ * * 1 0 ]
+        [ * * * 18 ]
+        ,
+         [   1 -1/2    0    0]
+        [   0    1    0    0]
+        [   0    0    1    0]
+        [   0    0    0    1])
+    """
+    n = self.dim()
+    Q = copy.deepcopy(self)
+    Q.__init__(FractionField(self.base_ring()), self.dim(), self.coefficients())
+    MS = MatrixSpace(Q.base_ring(), n, n)
+    T = MS(1)
+
+    ## Construct an integral change of basis matrix T 
+    ## so that T^t * Q * T is diagonal.
+
+    for i in range(n):
+        temp = MS(1)
+        for j in range(i+1, n):
+            temp[j,j] = 1
+            temp[i,j] = -Q[i,j] / ZZ(2) * Q[i,i]
+
+        Q = Q(temp)
+        T = temp * T
+
+    ## Return the appropriate output
+    if return_matrix:
+        return Q, T
+    else:
+        return Q
+
+
+def signature(self):
+    """
+    Returns the signature of the quadratic form, defined as:
+
+       number of positive eigenvalues - number of negative eigenvalues
+
+    of the matrix of the quadratic form.
+
+    OUTPUT:
+        an integer
+
+    EXAMPLES:
+    
+    """
+    diag = self.rational_diagonal_form()
+    return sum([sgn(diag[i,i])  for i in range(diag.dim())])
+
+
+
+def local_diagonal(self, p):
+    """
+    Finds a diagonal form equivalent to Q over the p-adic numbers Q_p. 
+
+    INPUT:
+    p -- prime number in ZZ
+
+    OUTPUT:
+    A quadratic form whose only non-zero entries are on the diagonal.
+
+    """
+    ## TODO: Check that  is a prime number
+
+    if (p != 2):
+        return self.local_normal_form(p)  ## This is a diagonal matrix for Q over Z_p. =)
+    else:
+        Q2 = self.local_normal_form(p)
+        for i in range(Q2.dim() - 1):
+            if (Q2[i, i+1] != 0):
+                ## This corresponds to [0 1]  =  [0  1/2]   ===>>>  [1  0]
+                ##                     [0 0]     [1/2  0]           [0 -1]
+                if (Q2[i,i] == 0):
+                    Q2[i, i] = Q2[i, i+1]
+                    Q2[i+1, i+1] = -Q2[i, i+1]
+                    Q2[i, i+1] = 0
+
+                ## This corresponds to [1 1]  =  [1  1/2]   ===>>>  [1 0]
+                ##                     [0 1]     [1/2  1]           [0 3]
+                else:
+                    Q2[i, i+1] = 0
+                    Q2[i+1, i+1] = Q2[i+1, i+1] * 3    
+
+    return Q2
+
+
+
+def hasse_invariant(self, p):
+    """
+    Computes the Hasse invariant at a prime p, as given on p55 of
+    Cassels book.  If Q is diagonal with coefficeints a_i, then the
+    (Cassels) Hasse invariant is given by
+
+        c_p = \prod_{i < j} (a_i, a_j)_p
+
+    where (a,b)_p is the Hilbert symbol at p.
+
+    WARNING: This is different from the O'Meara Hasse invariant, which
+    allows i <= j in the product.  That is given by the method
+    hasse_invariant__OMeara(p).
+
+    NOTE: We should really rename this hasse_invariant__Cassels(), and
+    set hasse_invariant() as a front-end to it.
+    """
+    ## TO DO: Need to deal with the case n=1 separately somewhere!
+
+    Diag = self.local_diagonal(p);
+
+    ## DIAGNOSTIC
+    #print "\n Q = " + str(self)
+    #print "\n Q diagonalized at p = " + str(p) + " gives " + str(Diag)
+
+    hasse_temp = 1
+    n = Diag.dim()
+
+    for j in range(n-1):
+        for k in range(j+1, n):
+            hasse_temp = hasse_temp * hilbert_symbol(Diag[j,j], Diag[k,k], p)
+
+    return hasse_temp
+
+
+def hasse_invariant__OMeara(self, p):
+    """
+    Computes the O'Meara Hasse invariant at a prime p, as given on
+    p167 of O'Meara's book.  If Q is diagonal with coefficeints a_i,
+    then the (Cassels) Hasse invariant is given by
+
+        c_p = \prod_{i <= j} (a_i, a_j)_p
+
+    where (a,b)_p is the Hilbert symbol at p.
+
+    WARNING: This is different from the (Cassels) Hasse invariant, which
+    only allows i < j in the product.  That is given by the method
+    hasse_invariant_OMeara(p)
+    """
+    ## TO DO: Need to deal with the case n=1 separately somewhere!
+
+    Diag = self.local_diagonal(p);
+
+    ## DIAGNOSTIC
+    #print "\n Q = " + str(self)
+    #print "\n Q diagonalized at p = " + str(p) + " gives " + str(Diag)
+
+    hasse_temp = 1
+    n = Diag.dim()
+
+    for j in range(n-1):
+        for k in range(j, n):
+            hasse_temp = hasse_temp * hilbert_symbol(Diag[j,j], Diag[k,k], p)
+
+    return hasse_temp
+
+
+
+
+def is_hyperbolic(self, p):
+    """
+    Checks if the quadratic form is a sum of hyperbolic planes over
+    the p-adic numbers Q_p.
+
+    REFERENCES:
+        This criteria follows from Cassels's "Rational Quadratic Forms":
+            - local invariants for hyperbolic plane (Lemma 2.4, p58)
+            - direct sum formulas (Lemma 2.3 on p58)
+
+    EXAMPLES:
+        sage: Q = QuadraticForm(ZZ, [1,1])
+        sage: Q.is_hyperbolic(2)
+        False
+
+        sage: Q.is_hyperbolic(3)
+        False
+
+        sage: Q.is_hyperbolic(5)     ## Here -1 is a square, so it's true.
+        True
+
+        sage: Q.is_hyperbolic(7)
+        False
+
+        sage: Q.is_hyperbolic(13)    ## Here -1 is a square, so it's true.
+        True
+
+    """
+    ## False for odd-dim'l forms
+    if self.dim() % 2 != 0:
+        return False
+
+    ## True for the zero form
+    if self.dim == 0:
+        return True
+
+    ## Compare local invariants 
+    ## (Note: since the dimension is even, the extra powers of 2 in 
+    ##        self.det() := Det(2*Q) don't affect the answer!) 
+    m = ZZ(self.dim() / 2) 
+    return IsPadicSquare(self.det() * (-1)**m, p) and (self.hasse_invariant(p) == (-1)**m)
+
+
+
+def is_anisotropic(self, p):
+    """
+    Checks if the quadratic form is anisotropic over the p-adic numbers Q_p. 
+    """ 
+    n = self.dim()
+    D = self.det()
+
+    ## TO DO: Should check that p is prime
+
+    if (n >= 5):
+        return False;
+
+    if (n == 4):
+        return (IsPadicSquare(D, p) and (self.hasse_invariant(p) == - hilbert_symbol(-1,-1,p)) )
+
+    if (n == 3):
+        return (self.hasse_invariant(p) != hilbert_symbol(-1, -D, p))
+
+    if (n == 2):
+        return (not IsPadicSquare(-D, p))
+
+    if (n == 1):
+        return (self[0,0] != 0)
+
+    raise NotImplementedError, "Oops!  We haven't established a convention for 0-dim'l quadratic forms... =(" 
+
+
+def is_isotropic(self, p):
+    """
+    Checks if Q is isotropic over the p-adic numbers Q_p. 
+    """
+    return not self.is_anisotropic(p)
+
+
+def anisotropic_primes(self):
+    """
+    Returns a list with all of the anisotropic primes of the quadratic form.
+
+
+    INPUT:
+        None
+
+    OUTPUT:
+        Returns a list of prime numbers >0.
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1])
+        sage: Q.anisotropic_primes()
+        [2]
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+        sage: Q.anisotropic_primes()
+        [2]
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1,1])
+        sage: Q.anisotropic_primes()
+        []
+    """
+
+    ## Look at all prime divisors of 2 * Det(Q) to find the anisotropic primes...
+    possible_primes = prime_divisors(2 * self.det())
+    AnisoPrimes = []
+
+    ## DIAGNSOTIC
+    #print " Possible anisotropic primes are: " + str(possible_primes)
+
+    for p in possible_primes:
+        if (self.is_anisotropic(p)):
+            AnisoPrimes += [p]
+
+    ## DIAGNSOTIC
+    #print " leaving anisotropic_primes..." 
+
+    return AnisoPrimes
+
+
+def compute_definiteness(self):
+    """
+    Computes whether the given quadratic form is positive-definite,
+    negative-definite, indefinite, degenerate, or the zero form.
+
+    This caches one of the following strings in self.__definiteness_string:
+    "pos_def", "neg_def", "indef", "zero", "degenerate".  It is called
+    from all routines like:
+
+        is_positive_definite(), is_negative_definite(), is_indefinite(), etc.
+
+    Note:  A degenerate form is considered neither definite nor indefinite.
+    Note:  The zero-dim'l form is considered both positive definite and negative definite.
+
+    INPUT:
+        None
+
+    OUTPUT:
+        None
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1,1])
+        sage: Q.is_positive_definite()
+        True
+        sage: Q.is_negative_definite()
+        False
+        sage: Q.is_indefinite()
+        False
+        sage: Q.is_definite()
+        True
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [])
+        sage: Q.is_positive_definite()
+        True
+        sage: Q.is_negative_definite()
+        True
+        sage: Q.is_indefinite()
+        False
+        sage: Q.is_definite()
+        True
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,0,-1])
+        sage: Q.is_positive_definite()
+        False
+        sage: Q.is_negative_definite()
+        False
+        sage: Q.is_indefinite()
+        False
+        sage: Q.is_definite()
+        False
+
+    """
+    ## Sanity Check
+    if not ((self.base_ring() == ZZ) or (self.base_ring() == QQ) or (self.base_ring() == RR)):
+        raise NotImplementedError, "Oops!  We can only check definiteness over ZZ, QQ, and RR for now." 
+    
+    ## Some useful variables
+    n = self.dim()
+    M = self.matrix()
+
+
+    ## Deal with the zero-diml form
+    if n == 0:
+        self.__definiteness_string = "zero"
+        return
+
+    ## Deal with degernerate forms
+    if self.det() == 0:
+        self.__definiteness_string = "degenerate"
+        return
+   
+
+    ## Check the sign of the ratios of consecutive determinants of the upper triangular r x r submatrices
+    ul = self[0,0]
+    subdet_list = [ul]
+    for r in range(1,n):
+        I = range(r+1)
+        new_det = M.matrix_from_rows_and_columns(I, I).det()
+
+        ## Sanity Check for degenerateness
+        if new_det == 0:
+            raise RuntimeError, "This shouldn't happen, since degernerate forms are not allowed at this point."
+
+        ## Check for indefiniteness
+        subdet_list.append(new_det)
+        if not ((subdet_list[-1] / subdet_list[-2]) * ul > 0):
+            self.__definiteness_string = "indefinite"
+            return
+        
+    ## Here all ratios of determinants have the correct sign, so the matrix is (pos or neg) definite.
+    if ul > 0:
+        self.__definiteness_string = "pos_def"
+    else:
+        self.__definiteness_string = "neg_def"
+
+
+
+
+def is_positive_definite(self):
+    """
+    Determines if the given quadratic form is positive-definite.
+
+    Note:  A degenerate form is considered neither definite nor indefinite.
+    Note:  The zero-dim'l form is considered both positive definite and negative definite.
+
+    INPUT:
+        None
+
+    OUTPUT:
+        boolean -- True or False
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,3,5])
+        sage: Q.is_positive_definite()
+        True
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,-3,5])
+        sage: Q.is_positive_definite()
+        False
+    
+    """
+    ## Try to use the cached value
+    try:
+        def_str = self.__definiteness_string
+    except:
+        self.compute_definiteness()
+        def_str = self.__definiteness_string
+
+    ## Return the answer
+    return (def_str == "pos_def") or (def_str == "zero")
+
+
+
+
+def is_negative_definite(self):
+    """
+    Determines if the given quadratic form is negative-definite.
+
+    Note:  A degenerate form is considered neither definite nor indefinite.
+    Note:  The zero-dim'l form is considered both positive definite and negative definite.
+
+    INPUT:
+        None
+
+    OUTPUT:
+        boolean -- True or False
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [-1,-3,-5])
+        sage: Q.is_negative_definite()
+        True
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,-3,5])
+        sage: Q.is_negative_definite()
+        False
+    
+    """
+    ## Try to use the cached value
+    try:
+        def_str = self.__definiteness_string
+    except:
+        self.compute_definiteness()
+        def_str = self.__definiteness_string
+
+    ## Return the answer
+    return (def_str == "neg_def") or (def_str == "zero")
+
+
+
+def is_indefinite(self):
+    """
+    Determines if the given quadratic form is indefinite.
+
+    Note:  A degenerate form is considered neither definite nor indefinite.
+    Note:  The zero-dim'l form is not considered indefinite.
+
+    INPUT:
+        None
+
+    OUTPUT:
+        boolean -- True or False
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [-1,-3,-5])
+        sage: Q.is_indefinite()
+        False
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,-3,5])
+        sage: Q.is_indefinite()
+        True
+    
+    """
+    ## Try to use the cached value
+    try:
+        def_str = self.__definiteness_string
+    except:
+        self.compute_definiteness()
+        def_str = self.__definiteness_string
+
+    ## Return the answer
+    return def_str == "indef"
+
+
+def is_definite(self):
+    """
+    Determines if the given quadratic form is (positive or negative) definite.
+
+    Note:  A degenerate form is considered neither definite nor indefinite.
+    Note:  The zero-dim'l form is considered indefinite.
+
+    INPUT:
+        None
+
+    OUTPUT:
+        boolean -- True or False
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [-1,-3,-5])
+        sage: Q.is_indefinite()
+        False
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,-3,5])
+        sage: Q.is_indefinite()
+        True
+    
+    """
+    ## Try to use the cached value
+    try:
+        def_str = self.__definiteness_string
+    except:
+        self.compute_definiteness()
+        def_str = self.__definiteness_string
+
+    ## Return the answer
+    return (def_str == "pos_def") or (def_str == "neg_def") or (def_str == "zero")
+
+
diff --git a/sage/quadratic_forms/quadratic_form__local_normal_form.py b/sage/quadratic_forms/quadratic_form__local_normal_form.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__local_normal_form.py
@@ -0,0 +1,434 @@
+#*****************************************************************************
+#       Copyright (C) 2007 William Stein and Jonathan Hanke
+#
+#  Distributed under the terms of the GNU General Public License (GPL)
+#
+#    This code is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#    General Public License for more details.
+#
+#  The full text of the GPL is available at:
+#
+#                  http://www.gnu.org/licenses/
+#*****************************************************************************
+
+import copy
+from sage.rings.infinity import Infinity
+from sage.rings.integer_ring import IntegerRing, ZZ
+from sage.rings.rational_field import QQ
+from sage.rings.arith import GCD, valuation, is_prime
+
+
+#from sage.misc.functional import ideal          ## TODO: This can probably be removed!
+
+
+
+def find_entry_with_minimal_scale_at_prime(self, p):
+    """
+    Finds the entry of the quadratic form with minimal scale at the
+    prime p, preferring diagonal entries in case of a tie.  (I.e.  If
+    we write the quadratic form as a symmetric matrix M, then this
+    entry M[i,j] has the minimal valuation at the prime p.)
+
+    Note: This answer is independent of the kind of matrix (Gram or
+    Hessian) associated to the form.
+    """
+    n = self.dim()
+    min_val = Infinity
+    ij_index = None
+    val_2 = valuation(2, p)
+    for d in range(n):           ## d = difference j-i
+        for e in range(n - d):    ## e is the length of the diagonal with value d.
+
+            ## Compute the valuation of the entry
+            if d == 0:
+                tmp_val = valuation(self[e, e+d], p)
+            else:
+                tmp_val = valuation(self[e, e+d], p) - val_2
+
+            ## Check if it's any smaller than what we have
+            if tmp_val < min_val:
+                ij_index = (e,e+d)    
+                min_val = tmp_val
+
+    ## Return the result
+    return ij_index
+
+
+
+
+def local_normal_form(self, p):
+    """
+    Returns the a locally integrally equivalent quadratic form over
+    the p-adic integers Z_p which gives the Jordan decomposition.  The
+    Jordan components are written as sums of blocks of size <= 2 and
+    are arranged by increasing scale, and then by increasing norm.
+    (This is equivalent to saying that we put the 1x1 blocks before
+    the 2x2 blocks in each Jordan component.)
+
+    INPUT:
+        p -- a positive prime number.
+    
+    WARNING:  Currently this only works for quadratic forms defined over ZZ.
+    
+    EXAMPLES:
+        sage: Q = QuadraticForm(ZZ, 2, [10,4,1])
+        sage: Q.local_normal_form(5)
+        Quadratic form in 2 variables over Integer Ring with coefficients: 
+        [ 1 0 ]
+        [ * 6 ]
+    
+        sage: Q.local_normal_form(3)
+        Quadratic form in 2 variables over Integer Ring with coefficients: 
+        [ 10 0 ]
+        [ * 15 ]
+    
+        sage: Q.local_normal_form(2)
+        Quadratic form in 2 variables over Integer Ring with coefficients: 
+        [ 1 0 ]
+        [ * 6 ]
+    
+    """
+    ## Sanity Checks
+    if (self.base_ring() != IntegerRing()):
+        raise NotImplementedError, "Oops!  This currently only works for quadratic forms defined over IntegerRing(). =("
+    if not ((p>=2) and is_prime(p)):
+        raise TypeError, "Oops!  p is not a positive prime number. =("
+
+    ## Some useful local variables
+    Q = copy.deepcopy(self)
+    Q.__init__(self.base_ring(), self.dim(), self.coefficients())
+
+    ## Prepare the final form to return
+    Q_Jordan = copy.deepcopy(self)
+    Q_Jordan.__init__(self.base_ring(), 0)
+
+    
+    while Q.dim() > 0:
+        n = Q.dim()
+
+        ## Step 1: Find the minimally p-divisible matrix entry, preferring diagonals
+        ## -------------------------------------------------------------------------
+        (min_i, min_j) = Q.find_entry_with_minimal_scale_at_prime(p)
+        if min_i == min_j:
+            min_val = valuation(2 * Q[min_i, min_j], p)
+        else:
+            min_val = valuation(Q[min_i, min_j], p)
+
+        ## Error if we still haven't seen non-zero coefficients!
+        if (min_val == Infinity):
+            raise RuntimeError, "Oops!  The original matrix is degenerate. =("
+
+      
+        ## Step 2: Arrange for the upper leftmost entry to have minimal valuation
+        ## ----------------------------------------------------------------------
+        if (min_i == min_j):
+            block_size = 1
+            Q.swap_variables(0, min_i, in_place = True)
+        else:
+            ## Work in the upper-left 2x2 block, and replace it by its 2-adic equivalent form  
+            Q.swap_variables(0, min_i, in_place = True)
+            Q.swap_variables(1, min_j, in_place = True)
+
+            ## 1x1 => make upper left the smallest
+            if (p != 2):
+                block_size = 1;
+                Q.add_symmetric(1, 0, 1, in_place = True)   
+            ## 2x2 => replace it with the appropriate 2x2 matrix
+            else: 
+                block_size = 2
+
+        ## DIAGNOSTIC
+        #print "\n Finished Step 2 \n";
+        #print "\n Q is: \n" + str(Q)  + "\n";
+        #print "  p is: " + str(p) 
+        #print "  min_val is: " + str( min_val)
+        #print "  block_size is: " + str(block_size)
+        #print "\n Starting Step 3 \n"
+
+        ## Step 3: Clear out the remaining entries
+        ##  ---------------------------------------
+        min_scale = p ** min_val                             ## This is the minimal valuation of the Hessian matrix entries.
+
+        ##DIAGNOSTIC
+        #print "Starting Step 3:"
+        #print "----------------"
+        #print "  min_scale is: " + str(min_scale)
+
+
+        ## Perform cancellation over Z by ensuring divisibility
+        if (block_size == 1):
+            a = 2 * Q[0,0]
+            for j in range(block_size, n):
+                b = Q[0, j]
+                g = GCD(a, b)
+
+                ## DIAGNSOTIC
+                #print "Cancelling from a 1x1 block:"
+                #print "----------------------------"
+                #print "  Cancelling entry with index (" + str(upper_left) + ", " + str(j) + ")"
+                #print "  entry = " + str(b)
+                #print "  gcd = " + str(g)
+                #print "  a = " + str(a)
+                #print "  b = " + str(b)
+                #print "  a/g = " + str(a/g) + "   (used for stretching)"
+                #print "  -b/g = " + str(-b/g) + "   (used for cancelling)"
+                
+                ## Sanity Check:  a/g is a p-unit
+                if valuation (g, p) != valuation(a, p):
+                    raise RuntimeError, "Oops!  We have a problem with our rescaling not preserving p-integrality!"
+
+                Q.multiply_variable(ZZ(a/g), j, in_place = True)   ## Ensures that the new b entry is divisible by a
+                Q.add_symmetric(ZZ(-b/g), j, 0, in_place = True)  ## Performs the cancellation
+
+
+        elif (block_size == 2):
+            a1 = 2 * Q[0,0]
+            a2 = Q[0, 1]
+            b1 = Q[1, 0]      ## This is the same as a2
+            b2 = 2 * Q[1, 1]
+
+            big_det = (a1*b2 - a2*b1) 
+            small_det = big_det / (min_scale * min_scale)  
+
+            ## Cancels out the rows/columns of the 2x2 block
+            for j in range(block_size, n):
+                a = Q[0, j]
+                b = Q[1, j]
+           
+                ## Ensures an integral result (scale jth row/column by big_det)
+                Q.multiply_variable(big_det, j, in_place = True)  
+           
+                ## Performs the cancellation (by producing -big_det * jth row/column)
+                Q.add_symmetric(ZZ(-(a*b2 - b*a2)), j, 0, in_place = True)  
+                Q.add_symmetric(ZZ(-(-a*b1 + b*a1)), j, 1, in_place = True)  
+
+                ## Now remove the extra factor (non p-unit factor) in big_det we introduced above
+                Q.divide_variable(ZZ(min_scale * min_scale), j, in_place = True)  
+
+            ## DIAGNOSTIC
+            #print "Cancelling out a 2x2 block:"
+            #print "---------------------------"
+            #print "  a1 = " + str(a1)
+            #print "  a2 = " + str(a2)
+            #print "  b1 = " + str(b1)
+            #print "  b2 = " + str(b2)
+            #print "  big_det = " + str(big_det)
+            #print "  min_scale = " + str(min_scale)            
+            #print "  small_det = " + str(small_det)            
+            #print "  Q = \n", Q            
+
+            ## Uses Cassels's proof to replace the remaining 2 x 2 block
+            if (((1 + small_det) % 8) == 0):
+                Q[0, 0] = 0
+                Q[1, 1] = 0
+                Q[0, 1] = min_scale
+            elif (((5 + small_det) % 8) == 0):
+                Q[0, 0] = min_scale
+                Q[1, 1] = min_scale
+                Q[0, 1] = min_scale
+            else:
+                raise RuntimeError, "Error in LocalNormal: Impossible behavior for a 2x2 block! \n"
+
+
+        ## Check that the cancellation worked, extract the upper-left block, and trim Q to handle the next block.
+        for i in range(block_size):
+            for j in range(block_size, n):
+                if Q[i,j] != 0:
+                    raise RuntimeError, "Oops!  The cancellation didn't work properly at entry (" + str(i) + ", " + str(j) + ")."
+        Q_Jordan = Q_Jordan + Q.extract_variables(range(block_size))
+        Q = Q.extract_variables(range(block_size, n))
+
+    return Q_Jordan
+
+
+
+
+def jordan_blocks_by_scale_and_unimodular(self, p, safe_flag=True):
+    """
+    Returns a list of pairs (s_i, L_i) where L_i is a maximal
+    p^(s_i)-unimodular Jordan component which is further
+    decomposed into block diagonals of block size <= 2.  For each
+    L_i the 2x2 blocks are listed after the 1x1 blocks (which
+    follows from the convention of the local_normal_form method).
+
+    Note: The decomposition of each L_i into smaller block is not
+        unique!
+
+    The safe_flag allows us to select whether we want a copy of the
+    output, or the original output.  By default safe_flag = True, so
+    we return a copy of the cached information.  If this is set to
+    False, then the routine is much faster but the return values are
+    vulnerable to being corrupted by the user. 
+
+
+    INPUT:
+        p -- a prime number > 0.
+
+    OUTPUT:
+        A list of pairs (s_i, L_i) where: 
+        s_i is an integer, 
+            L_i is a block-diagonal unimodular quadratic form over Z_p.
+        Note: These forms L_i are defined over the p-adic intgers,
+        but by a matrix over ZZ (or QQ?).
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,9,5,7])
+        sage: Q.jordan_blocks_by_scale_and_unimodular(3)
+        [(0,
+          Quadratic form in 3 variables over Integer Ring with coefficients: 
+          [ 1 0 0 ]
+          [ * 5 0 ]
+          [ * * 7 ]
+          ),
+           (2,
+            Quadratic form in 1 variables over Integer Ring with coefficients: 
+          [ 1 ]
+          )]
+
+
+        sage: Q2 = QuadraticForm(ZZ, 2, [1,1,1])
+        sage: Q = Q2 + Q2.scale_by_factor(2)
+        sage: Q.jordan_blocks_by_scale_and_unimodular(2)
+        [(-1,
+          Quadratic form in 2 variables over Integer Ring with coefficients:
+        [ 2 2 ]
+        [ * 2 ]
+        ),
+         (0,
+          Quadratic form in 2 variables over Integer Ring with coefficients:
+        [ 2 2 ]
+        [ * 2 ]
+        )]
+
+    """
+    ## Try to use the cached result
+    try:
+        if safe_flag:
+            return deepcopy(self.__jordan_blocks_by_scale_and_unimodular_dict[p])
+        else:
+            return self.__jordan_blocks_by_scale_and_unimodular_dict[p]
+    except:
+        ## Initialize the global dictionary if it doesn't exist
+        if not hasattr(self, '__jordan_blocks_by_scale_and_unimodular_dict'):
+            self.__jordan_blocks_by_scale_and_unimodular_dict = {}
+
+
+    ## Deal with zero dim'l forms
+    if self.dim() == 0:
+        return []
+
+
+    ## Find the Local Normal form of Q at p
+    Q1 = self.local_normal_form(p)
+
+
+    ## Parse this into Jordan Blocks
+    n = Q1.dim()
+    tmp_Jordan_list = []
+    i = 0
+    start_ind = 0
+    if (n >= 2) and (Q1[0,1] != 0):
+        start_scale = valuation(Q1[0,1], p) - 1
+    else:
+        start_scale = valuation(Q1[0,0], p)    
+
+    while (i < n):
+
+        ## Determine the size of the current block
+        if (i == n-1) or (Q1[i,i+1] == 0):
+            block_size = 1
+        else: 
+            block_size = 2
+
+        ## Determine the valuation of the current block
+        if block_size == 1:
+            block_scale = valuation(Q1[i,i], p)
+        else:
+            block_scale = valuation(Q1[i,i+1], p) - 1
+
+        ## Process the previous block if the valuation increased    
+        if block_scale > start_scale:
+            tmp_Jordan_list += [(start_scale, Q1.extract_variables(range(start_ind, i)).scale_by_factor(ZZ(1) / (QQ(p)**(start_scale))))]
+            start_ind = i
+            start_scale = block_scale
+
+        ## Increment the index
+        i += block_size
+
+    ## Add the last block
+    tmp_Jordan_list += [(start_scale, Q1.extract_variables(range(start_ind, n)).scale_by_factor(1/ZZ(p**(start_scale))))]
+
+
+    ## Cache the result
+    self.__jordan_blocks_by_scale_and_unimodular_dict[p] = tmp_Jordan_list
+
+    ## Return the result
+    return tmp_Jordan_list
+
+
+
+
+def jordan_blocks_in_unimodular_list_by_scale_power(self, p):
+    """
+    Returns a list of Jordan components, whose component at index i
+    should be scaled by the factor p^i.
+
+    This is only defined for integer-valued quadratic forms
+    (i.e. forms with base_ring ZZ), and the indexing only works
+    correctly for p=2 when the form has an integer Gram matrix.
+
+    INPUT:
+        self -- a quadratic form over ZZ, which has integer Gram matrix if p == 2
+        p -- a prime number > 0
+
+    OUTPUT:
+        a list of p-unimodular quadratic forms 
+
+    EXAMPLES:
+        sage: Q = QuadraticForm(ZZ, 3, [2, -2, 0, 3, -5, 4])
+        sage: Q.jordan_blocks_in_unimodular_list_by_scale_power(2)
+        [Quadratic form in 2 variables over Integer Ring with coefficients:
+        [ 3 0 ]
+        [ * 15 ]
+        ,
+         Quadratic form in 1 variables over Integer Ring with coefficients:
+        [ 27 ]
+        ]
+
+        sage: Q.jordan_blocks_in_unimodular_list_by_scale_power(3)
+        [Quadratic form in 2 variables over Integer Ring with coefficients:
+        [ 2 0 ]
+        [ * 10 ]
+        ,
+         Quadratic form in 1 variables over Integer Ring with coefficients:
+        [ 2 ]
+        ]
+
+    """
+    ## Sanity Check
+    if self.base_ring() != ZZ:
+        raise TypeError, "Oops!  This method only makes sense for integer-valued quadratic forms (i.e. defined over ZZ)."
+
+    ## Deal with zero dim'l forms
+    if self.dim() == 0:
+        return []
+
+    ## Find the Jordan Decomposition
+    list_of_jordan_pairs = self.jordan_blocks_by_scale_and_unimodular(p)
+    scale_list =  [P[0] for P in list_of_jordan_pairs]
+    s_max = max(scale_list)
+    if min(scale_list) < 0:
+        raise TypeError, "Oops!  The given quadratic form has a Jordan component with a negative scale exponent!\n" \
+        + "This routine requires an integer-matrix quadratic form for the output indexing to work properly!"
+
+    ## Make the new list of unimodular Jordan components
+    zero_form = self.deepcopy()
+    zero_form.__init__(ZZ, 0)
+    list_by_scale = [zero_form  for _ in range(s_max+1)]
+    for P in  list_of_jordan_pairs:
+        list_by_scale[P[0]] = P[1]
+
+    ## Return the new list
+    return list_by_scale
diff --git a/sage/quadratic_forms/quadratic_form__local_representation_conditions.py b/sage/quadratic_forms/quadratic_form__local_representation_conditions.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__local_representation_conditions.py
@@ -0,0 +1,615 @@
+
+#########################################################################
+## Class for keping track of the local conditions for representability ##
+## of numbers by a quadratic form over ZZ (and eventually QQ also).    ##
+#########################################################################
+
+from copy import deepcopy
+
+from sage.rings.integer_ring import IntegerRing, ZZ
+from sage.rings.arith import prime_divisors, valuation, is_square
+from sage.quadratic_forms.extras import quadratic_nonresidue, IsPadicSquare
+from sage.rings.infinity import infinity
+from sage.misc.functional import numerator, denominator
+from sage.rings.rational_field import QQ
+
+class QuadraticFormLocalRepresentationConditions():
+    """
+    Creates a class for dealing with the local conditions of a
+    quadratic form, and checking local representability of numbers.
+
+    EXAMPLES:
+        sage: Q4 = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+        sage: Q4.local_representation_conditions()
+        This form represents the p-adic integers Z_p for all primes p except 
+        [].  For these and the reals, we have:
+             Reals:   [0, +Infinity]
+        sage: Q4.is_locally_represented_number(1)
+        True
+        sage: Q4.is_locally_universal_at_all_primes()
+        True
+        sage: Q4.is_locally_universal_at_all_places()
+        False
+        sage: L = [m  for m in range(-5, 100)  if Q4.is_locally_represented_number(m)]
+        sage: L == range(100)
+        True
+
+        sage: Q3 = DiagonalQuadraticForm(ZZ, [1,1,1])
+        sage: Q3.local_representation_conditions()
+        This form represents the p-adic integers Z_p for all primes p except 
+        [2].  For these and the reals, we have:
+             Reals:   [0, +Infinity]
+             p = 2:   [0, 0, 0, +Infinity, 0, 0, 0, 0]
+        sage: E = [m  for m in range(100)  if not Q3.is_locally_represented_number(m)]
+        sage: E1 = [m  for m in range(100)  if m / 2**(2*floor(valuation(m,2)/2)) % 8 == 7]
+        sage: E == E1
+        True
+        sage: E
+        [7, 15, 23, 28, 31, 39, 47, 55, 60, 63, 71, 79, 87, 92, 95]
+
+        sage: Q2 = DiagonalQuadraticForm(ZZ, [1,1])
+        sage: Q2.local_representation_conditions()
+        This 2-dimensional form represents the p-adic integers of even
+        valuation for all primes p except [2].
+        For these and the reals, we have:
+             Reals:   [0, +Infinity]
+             p = 2:   [0, +Infinity, 0, +Infinity, 0, +Infinity, 0, +Infinity]
+        sage: Q2.is_locally_universal_at_all_places()
+        False
+        sage: Q2.is_locally_universal_at_all_primes()
+        False
+        sage: L = [m  for m in range(-5, 25)  if Q2.is_locally_represented_number(m)]
+        sage: L1 = [0] + [m  for m in range(1,25)  \ 
+              if len([p  for p in prime_factors(squarefree_part(ZZ(m)))  if (p % 4) == 3]) % 2 == 0]
+        sage: L == L1
+        True
+        sage: L
+        [0, 1, 2, 4, 5, 8, 9, 10, 13, 16, 17, 18, 20, 21]
+
+        sage: Q1 = DiagonalQuadraticForm(ZZ, [1])
+        sage: Q1.local_representation_conditions()
+        This 1-dimensional form only represents square multiples of 1.
+        sage: L = [m  for m in range(100)  if Q1.is_locally_represented_number(m)]
+        sage: L
+        [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
+
+        sage: Q0 = DiagonalQuadraticForm(ZZ, [])
+        sage: Q0.local_representation_conditions()
+        This 0-dimensional form only represents zero.
+        sage: L = [m  for m in range(100)  if Q0.is_locally_represented_number(m)]
+        sage: L
+        [0]
+    """
+
+    def __init__(self, Q):
+        """
+        Takes a QuadraticForm and computes its local conditions (if
+        they don't already exist).  The recompute_flag overrides the
+        previously computed conditions if they exist, and stores the
+        new conditions.
+        """
+
+        ## Check that the form Q is integer-valued (we can relax this later)
+        if Q.base_ring() != ZZ:
+            raise TypeError, "We require that the quadratic form be defined over ZZ (integer-values) for now."
+
+
+        ## Basic structure initialization
+        self.local_repn_array = []    ## List of all local conditions
+        self.dim = Q.dim()       ## We allow this to be any non-negative integer.
+        self.exceptional_primes = [infinity]
+
+        ## Deal with the special cases of 0 and 1-dimensional forms
+        if self.dim == 0:
+            self.coeff = None
+            return 
+        elif self.dim == 1:
+            self.coeff = Q[0,0]
+            return
+        else:
+            self.coeff = None
+
+
+        ## Compute the local conditions at the real numbers (i.e. "p = infinity")
+        ## ----------------------------------------------------------------------
+        M = Q.matrix()
+        E = M.eigenspaces()
+        M_eigenvalues = [E[i][0]  for i in range(len(E))]
+
+        pos_flag = infinity
+        neg_flag = infinity
+        
+        for e in M_eigenvalues:
+            if e > 0:
+                pos_flag = 0
+            elif e < 0:
+                neg_flag = 0
+
+        real_vec = [infinity, pos_flag, neg_flag, None, None, None, None, None, None]
+        self.local_repn_array.append(real_vec)        
+
+    
+        ## Compute the local conditions for representability:
+        ## --------------------------------------------------
+        N = Q.level()
+        level_primes = prime_divisors(N)
+        prime_repn_modulus_list = [p**(valuation(4*N, p) + 2)  for p in level_primes]
+        
+        ## Make a table of local normal forms for each p | N
+        local_normal_forms = [Q.local_normal_form(p)  for p in level_primes]
+        
+        ## Check local representability conditions for each prime
+        for i in range(len(level_primes)):
+            p = level_primes[i]
+            tmp_local_repn_vec = [p, None, None, None, None, None, None, None, None]
+            sqclass = self.squareclass_vector(p)
+
+            ## Check the representability in each Z_p squareclass
+            for j in range(len(sqclass)):
+                m = sqclass[j]
+                k = 0
+                repn_flag = False
+
+                while ((repn_flag == False) and (m < 4 * N * p * p)):
+                    if (local_normal_forms[i].local_density(p, m) > 0):
+                        tmp_local_repn_vec[j+1] = k
+                        repn_flag = True
+                    k = k + 1
+                    m = m * p * p
+            
+                ## If we're not represented, write "infinity" to signify
+                ## that this squareclass is fuly obstructed
+                if (repn_flag == False):
+                    tmp_local_repn_vec[j+1] = infinity
+
+            ## Test if the conditions at p give exactly Z_p when dim >=3, or
+            ## if we represent the elements of even valuation >= 2 when dim = 2.
+            omit_flag = True
+            if self.dim >= 2:
+                ## Check that all entries are zero or 'None'
+                for x in tmp_local_repn_vec[1:]:
+                    if not ((x == 0) or (x == None)):
+                        omit_flag = False
+
+            ## Add the results for this prime if there is a congruence obstruction
+            if omit_flag == False:
+                self.local_repn_array.append(tmp_local_repn_vec)
+                self.exceptional_primes.append(p)
+
+
+    def __repr__(self):
+        """
+        Print the local conditions.
+
+        TO DO:  Improve the output for the real numbers, and special output for locally unversality. 
+        Also give names to the squareclasses, so it's clear what the output means! =)
+        """
+        if self.dim == 0:
+            out_str = "This 0-dimensional form only represents zero."
+        elif self.dim == 1:
+            out_str = "This 1-dimensional form only represents square multiples of " + str(self.coeff) + "."
+        elif self.dim == 2:
+            out_str = "This 2-dimensional form represents the p-adic integers of even\n"
+            out_str += "valuation for all primes p except " + str(self.exceptional_primes[1:]) + ".\n"
+            out_str += "For these and the reals, we have:\n"
+        else:
+            out_str = "This form represents the p-adic integers Z_p for all primes p except \n"
+            out_str += str(self.exceptional_primes[1:]) + ".  For these and the reals, we have:\n"
+
+        for v in self.local_repn_array:
+            if v[0] == infinity:
+                out_str += "     " + "Reals:   " + str(v[1:3]) + "\n"
+            elif v[0] == 2:
+                out_str += "     " + "p = 2:   " + str(v[1:]) + "\n"
+            else:
+                out_str += "     " + "p = " + str(v[0]) + ":   " + str(v[1:5]) + "\n"
+
+        return out_str
+
+
+
+    def __eq__(self, right):
+        """
+        Determines if two sets of local conditions are equal.
+    
+        EXAMPLES:
+             sage: Q1 = DiagonalQuadraticForm(ZZ, [1,1])
+             sage: Q2 = DiagonalQuadraticForm(ZZ, [1,1,1])
+             sage: Q3 = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+             sage: Q4 = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+
+             sage: Q1.local_representation_conditions() == Q2.local_representation_conditions()
+             False
+             sage: Q1.local_representation_conditions() == Q3.local_representation_conditions()
+             False
+             sage: Q1.local_representation_conditions() == Q4.local_representation_conditions()
+             False
+             sage: Q2.local_representation_conditions() == Q3.local_representation_conditions()
+             False
+             sage: Q3.local_representation_conditions() == Q4.local_representation_conditions()
+             True
+        """    
+        if not isinstance(right, QuadraticFormLocalRepresentationConditions):
+            return False
+
+        ## Check the dimensions agree when they affect the kind of representation conditions.
+        if ((self.dim <= 2) or (right.dim <= 2)) and self.dim != right.dim:
+            return False
+
+        ## Check equality by dimension
+        if self.dim == 0:
+            return True
+        elif self.dim == 1:
+            return self.coeff == right.coeff     ## Compare coefficients in dimension 1 (since ZZ has only one unit square)
+        else:
+            return (self.exceptional_primes == right.exceptional_primes) \
+                and (self.local_repn_array == right.local_repn_array)
+
+
+    def squareclass_vector(self, p):
+        """
+        Gives a vector of integers which are normalized
+        representatives for the p-adic rational squareclasses 
+        (or the real squareclasses) at the prime p.
+
+        INPUT:
+            p -- a positive prime number or "infinity".
+
+        OUTPUT:
+            a list of integers
+
+        EXAMPLES:
+        """
+        if p == infinity:
+            return [1, -1]
+        elif p == 2:
+            return [1, 3, 5, 7, 2, 6, 10, 14]
+        else:
+            r = quadratic_nonresidue(p)
+            return [1, r, p, p*r]
+
+
+
+    def local_conditions_vector_for_prime(self, p):
+        """
+        Returns a local representation vector for the (possibly infinite) prime p.
+        """
+        ## Check if p is non-generic
+        if p in self.exceptional_primes:
+            return deepcopy(self.local_repn_array[self.exceptional_primes.index(p)])
+
+        ## Otherwise, generate a vector at this (finite) prime
+        if self.dim >= 3:
+            if p == 2:
+                return [2, 0, 0, 0, 0, 0, 0, 0, 0]
+            else:
+                return [p, 0, 0, 0, 0, None, None, None, None]
+
+        elif self.dim == 2:
+            if p == 2:
+                return [2, 0, 0, 0, 0, infinity, infinity, infinity, infinity]
+            else:
+                return [p, 0, 0, infinity, infinity, None, None, None, None]
+
+        elif self.dim == 1:
+            v = [p, None, None, None, None, None, None, None, None]
+            sqclass = self.squareclass_vector(p)
+
+            for i in range(len(sq_class)):
+                if IsPadicSquare(self.coeff / sqclass[i], p):    ## Note:This should happen only once!
+                    nu = valuation(self.coeff / sqclass[i], p) / 2
+                else:
+                    v[i+1] = infinity
+
+        elif self.dim == 0:
+            if p == 2:
+                return [2, infinity, infinity, infinity, infinity, infinity, infinity, infinity, infinity]
+            else:
+                return [p, infinity, infinity, infinity, infinity, None, None, None, None]
+
+        raise RuntimeError, "Error... The dimension stored should be a non-negative integer!" 
+
+
+    def is_universal_at_prime(self, p):
+        """
+        Determines if the (integer-valued/rational) quadratic form represents all of Z_p.
+        """
+        ## Check if the prime behaves generically for n >= 3.
+        if (self.dim >= 3) and not (p in self.exceptional_primes):
+            return True
+
+        ## Check if the prime behaves generically for n <= 2.
+        if (self.dim <= 2) and not (p in self.exceptional_primes):
+            return False
+
+        ## Check if the prime is "infinity" (for the reals)
+        if p == infinity:
+            v = self.local_repn_array[0]
+            if p != v[0]:
+                raise RuntimeError, "Error... The first vector should be for the real numbers!"
+            return (v[1:3] == [0,0])     ## True iff the form is indefinite
+
+        ## Check non-generic "finite" primes
+        v = self.local_conditions_vector_for_prime(p)
+        Zp_univ_flag = True
+        for nu in v[1:]:
+            if not ((nu >= 0) or (nu == None)):
+                Zp_univ_flag = False
+        return Zp_univ_flag
+
+
+    def is_universal_at_all_finite_primes(self):
+        """
+        Determines if the quadratic form represents Z_p for all finite/non-archimedian primes.
+        """
+        ## Check if dim <= 2.
+        if self.dim <= 2:
+            return False
+
+        ## Check that all non-generic finite primes are universal
+        univ_flag = True
+        for p in self.exceptional_primes[1:]:      ## Omit p = "infinity" here
+            univ_flag = univ_flag and is_universal_at_prime(p)
+        return univ_flag
+
+
+    def is_universal_at_all_places(self):
+        """
+        Determines if the quadratic form represents Z_p for all
+        finite/non-archimedian primes, and represents all real numbers.
+        """
+        ## Check if dim <= 2.
+        if self.dim <= 2:
+            return False
+
+        ## Check that all non-generic finite primes are universal
+        for p in self.exceptional_primes:
+            if not self.is_universal_at_prime(p):
+                return False
+        return True
+
+
+
+    def is_locally_represented_at_place(self, m, p):
+        """
+        Determines if the rational number m is locally represented by the
+        quadratic form at the (possibly infinite) prime p.
+        """
+        ## Sanity Check
+        if not m in QQ:
+            raise TypeError, "Oops!  m = " + str(m) +  " is not a rational number!"
+
+       ## Representing zero
+        if m == 0:
+            return True
+
+        ## 0-dim'l forms
+        if self.dim == 0:    ## Here m != 0
+            return False
+
+        ## 1-dim'l forms
+        if self.dim == 1:
+            m1 = QQ(m) / self.coeff
+            if p == infinity:
+                return (m1 > 0)
+            else:
+                return (valuation(m1, p) >= 0) and IsPadicSquare(m1, p)
+
+        ## >= 2-dim'l forms
+        local_vec = self.local_conditions_vector_for_prime(p)
+
+        ## Check the real place
+        if p == infinity:
+            if m > 0:
+                return local_vec[1] == 0
+            elif m < 0:
+                return local_vec[2] == 0
+            else:   ## m == 0
+                return True
+
+        ## Check at a finite place
+        sqclass = self.squareclass_vector(p)
+        for s in sqclass:
+            #print "m =", m, "   s =", s, "   m/s =", (QQ(m)/s)
+            if IsPadicSquare(QQ(m)/s, p):
+                nu = valuation(m/s, p)
+                return local_vec[sqclass.index(s) + 1] <= (nu / 2)
+
+
+
+    def is_locally_represented(self, m):
+        """
+        Determines if the rational number m is locally represented by the quadratic form.
+        """
+        ## Representing zero
+        if m == 0:
+            return True
+
+        ## 0-dim'l forms
+        if self.dim == 0:    ## Here m != 0
+            return False
+
+        ## 1-dim'l forms
+        if self.dim == 1:
+            m1 = m / self.coeff
+            return (m1 in ZZ) and is_square(m1)
+ 
+        ## Check the generic primes (when n = 2 or n >= 3)
+        m_primes = prime_divisors(numerator(m) * denominator(m))
+        for p in m_primes:
+            if not p in self.exceptional_primes:
+               val = valuation(m, p)
+               if (val < 0): 
+                   return False
+
+        ## Check the non-generic primes (when n = 2 or n >= 3)
+        for p in self.exceptional_primes:
+            if not self.is_locally_represented_at_place(m, p):
+                return False                    
+
+        ## If we got here, we're locally represented!
+        return True
+
+
+
+## --------------------  End of QuadraticFormLocalRepresentationConditions Class   ----------------------
+
+
+
+def local_representation_conditions(self, recompute_flag=False, silent_flag=False):
+    """
+    WARNING: THIS ONLY WORKS CORRECTLY FOR FORMS IN >=3 VARIABLES,
+        WHICH ARE LOCALLY UNIVERSAL AT ALMOST ALL PRIMES!
+
+    This class finds the local conditions for a number to be integrally
+    represented by an integer-valued quadratic form.  These conditions
+    are stored in "self.__local_representability_conditions" and
+    consist of a list of 9 element vectors, with one for each prime
+    with a local obstruction (though only the first 5 are meaningful
+    unless p=2).  The first element is always the prime p where the
+    local obstruction occurs, and the next 8 (or 4) entries represent
+    square-classes in the p-adic integers Z_p, and are labeled by the
+    Q_p square-classes t*(Q_p)^2 with t given as follows:
+
+        p > 2  ==>  [ *  1  u  p  up  *  *  *  * ]
+
+        p = 2  ==>  [ *  1  3  5  7  2  6  10  14 ]
+
+    The integer appearing in each place tells us how p-divisible a
+    number needs to be in that square-class in order to be locally
+    represented by Q.  A negative number indicates that the entire Q_p
+    square-class is not represented, while a positive number x indicates
+    that t*p^(2*x) (Z_p)^2 is locally represented but t*p^(2*(x-1))
+    (Z_p)^2 is not.
+
+    As an example, the vector
+
+        [2  3  0  0  0  0  2  0  infinity]
+
+    tells us that all positive integers are locally represented at p=2
+    except those of the forms:
+
+        2^6 * u * r^2  with u = 1 (mod 8)
+
+        2^5 * u * r^2  with u = 3 (mod 8)
+
+        2 * u * r^2  with u = 7 (mod 8)
+
+    At the real numbers, the vector which looks like
+
+        [infinity, 0, infinity, None, None, None, None, None, None]
+
+    means that Q is negative definite (i.e. the 0 tells us all
+    positive reals are represented).  The real vector always appears,
+    and is listed before the other ones.
+
+    OUTPUT:
+        A list of 9-element vectors describing the representation
+        obstructions at primes dividing the level.
+
+    EXAMPLES:
+         sage: Q = DiagonalQuadraticForm(ZZ, [])
+         sage: Q.local_representation_conditions()
+         This 0-dimensional form only represents zero.
+
+         sage: Q = DiagonalQuadraticForm(ZZ, [5])
+         sage: Q.local_representation_conditions()
+         This 1-dimensional form only represents square multiples of 5.
+
+        sage: Q1 = DiagonalQuadraticForm(ZZ, [1,1])
+        sage: Q1.local_representation_conditions()
+        This 2-dimensional form represents the p-adic integers of even
+        valuation for all primes p except [2].
+        For these and the reals, we have:
+             Reals:   [0, +Infinity]
+             p = 2:   [0, +Infinity, 0, +Infinity, 0, +Infinity, 0, +Infinity]
+
+
+        sage: Q1 = DiagonalQuadraticForm(ZZ, [1,1,1])
+        sage: Q1.local_representation_conditions()
+        This form represents the p-adic integers Z_p for all primes p except 
+        [2].  For these and the reals, we have:
+             Reals:   [0, +Infinity]
+             p = 2:   [0, 0, 0, +Infinity, 0, 0, 0, 0]
+
+        sage: Q1 = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+        sage: Q1.local_representation_conditions()
+        This form represents the p-adic integers Z_p for all primes p except 
+        [].  For these and the reals, we have:
+             Reals:   [0, +Infinity]
+
+        sage: Q1 = DiagonalQuadraticForm(ZZ, [1,3,3,3])
+        sage: Q1.local_representation_conditions()     
+        This form represents the p-adic integers Z_p for all primes p except 
+        [3].  For these and the reals, we have:
+             Reals:   [0, +Infinity]
+             p = 3:   [0, 1, 0, 0]
+
+        sage: Q2 = DiagonalQuadraticForm(ZZ, [2,3,3,3])
+        sage: Q2.local_representation_conditions()
+        This form represents the p-adic integers Z_p for all primes p except 
+        [3].  For these and the reals, we have:
+             Reals:   [0, +Infinity]
+             p = 3:   [1, 0, 0, 0]
+
+        sage: Q3 = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+        sage: Q3.local_representation_conditions()
+        This form represents the p-adic integers Z_p for all primes p except 
+        [].  For these and the reals, we have:
+             Reals:   [0, +Infinity]
+
+    """
+    ## Recompute the local conditions if they don't exist or the recompute_flag is set.
+    if (not hasattr(self, "__local_representability_conditions")) or (recompute_flag == True):
+        self.__local_representability_conditions = QuadraticFormLocalRepresentationConditions(self)
+
+    ## Return the local conditions if the silent_flag is not set.
+    if not silent_flag:
+        return self.__local_representability_conditions
+
+
+
+def is_locally_universal_at_prime(self, p):
+    """
+    Determines if the (integer-valued/rational) quadratic form represents all of Z_p.
+    """
+    self.local_representation_conditions(silent_flag=True)
+    return self.__local_representability_conditions.is_universal_at_prime(p)
+
+
+
+def is_locally_universal_at_all_primes(self):
+    """
+    Determines if the quadratic form represents Z_p for all finite/non-archimedian primes.
+    """    
+    self.local_representation_conditions(silent_flag=True)
+    return self.__local_representability_conditions.is_universal_at_all_finite_primes()
+
+
+
+def is_locally_universal_at_all_places(self):
+    """
+    Determines if the quadratic form represents Z_p for all
+    finite/non-archimedian primes, and represents all real numbers.
+    """
+    self.local_representation_conditions(silent_flag=True)
+    return self.__local_representability_conditions.is_universal_at_all_places()
+    
+
+
+def is_locally_represented_number_at_place(self, m, p):
+    """
+    Determines if the rational number m is locally represented by the
+    quadratic form at the (possibly infinite) prime p.
+    """
+    self.local_representation_conditions(silent_flag=True)
+    return self.__local_representability_conditions.is_locally_represented_at_place(m, p)
+
+
+
+def is_locally_represented_number(self, m):
+    """
+    Determines if the rational number m is locally represented by the quadratic form.
+    """
+    self.local_representation_conditions(silent_flag=True)
+    return self.__local_representability_conditions.is_locally_represented(m)
diff --git a/sage/quadratic_forms/quadratic_form__mass.py b/sage/quadratic_forms/quadratic_form__mass.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__mass.py
@@ -0,0 +1,39 @@
+
+######################################################
+## Routines to compute the mass of a quadratic form ##
+######################################################
+
+## Import all general mass finding routines
+from sage.quadratic_forms.quadratic_form__mass__Siegel_densities import *
+from sage.quadratic_forms.quadratic_form__mass__Conway_Sloane_masses import *
+
+
+###################################################
+
+
+def shimura_mass__maximal(self, p):
+    """
+    Use Shimuras exact mass formula to compute the mass of a maximal
+    quadratic lattice. This works for any totally real number field,
+    but has a small technical restriction when n is odd.
+    """
+    pass
+
+
+def hanke_mass__maximal(self, p):
+    """
+    Use Shimuras exact mass formula to compute the mass of a maximal 
+    quadratic lattice.  This works for any totally real number field, 
+    but has a small technical restriction when n is odd.
+    """
+    pass
+
+
+def GHY_mass_maximal(self, p):
+    """
+    Use the GHY formula to compute the mass of a (maximal?) quadratic
+    lattice. This works for any number field.
+
+    See [GHY, Prop 7.4 and 7.5, p121] and [GY, Thrm 10.20, p25].
+    """
+    pass
diff --git a/sage/quadratic_forms/quadratic_form__mass__Conway_Sloane_masses.py b/sage/quadratic_forms/quadratic_form__mass__Conway_Sloane_masses.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__mass__Conway_Sloane_masses.py
@@ -0,0 +1,542 @@
+
+from sage.rings.integer_ring import ZZ
+from sage.rings.rational_field import QQ
+from sage.rings.arith import kronecker_symbol, legendre_symbol, prime_divisors, is_prime
+from sage.algebras.quaternion_algebra import fundamental_discriminant
+from sage.functions.constants import pi
+from sage.misc.misc import prod
+from sage.quadratic_forms.special_values import gamma__exact, zeta__exact, quadratic_L_function__exact
+from sage.calculus.calculus import floor
+
+def parity(self, allow_rescaling_flag=True):
+    """
+    Returns the parity ("even" or "odd") of an integer-valued quadratic
+    form over ZZ, defined up to similitude/rescaling of the form so that
+    its Jordan component of smallest scale is unimodular.  After this
+    rescaling, we say a form is even if it only represents even numbers,
+    and odd if it represents some odd number.
+    
+    If the 'allow_rescaling_flag' is set to False, then we require that
+    the quadratic form have a Gram matrix with coefficients in ZZ, and
+    look at the unimodular Jordan block to determine its parity.  This
+    returns an error if the form is not integer-matrix, meaning that it
+    has Jordan components at p=2 which do not have an integer scale.
+
+    We determine the parity by looking for a 1x1 block in the 0-th
+    Jordan component, after a possible rescaling.  
+
+    INPUT:
+        self -- a quadratic form with base_ring ZZ, which we may
+                require to have integer Gram matrix.
+                
+    OUTPUT:
+        One of the strings: "even" or "odd"
+
+    EXAMPLES:
+        sage: Q = QuadraticForm(ZZ, 3, [4, -2, 0, 2, 3, 2]); Q
+        Quadratic form in 3 variables over Integer Ring with coefficients:
+        [ 4 -2 0 ]
+        [ * 2 3 ]
+        [ * * 2 ]
+        sage: Q.parity()
+        'even'
+
+        sage: Q = QuadraticForm(ZZ, 3, [4, -2, 0, 2, 3, 1]); Q
+        Quadratic form in 3 variables over Integer Ring with coefficients:
+        [ 4 -2 0 ]
+        [ * 2 3 ]
+        [ * * 1 ]
+        sage: Q.parity()
+        'odd'
+
+    """
+    ## Deal with 0-dim'l forms
+    if self.dim() == 0:
+        return "even"
+
+    ## Identify the correct Jordan component to use.
+    Jordan_list = self.jordan_blocks_by_scale_and_unimodular(2)
+    scale_pow_list = [J[0]  for J in Jordan_list]
+    min_scale_pow = min(scale_pow_list)
+    if allow_rescaling_flag:
+        ind = scale_pow_list.index(min_scale_pow)
+    else:
+        if min_scale_pow < 0:
+            raise TypeError, "Oops!  If rescaling is not allowed, then we require our form to have an integral Gram matrix."
+        ind = scale_pow_list.index(0)
+    
+
+    ## Find the component of scale (power) zero, and then look for an odd dim'l component.
+    J0 = Jordan_list[ind]
+    Q0 = J0[1]
+
+    ## The lattice is even if there is no component of scale (power) 0
+    if J0 == None:
+        return "even"
+
+    ## Look for a 1x1 block in the 0-th Jordan component (which by
+    ## convention of the local_normal_form routine will appear first).
+    if Q0.dim() == 1:
+        return "odd"
+    elif Q0[0,1] == 0:
+        return "odd"
+    else:
+        return "even"
+
+
+
+def is_even(self, allow_rescaling_flag=True):
+    """
+    Returns true iff after rescaling by some appropriate factor, the
+    form represents no odd integers.  For more details, see parity().
+
+    Requires that Q is defined over ZZ.
+    """
+    return self.parity(allow_rescaling_flag) == "even"
+
+
+def is_odd(self, allow_rescaling_flag=True):
+    """
+    Returns true iff after rescaling by some appropriate factor, the
+    form represents some odd integers.  For more details, see parity().
+
+    Requires that Q is defined over ZZ.
+    """
+    return self.parity(allow_rescaling_flag) == "odd"
+
+    
+
+def conway_species_list_at_odd_prime(self, p):
+    """
+    Returns an integer called the 'species' which determines the type
+    of the orthogonal group over the finite field F_p.
+
+    This assumes that the given quadratic form is a unimodular Jordan
+    block at an odd prime p.  When the dimension is odd then this
+    number is always positive, otherwise it may be positive or
+    negative (or zero, but that is considered positive by convention).
+
+    Note: The species of a zero dim'l form is always 0+, so we
+    interpret the return value of zero as positive here! =)
+
+    INPUT:
+        a positive prime number
+
+    OUTPUT:
+        a list of integers
+    """
+    ## Sanity Check:
+    if not ((p>2) and is_prime(p)):
+        raise TypeError, "Oops!  We are assuming that p is an odd positive prime number."
+
+    ## Deal with the zero-dim'l form
+    if self.dim() == 0:
+        return [0]
+
+    ## List the (unscaled/unimodular) Jordan blocks by their scale power
+    jordan_list = self.jordan_blocks_in_unimodular_list_by_scale_power(p)
+
+    ## Make a list of species (including the two zero-dim'l forms missing at either end of the list of Jordan blocks)
+    species_list = []
+    for tmp_Q in jordan_list: 
+
+        ## Some useful variables
+        n = tmp_Q.dim()
+        d = tmp_Q.det()
+
+        ## Determine the species
+        if (n % 2 != 0):                            ## Deal with odd dim'l forms
+            species = n
+        elif (n % 4 == 2) and (p % 4 == 3):         ## Deal with even dim'l forms
+            species = (-1) * legendre_symbol(d, p) * n
+        else:
+            species = legendre_symbol(d, p) * n
+
+        ## Append the species to the list
+        species_list.append(species)
+
+    ## Return the species list
+    return species_list
+
+
+def conway_species_list_at_2(self):
+    """
+    Returns an integer called the 'species' which determines the type
+    of the orthoginal group over the finite field F_p.
+
+    This assumes that the given quadratic form is a unimodular Jordan
+    block at an odd prime p.  When the dimension is odd then this
+    number is always positive, otherwise it may be positive or
+    negative.
+
+    Note: The species of a zero dim'l form is always 0+, so we
+    interpret the return value of zero as positive here! =)
+
+    OUTPUT:
+        a list of integers
+
+    EXAMPLES:
+    """
+    ## Some useful variables
+    n = self.dim()
+    d = self.det()
+
+    ## Deal with the zero-dim'l form
+    if n == 0:
+        return 0
+
+    ## List the (unscaled/unimodular) Jordan blocks by their scale power
+    jordan_list = self.jordan_blocks_in_unimodular_list_by_scale_power(2)
+
+    ## Make a list of species (including the two zero-dim'l forms missing at either end of the list of Jordan blocks)
+    species_list = []
+
+    if jordan_list[0].parity() == "odd":        ## Add an entry for the unlisted "-1" Jordan component as well.
+        species_list.append(1)
+
+    for i in range(len(jordan_list)):           ## Add an entry for each (listed) Jordan component
+
+        ## Make the number 2*t in the C-S Table 1.
+        d = jordan_list[i].dim()
+        if jordan_list[i].is_even():
+            two_t = d
+        else:
+            two_t = ZZ(2) * floor((d-1) / 2)
+
+        ## Determine if the form is bound
+        if len(jordan_list) == 1:
+            is_bound = False
+        elif i == 0:
+            is_bound = jordan_list[i+1].is_odd()
+        elif i == len(jordan_list) - 1:
+            is_bound = jordan_list[i-1].is_odd()
+        else:
+            is_bound = jordan_list[i-1].is_odd() or jordan_list[i+1].is_odd()
+
+        ## Determine the species
+        octane = jordan_list[i].conway_octane_of_this_unimodular_Jordan_block_at_2()
+        if is_bound or (octane == 2) or (octane == 6):
+            species = two_t + 1
+        elif (octane == 0) or (octane == 1) or (octane == 7): 
+            species = two_t
+        else:
+            species = (-1) * two_t
+
+        ## Append the species to the list
+        species_list.append(species)
+
+
+    if jordan_list[-1].is_odd():        ## Add an entry for the unlisted "s_max + 1" Jordan component as well.
+        species_list.append(1)
+
+    ## Return the species list
+    return species_list
+
+
+
+
+def conway_octane_of_this_unimodular_Jordan_block_at_2(self):
+    """
+    Determines the 'octane' of this full unimodular Jordan block at
+    the prime p=2.  This is an invariant defined (mod 8), ad.
+
+    This assumes that the form is given as a block diagonal form with
+    unimodular blocks of size <= 2 and the 1x1 blocks are all in the upper
+    leftmost position.
+
+    OUTPUT:
+        an integer 0 <= x <= 7
+
+    """
+    ## Deal with 'even' forms 
+    if self.parity() == "even":
+        d = self.Gram_matrix().det()
+        if (d % 8 == 1) or (d % 8 == 7):
+            return 0
+        else:
+            return 4
+
+    ## Deal with 'odd' forms by diagonalizing, and then computing the octane.
+    n = self.dim()
+    u = self[0,0]
+    tmp_diag_vec = [None  for i in range(n)]
+    tmp_diag_vec[0] = u       ## This should be an odd integer!
+    ind = 1                  ## The next index to diagonalize
+
+
+    ## Use u to diagonalize the form -- WHAT ARE THE POSSIBLE LOCAL NORMAL FORMS?
+    while ind < n:
+        
+        ## Check for a 1x1 block and diagonalize it
+        if (ind == (n-1)) or (self[ind, ind+1] == 0):
+            tmp_diag_vec[ind] = self[ind, ind]
+            ind += 1
+
+        ## Diagonalize the 2x2 block
+        else:
+            B = self[ind, ind+1]
+            if (B % 2 != 0):
+                raise RuntimeError, "Oops, we expected the mixed term to be even! "
+
+            a = self[ind, ind]
+            b = ZZ(B / ZZ(2))
+            c = self[ind+1, ind+1]
+            tmp_disc = b * b - a * c
+
+            ## Perform the diagonalization
+            if (tmp_disc % 8 == 1):                ## 2xy
+                tmp_diag_vec[ind] = 1
+                tmp_diag_vec[ind+1] = -1
+                ind += 2
+            elif(tmp_disc % 8 == 5):               ## 2x^2 + 2xy + 2y^2
+                tmp_diag_vec[0] = 3*u    
+                tmp_diag_vec[ind] = -u
+                tmp_diag_vec[ind+1] = -u
+                ind += 2
+                u = tmp_diag_vec[0]
+            else:
+                raise RuntimeError, "Oops!  This should not happen -- the odd 2x2 blocks have disc 1 or 5 (mod 8)."
+
+    ## Compute the octane
+    octane = 0
+    for a in tmp_diag_vec:
+        if a % 4 == 1:
+            octane += 1
+        elif a % 4 == 3:
+            octane += -1
+        else:
+            raise RuntimeError, "Oops!  The diagonal elements should all be odd... =("
+
+    ## Return its value
+    return octane % 8
+
+
+
+def conway_diagonal_factor(self, p):
+    """
+    Computes the diagonal factor of Conway's p-mass.
+    """
+     ## Get the species list at p
+    if p == 2:
+        species_list = self.conway_species_list_at_2()
+    else:
+        species_list = self.conway_species_list_at_odd_prime(p)
+
+    ## Evaluate the diagonal factor
+    diag_factor = QQ(1)
+    for s in species_list:
+        if s == 0:
+            pass
+        elif s % 2 == 1:                   ## Note: Here always s > 0.
+            diag_factor = diag_factor / (2 * prod([1 - QQ(p)**(-i)  for i in range(2, s, 2)]))
+        else:
+            diag_factor = diag_factor / (2 * prod([1 - QQ(p)**(-i)  for i in range(2, abs(s), 2)]))
+            s_sign = ZZ(s / abs(s))             
+            diag_factor = diag_factor / (ZZ(1) - s_sign * QQ(p) ** ZZ(-abs(s) / ZZ(2)))
+
+    ## Return the diagonal factor
+    return diag_factor
+
+
+
+def conway_cross_product_doubled_power(self, p):
+    """
+    Computes twice the power of p which evalues the 'cross product'
+    term in Conway's mass formula.
+    """
+    doubled_power = 0
+    dim_list = [J.dim()  for J in self.jordan_blocks_in_unimodular_list_by_scale_power(p)]
+    for i in range(len(dim_list)):
+        for j in range(i):
+            doubled_power += (i-j) * dim_list[i] * dim_list[j]
+
+    return doubled_power
+
+
+
+def conway_type_factor(self):
+    """
+    This is a special factor only present in the mass formula when p=2.
+    """
+    jordan_list = self.jordan_blocks_in_unimodular_list_by_scale_power(2)
+    n2 = sum([J.dim()  for J in jordan_list  if J.is_even()])
+    n11 = sum([1  for i in range(len(jordan_list) - 1)  if jordan_list[i].is_odd() and jordan_list[i+1].is_odd()])
+
+    return ZZ(2)**(n11 - n2)
+
+
+
+def conway_p_mass(self, p):
+    """
+    Computes Conway's p-mass.
+    """
+    ## Compute the first two factors of the p-mass
+    p_mass = self.conway_diagonal_factor(p) * (p ** (self.conway_cross_product_doubled_power(p) / ZZ(2)))
+
+    ## Multiply by the 'type factor' when p = 2
+    if p == 2:
+        p_mass *= self.conway_type_factor()
+
+    ## Return the result
+    return p_mass
+
+
+
+def conway_standard_p_mass(self, p):
+    """
+    Computes the standard (generic) Conway-Sloane p-mass.
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1])
+        sage: Q.conway_standard_p_mass(2)
+        2/3
+    """
+    ## Some useful variables
+    n = self.dim()
+    if n % 2 == 0:
+        s = n / 2
+    else:
+        s = (n+1) / 2
+
+    ## Compute the inverse of the generic p-mass
+    p_mass_inv = 2 * prod([1-p**(-i)  for i in range(2, 2*s, 2)]) 
+    if n % 2 == 0:
+        D = (-1)**s * self.det() * (2**n)   ##   We should have something like  D = (-1)**s * self.det() / (2**n), but that's not an integer and here we only care about the square-class.
+        #d = self.det()   ## Note: No normalizing power of 2 is needed since the power is even.
+        #if not ((p == 2) or (d % p == 0)):
+        p_mass_inv *= (1 - kronecker_symbol(fundamental_discriminant(D), p) * p**(-s))
+
+    ## Return the standard p-mass
+    return ZZ(1) / p_mass_inv
+
+
+
+def conway_standard_mass(self):
+    """
+    Returns the infinite product of the standard mass factors.
+
+    EXAMPLES:
+        sage: Q = QuadraticForm(ZZ, 3, [2, -2, 0, 3, -5, 4])
+        sage: Q.conway_standard_mass()
+        1/6
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1])
+        sage: Q.conway_standard_mass()
+        1/6
+    """
+    n = self.dim()
+    if n % 2 == 0:
+        s = n / 2
+    else:
+        s = (n+1) / 2
+
+    ## DIAGNOSTIC
+    #print "n = ", n
+    #print "s = ", s
+    #print "Gamma Factor = \n", prod([gamma__exact(j / ZZ(2))  for j in range(1, n+1)])
+    #print "Zeta Factor = \n", prod([zeta__exact(2*k)  for k in range(1, s)])
+    #print "Pi Factor = \n", pi**((-1) * n * (n+1) / ZZ(4)) 
+        
+    generic_mass = 2 * pi**((-1) * n * (n+1) / ZZ(4)) \
+            * prod([gamma__exact(j / ZZ(2))  for j in range(1, n+1)]) \
+            * prod([zeta__exact(2*k)  for k in range(1, s)])
+
+    if n % 2 == 0:
+        D = (-1)**s * self.det() * (2**n)   ##   We should have something like  D = (-1)**s * self.det() / (2**n), but that's not an integer and here we only care about the square-class.
+        generic_mass *= quadratic_L_function__exact(s, D)
+
+    return generic_mass
+
+
+
+def conway_mass(self):
+    """
+    Compute the mass by using the Conway-Sloane mass formula.    
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1])
+        sage: Q.conway_mass()
+        1/48
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [7,1,1])
+        sage: Q.conway_mass()
+        1/16
+
+        sage: Q = QuadraticForm(ZZ, 3, [7, 2, 2, 2, 0, 2]) + DiagonalQuadraticForm(ZZ, [1])
+        sage: Q.conway_mass()
+        3/32
+    """
+    ## Try to use the cached result
+    try:
+        return self.__conway_mass
+    except:
+        ## Double the form so it's integer-matrix
+        Q = self.scale_by_factor(2)
+
+        ## Compute the standard mass
+        mass = Q.conway_standard_mass()
+
+        ## Adjust the p-masses when p|2d
+        d = self.det()
+        for p in prime_divisors(2*d):
+            mass *= (Q.conway_p_mass(p) / Q.conway_standard_p_mass(p))
+
+        ## Cache and return the (simplified) result
+        self.__conway_mass = QQ((mass**ZZ(2))**(ZZ(1)/ZZ(2)))
+        return self.__conway_mass
+
+
+## ========================================================
+
+
+
+
+def conway_generic_mass(self):
+    """ 
+    Computes the generic mass given as 
+         2 \pi^{-n(n+1)/4} \prod_{j=1}^{n} \Gamma\(\tfrac{j}{2}\)
+        \zeta(2) \cdots \zeta(2s-2) \zeta_{D}(s)
+    where $n = 2s$ or $2s-1$ depending on the parity of $n$, 
+    and $D = (-1)^{s} d$.  We interpret the symbol $\(\frac{D}{p}\)$ 
+    as 0 if $p\mid 2d$.
+    (Conway and Sloane, Mass formula paper, p??)
+
+    This is possibly equal to  
+        2^{-td} * \tau(G) *[\prod_{i=1}^{t} \zeta(1-2i) ]* L(1-t, \chi)
+    where $\dim(Q) = n = 2t$ or $2t+1$, and the last factor is omitted 
+    when $n$ is odd.
+    (GHY, Prop 7.4 and 7.5, p121)
+    """
+    RR = RealField(200)
+    n = self.dim()
+    if n % 2 == 0:
+        s = n / 2
+    else:
+        s = (n-1) / 2
+
+    ## Form the generic zeta product
+    ans = 2 * RR(pi)^(-n * (n+1) / 4)
+    for j in range(1,n+1):
+        ans *= gamma(RR(j/2))
+    for j in range(2, 2*s, 2):  ## j = 2, ..., 2s-2    
+        ans *= zeta(RR(j))
+
+    ## Extra L-factor for even dimensional forms  -- DO THIS!!!
+    raise NotImplementedError, "This routine is not finished yet... =("
+
+    ## Return the answer
+    return ans
+
+
+
+
+
+    
+def conway_p_mass_adjustment(self, p):
+    """
+    Computes the adjustment to give the p-mass from the generic mass.
+    """
+    pass
+
+
+########################################################################
diff --git a/sage/quadratic_forms/quadratic_form__mass__Siegel_densities.py b/sage/quadratic_forms/quadratic_form__mass__Siegel_densities.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__mass__Siegel_densities.py
@@ -0,0 +1,378 @@
+
+######################################################################################################
+##  Computes the local masses (rep'n densitites of a form by itself) for a quadratic forms over ZZ
+##      using the papers of Pall [PSPUM VIII (1965), pp95--105]  for p>2, and Watson [Mathematika 
+##      23, no. 1, (1976), pp 94--106] for p=2.  These formulas will also work for any local field 
+##          which is unramified at p=2.
+##
+##  Copyright by Jonathan Hanke 2007 <jonhanke@gmail.com>
+######################################################################################################
+
+import copy
+
+from sage.misc.misc import prod 
+from sage.misc.mrange import mrange
+from sage.calculus.calculus import floor
+from sage.rings.integer_ring import ZZ
+from sage.rings.integer_mod_ring import IntegerModRing
+from sage.rings.rational_field import QQ
+from sage.rings.arith import legendre_symbol, kronecker, prime_divisors
+from sage.quadratic_forms.extras import sgn
+from sage.quadratic_forms.special_values import gamma__exact, zeta__exact, quadratic_L_function__exact
+from sage.misc.functional import squarefree_part
+from sage.functions.constants import pi
+from sage.matrix.matrix_space import MatrixSpace
+
+
+def mass__by_Siegel_densities(self, odd_algorithm="Pall", even_algorithm="Watson"):
+    """
+    Gives the mass of transformations (det 1 and -1).
+
+    WARNING: THIS IS BROKEN RIGHT NOW... =(
+
+    Optional Arguments:
+        When p > 2  --  odd_algorithm = "Pall" (only one choice for now)
+        When p = 2  --  even_algorithm = "Kitaoka" or "Watson"
+
+    REFERENCES:
+        Nipp's Book "Tables of Quaternary Quadratic Forms".
+        Papers of Pall (only for p>2) and Watson (for p=2 -- tricky!).
+        Siegel, Milnor-Hussemoller, Conway-Sloane Paper IV, Kitoaka
+            (all of which have problems...)
+                
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+        sage: Q.mass__by_Siegel_densities()
+        1/384
+        sage: Q.mass__by_Siegel_densities() - (2^Q.dim() * factorial(Q.dim()))^(-1)
+        0
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1])
+        sage: Q.mass__by_Siegel_densities()
+        1/48
+        sage: Q.mass__by_Siegel_densities() - (2^Q.dim() * factorial(Q.dim()))^(-1)
+        0
+    """
+    ## Setup
+    n = self.dim()
+    s = floor((n-1)/2)
+    if n % 2 != 0:
+        char_d = squarefree_part(2*self.det())   ## Accounts for the det as a QF
+    else:
+        char_d = squarefree_part(self.det())
+    
+    ## Form the generic zeta product
+    generic_prod = ZZ(2) * (pi)**(-ZZ(n) * (n+1) / 4)   
+    ##########################################
+    generic_prod *= (self.det())**(ZZ(n+1)/2)  ## ***** This uses the Hessian Determinant ********
+    ##########################################
+    #print "gp1 = ", generic_prod
+    generic_prod *= prod([gamma__exact(ZZ(j)/2)  for j in range(1,n+1)])
+    #print "\n---", [(ZZ(j)/2, gamma__exact(ZZ(j)/2))  for j in range(1,n+1)]
+    #print "\n---", prod([gamma__exact(ZZ(j)/2)  for j in range(1,n+1)])
+    #print "gp2 = ", generic_prod
+    generic_prod *= prod([zeta__exact(ZZ(j))  for j in range(2, 2*s+1, 2)])
+    #print "\n---", [zeta__exact(ZZ(j))  for j in range(2, 2*s+1, 2)]
+    #print "\n---", prod([zeta__exact(ZZ(j))  for j in range(2, 2*s+1, 2)])
+    #print "gp3 = ", generic_prod
+    if (n % 2 == 0):
+        generic_prod *= ZZ(1) * quadratic_L_function__exact(n/2, (-1)**(n/2) * char_d)
+        #print " NEW = ", ZZ(1) * quadratic_L_function__exact(n/2, (-1)**(n/2) * char_d)
+        #print 
+    #print "gp4 = ", generic_prod
+
+    #print "generic_prod =", generic_prod
+
+    ## Determine the adjustment factors
+    adj_prod = 1
+    for p in prime_divisors(2 * self.det()):
+        ## Cancel out the generic factors
+        p_adjustment = prod([1 - ZZ(p)**(-j)  for j in range(2, 2*s+1, 2)])
+        if (n % 2 == 0):
+            p_adjustment *= ZZ(1) * (1 - kronecker((-1)**(n/2) * char_d, p) * ZZ(p)**(-n/2))
+            #print " EXTRA = ", ZZ(1) * (1 - kronecker((-1)**(n/2) * char_d, p) * ZZ(p)**(-n/2))
+        #print "Factor to cancel the generic one:", p_adjustment
+
+        ## Insert the new mass factors
+        if p == 2:
+            if even_algorithm == "Kitaoka":
+                p_adjustment = p_adjustment / self.Kitaoka_mass_at_2()
+            elif even_algorithm == "Watson": 
+                p_adjustment = p_adjustment / self.Watson_mass_at_2()
+            else:
+                raise TypeError, "There is a problem -- your even_algorithm argument is invalid.  Try again. =("
+        else:
+            if odd_algorithm == "Pall":         
+                p_adjustment = p_adjustment / self.Pall_mass_density_at_odd_prime(p)
+            else:
+                raise TypeError, "There is a problem -- your optional arguments are invalid.  Try again. =("
+
+        #print "p_adjustment for p =", p, "is", p_adjustment 
+
+        ## Put them together (cumulatively)
+        adj_prod *= p_adjustment
+
+    #print "Cumulative adj_prod =", adj_prod
+
+        ## Extra adjustment for the case of a 2-dimensional form.
+    #if (n == 2):
+    #    generic_prod *= 2
+
+
+    ## Return the mass
+    mass = generic_prod * adj_prod
+    return mass
+    
+    
+
+def Pall_mass_density_at_odd_prime(self, p):
+    """
+    Returns the local representation density of a form (for
+    representing itself) defined over ZZ, at some prime p>2.
+
+    REFERENCES:
+        Pall's article "The Weight of a Genus of Positive n-ary Quadratic Forms" 
+        appearing in Proc. Symp. Pure Math. VIII (1965), pp95--105.
+
+    INPUT:
+        p -- a prime number > 2.
+
+    OUTPUT:
+        a rational number.
+    """
+    ## Check that p is a positive prime -- unnecessary since it's done implicitly in the next step. =)
+    if p<=2:
+        raise TypeError, "Oops!  We need p to be a prime > 2."
+
+    ## Step 1: Obtain a p-adic (diagonal) local normal form, and
+    ## compute the invariants for each Jordan block.
+    jordan_list = self.jordan_blocks_by_scale_and_unimodular(p)
+    modified_jordan_list = [(a, Q.dim(), Q.det())  for (a,Q) in jordan_list]     ## List of pairs (scale, det)
+    #print jordan_list
+    #print modified_jordan_list
+
+
+    ## Step 2: Compute the list of local masses for each Jordan block 
+    jordan_mass_list = []
+    for (s,n,d) in modified_jordan_list:
+        generic_factor = prod([1 - p**(-2*j)  for j in range(1, floor((n-1)/2)+1)]) 
+        #print "generic factor: ", generic_factor        
+        if (n % 2 == 0):
+            m = n/2
+            generic_factor *= (1 + legendre_symbol(((-1)**m) * d, p) * p**(-m)) 
+        #print "jordan_mass: ", generic_factor
+        jordan_mass_list = jordan_mass_list + [generic_factor]
+
+                
+    ## Step 3: Compute the local mass $\al_p$ at p.
+        MJL = modified_jordan_list
+    s = len(modified_jordan_list)
+    M = [sum([MJL[j][1]  for j in range(i, s)])  for i in range(s-1)]    ## Note: It's s-1 since we don't need the last M. 
+    #print "M = ", M
+    nu = sum([M[i] * MJL[i][0] * MJL[i][1]  for i in range(s-1)]) - ZZ(sum([J[0] * J[1] * (J[1]-1)  for J in MJL]))/ZZ(2)
+    p_mass = prod(jordan_mass_list)
+    p_mass *= 2**(s-1) * p**nu
+
+    print jordan_list, MJL, jordan_mass_list, p_mass
+    
+    ## Return the result        
+    return p_mass
+
+
+def Watson_mass_at_2(self):
+    """
+    Returns the local mass of the quadratic form when p=2, according
+    to Watson's Theorem 1 of "The 2-adic density of a quadratic form"
+    in Mathematika 23 (1976), pp 94--106.
+    """
+    ## Make a 0-dim'l quadratic form (for initialization purposes)
+    Null_Form = copy.deepcopy(self)
+    Null_Form.__init__(ZZ, 0)
+
+    ## Step 0: Compute Jordan blocks and bounds of the scales to keep track of 
+    Jordan_Blocks = self.jordan_blocks_by_scale_and_unimodular(2)
+    scale_list = [B[0]  for B in Jordan_Blocks]
+    s_min = min(scale_list)
+    s_max = max(scale_list)
+        
+    ## Step 1: Compute dictonaries of the diagonal block and 2x2 block for each scale
+    diag_dict = dict((i, Null_Form)  for i in range(s_min-2, s_max + 4))     ## Initialize with the zero form
+    dim2_dict = dict((i, Null_Form)  for i in range(s_min, s_max + 4))       ## Initialize with the zero form
+    for (s,L) in Jordan_Blocks:
+        i = 0
+        while (i < L.dim()-1) and (L[i,i+1] == 0):      ## Find where the 2x2 blocks start
+            i = i + 1
+        if i < (L.dim() - 1):
+            diag_dict[s] = L.extract_variables(range(i))                ## Diagonal Form
+            dim2_dict[s+1] = L.extract_variables(range(i, L.dim()))     ## Non-diagonal Form    
+        else:
+            diag_dict[s] = L
+
+    #print "diag_dict = ", diag_dict
+    #print "dim2_dict = ", dim2_dict
+    #print "Jordan_Blocks = ", Jordan_Blocks
+
+    ## Step 2: Compute three dictionaries of invariants (for n_j, m_j, nu_j)
+    n_dict = dict((j,0)  for j in range(s_min+1, s_max+2))
+    m_dict = dict((j,0)  for j in range(s_min, s_max+4))
+    for (s,L) in Jordan_Blocks:
+        n_dict[s+1] = L.dim()
+        if diag_dict[s].dim() == 0:
+            m_dict[s+1] = ZZ(1)/ZZ(2) * L.dim()
+        else:
+            m_dict[s+1] = floor(ZZ(L.dim() - 1) / ZZ(2))
+            #print " ==>", ZZ(L.dim() - 1) / ZZ(2), floor(ZZ(L.dim() - 1) / ZZ(2))
+
+    nu_dict = dict((j,n_dict[j+1] - 2*m_dict[j+1])  for j in range(s_min, s_max+1))
+    nu_dict[s_max+1] = 0
+
+    #print "n_dict = ", n_dict
+    #print "m_dict = ", m_dict
+    #print "nu_dict = ", nu_dict
+        
+    ## Step 3: Compute the e_j dictionary
+    eps_dict = {}
+    for j in range(s_min, s_max+3):
+        two_form = (diag_dict[j-2] + diag_dict[j] + dim2_dict[j]).scale_by_factor(2) 
+        j_form = (two_form + diag_dict[j-1]).base_change_to(IntegerModRing(4))
+
+        if j_form.dim() == 0:
+            eps_dict[j] = 1
+        else:
+            iter_vec = [4] * j_form.dim()
+            alpha = sum([True  for x in mrange(iter_vec)  if j_form(x) == 0])
+            beta = sum([True  for x in mrange(iter_vec)  if j_form(x) == 2])
+            if alpha > beta:
+                eps_dict[j] = 1
+            elif alpha == beta:
+                eps_dict[j] = 0
+            else:
+                eps_dict[j] = -1
+
+    #print "eps_dict = ", eps_dict
+
+
+    ## Step 4: Compute the quantities nu, q, P, E for the local mass at 2
+    nu = sum([j * n_dict[j] * (ZZ(n_dict[j] + 1) / ZZ(2) + \
+              sum([n_dict[r]  for r in range(j+1, s_max+2)]))  for j in range(s_min+1, s_max+2)])  
+    q = sum([sgn(nu_dict[j-1] * (n_dict[j] + sgn(nu_dict[j])))  for j in range(s_min+1, s_max+2)])
+    P = prod([ prod([1 - QQ(4)**(-i)  for i in range(1, m_dict[j]+1)])  for j in range(s_min+1, s_max+2)])
+    E = prod([ZZ(1)/ZZ(2) * (1 + eps_dict[j] * QQ(2)**(-m_dict[j]))  for j in range(s_min, s_max+3)])
+    
+    #print "\nFinal Summary:"
+    #print "nu =", nu 
+    #print "q = ", q
+    #print "P = ", P
+    #print "E = ", E
+    
+    
+    ## Step 5: Compute the local mass for the prime 2.
+    mass_at_2 = QQ(2)**(nu - q) * P / E
+    return mass_at_2
+
+
+
+def Kitaoka_mass_at_2(self):
+    """
+    Returns the local mass of the quadratic form when p=2, according
+    to Theorem 5.6.3 on pp108--9 of Kitaoka's Book "The Arithmetic of
+    Quadratic Forms".
+
+    """
+    ## Make a 0-dim'l quadratic form (for initialization purposes)
+    Null_Form = copy.deepcopy(self)
+    Null_Form.__init__(ZZ, 0)
+
+    ## Step 0: Compute Jordan blocks and bounds of the scales to keep track of 
+    Jordan_Blocks = self.jordan_blocks_by_scale_and_unimodular(2)
+    scale_list = [B[0]  for B in Jordan_Blocks]
+    s_min = min(scale_list)
+    s_max = max(scale_list)
+        
+    ## Step 1: Compute dictonaries of the diagonal block and 2x2 block for each scale
+    diag_dict = dict((i, Null_Form)  for i in range(s_min-2, s_max + 4))     ## Initialize with the zero form
+    dim2_dict = dict((i, Null_Form)  for i in range(s_min, s_max + 4))       ## Initialize with the zero form
+    for (s,L) in Jordan_Blocks:
+        i = 0
+        while (i < L.dim()-1) and (L[i,i+1] == 0):      ## Find where the 2x2 blocks start
+            i = i + 1
+        if i < (L.dim() - 1):
+            diag_dict[s] = L.extract_variables(range(i))                ## Diagonal Form
+            dim2_dict[s+1] = L.extract_variables(range(i, L.dim()))     ## Non-diagonal Form    
+        else:
+            diag_dict[s] = L
+
+    #print "diag_dict = ", diag_dict
+    #print "dim2_dict = ", dim2_dict
+    #print "Jordan_Blocks = ", Jordan_Blocks
+
+
+    ##################  START EDITING HERE  ##################
+
+    ## Compute q := sum of the q_j
+    q = 0
+    for j in range(s_min, s_max + 1):
+        if diag_dict[j].dim() > 0:               ## Check that N_j is odd (i.e. rep'ns an odd #)
+            if diag_dict[j+1].dim() == 0:
+                q += Jordan_Blocks[j][1].dim()        ## When N_{j+1} is "even", add n_j
+            else:
+                q += Jordan_Blocks[j][1].dim() + 1    ## When N_{j+1} is "odd", add n_j + 1
+
+    ## Compute P = product of the P_j
+    P = QQ(1)
+    for j in range(s_min, s_max + 1):
+        tmp_m = dim2_dict[j].dim() / 2
+        P *= prod([QQ(1) - QQ(4**(-k))  for j in range(1, tmp_m + 1)])
+
+    ## Compute the product E := prod_j (1 / E_j)
+    E = QQ(1)
+    for j in range(s_min - 1, s_max + 2):
+        if (diag_dict[j-1].dim() == 0) and (diag_dict[j+1].dim() == 0) and \
+           ((diag_dict[j].dim() != 2) or (((diag_dict[j][0,0] - diag_dict[j][1,1]) % 4) != 0)):
+
+            ## Deal with the complicated case:
+            tmp_m = dim2_dict[j].dim() / 2
+            if dim2_dict[j].is_hyperbolic():
+                E *= 2 / (1 + 2**(-tmp_m))
+            else:
+                E *= 2 / (1 - 2**(-tmp_m)) 
+
+        else:
+            E *= 2 
+
+    ## DIAGNOSTIC    
+    #print "\nFinal Summary:"
+    #print "nu =", nu 
+    #print "q = ", q
+    #print "P = ", P
+    #print "E = ", E
+
+    ## Compute the exponent w
+    w = QQ(0)
+    for j in range(s_min, s_max+1):
+        n_j = Jordan_Blocks[j][1].dim()
+        for k in range(j+1, s_max+1):
+            n_k = Jordan_Blocks[k][1].dim()            
+            w += j * n_j * (n_k + QQ(n_j + 1) / 2)
+    
+    
+    ## Step 5: Compute the local mass for the prime 2.
+    mass_at_2 = (QQ(2)**(w - q)) * P * E
+    return mass_at_2
+        
+        
+def mass_at_two_by_counting_mod_power(self, k):
+    """
+    Computes the local mass at p=2 assuming that it's stable (mod 2^k).
+
+    Note: This is **way** too slow to be useful, even when k=1!!!
+    """
+    R = IntegerModRing(2**k)
+    Q1 = self.base_change_to(R)
+    n = self.dim()
+    MS = MatrixSpace(R, n)
+    
+    ct = sum([1  for x in mrange([2**k] * (n**2))  if Q1(MS(x)) == Q1])   ## Count the solutions mod 2^k
+    two_mass = ZZ(1)/2 * (ZZ(ct) / ZZ(2)**(k*n*(n-1)/2))
+    return two_mass 
+    
\ No newline at end of file
diff --git a/sage/quadratic_forms/quadratic_form__neighbors.py b/sage/quadratic_forms/quadratic_form__neighbors.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__neighbors.py
@@ -0,0 +1,249 @@
+
+from sage.modules.free_module_element import vector
+from sage.quadratic_forms.extras import random_int_upto
+from sage.rings.integer_ring import ZZ
+from copy import deepcopy
+from sage.quadratic_forms.extras import extend_to_primitive
+from sage.matrix.constructor import matrix
+#from sage.quadratic_forms.quadratic_form import QuadraticForm    ## This creates a circular import! =(
+
+
+####################################################################################
+## Routines used for understanding p-neighbors, and computing classes in a genus. ##
+####################################################################################
+
+
+def find_primitive_p_divisible_vector__random(self, p):
+    """
+    Finds a random p-primitive vector in L/pL whose value is p-divisible.
+
+    Note: Since there are about p^(n-2) of these lines, we have a 1/p chance
+        of randomly finding an appropriate vector.
+
+    WARNING: If there are local obstructions for this to happen, then
+        this algorithm will never terminate... =(  We should check for
+        this too!
+
+    EXAMPLES:
+        sage: Q = QuadraticForm(ZZ, 2, [10,1,4])
+        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
+        (1, 1)
+        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
+        (1, 0)
+        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
+        (2, 0)
+        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
+        (2, 2)
+        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
+        (3, 3)
+        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
+        (3, 3)
+        sage: Q.find_primitive_p_divisible_vector__random(5)    # random
+        (2, 0)
+
+    """
+    n = self.dim()
+    v = vector([ZZ(random_int_upto(p))  for i in range(n)])
+
+    ## Repeatedly choose random vectors, and evaluate until the value is p-divisible.
+    while True:
+        if (self(v) % p == 0) and (v != 0):         
+            return v
+        else: 
+            v[random_int_upto(n)] = ZZ(random_int_upto(p))      ## Replace a random entry and try again.
+
+
+
+
+def find_primitive_p_divisible_vector__all(self, p):
+    """
+    Finds all random p-primitive vectors (up to scaling) in L/pL whose
+    value is p-divisible.
+
+    Note: Since there are about p^(n-2) of these lines, we should avoid this for large n.
+    """
+    pass
+
+
+def find_primitive_p_divisible_vector__next(self, p, v=None):
+    """
+    Finds the next p-primitive vector (up to scaling) in L/pL whose
+    value is p-divisible, where the last vector returned was v.  For
+    an intial call, no v needs to be passed.
+
+    Returns vectors whose last non-zero entry is normalized to 0 or 1 (so no
+    lines are counted repeatedly).  The ordering is by increasing the
+    first non-normalized entry.  If we have tested all (lines of)
+    vectors, then return None.
+
+    OUTPUT:
+        vector or None
+
+    EXAMPLES:
+        sage: Q = QuadraticForm(ZZ, 2, [10,1,4])
+        sage: v = Q.find_primitive_p_divisible_vector__next(5); v
+        (1, 1)
+        sage: v = Q.find_primitive_p_divisible_vector__next(5, v); v
+        (1, 0)
+        sage: v = Q.find_primitive_p_divisible_vector__next(5, v); v
+
+
+    """
+    ## Initialize 
+    n = self.dim()
+    if v == None:
+        w = vector([ZZ(0) for i in range(n-1)] + [ZZ(1)])
+    else:
+        w = deepcopy(v)
+
+
+    ## Handle n = 1 separately.
+    if n <= 1:
+        raise RuntimeError, "Sorry -- Not implemented yet!"
+
+
+    ## Look for the last non-zero entry (which must be 1)
+    nz = n - 1
+    while w[nz] == 0:
+        nz += -1
+
+    ## Test that the last non-zero entry is 1 (to detect tampering).
+    if w[nz] != 1:
+        print "Warning: The input vector to QuadraticForm.find_primitive_p_divisible_vector__next() is not normalized properly."
+
+
+
+    ## Look for the next vector, until w == 0
+    while True:
+
+
+        ## Look for the first non-maximal (non-normalized) entry
+        ind = 0
+        while (ind < nz) and (w[ind] == p-1):
+            ind += 1
+
+        #print ind, nz, w
+
+        ## Increment 
+        if (ind < nz):
+            w[ind] += 1
+            for j in range(ind):
+                w[j] = 0        
+        else:  
+            for j in range(ind+1):    ## Clear all entries
+                w[j] = 0        
+
+            if nz != 0:               ## Move the non-zero normalized index over by one, or return the zero vector
+                w[nz-1] = 1
+                nz += -1
+
+
+        ## Test for zero vector
+        if w == 0:
+            return None
+
+        ## Test for p-divisibility
+        if (self(w) % p == 0):
+            return w
+
+
+
+
+## ----------------------------------------------------------------------------------------------
+
+def find_p_neighbor_from_vec(self, p, v):
+    """
+    Finds the p-neighbor of this quadratic form associated to a given
+    vector v satisfying:
+        a) Q(v) = 0  (mod p)
+        b) v is a non-singular point of the conic Q(v) = 0 (mod p).
+
+    Reference:  Gonzalo Tornaria's Thesis, Thrm 3.5, p34.
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ,[1,1,1,1])
+        sage: v = vector([0,2,1,1])
+        sage: X = Q.find_p_neighbor_from_vec(3,v); X
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 3 10 0 -4 ]
+        [ * 9 0 -6 ]
+        [ * * 1 0 ]
+        [ * * * 2 ]
+
+    """
+    R = self.base_ring()
+    n = self.dim()
+    B2 = self.matrix()
+
+    ## Find a (dual) vector w with B(v,w) != 0 (mod p)
+    v_dual = B2 * vector(v)     ## We want the dot product with this to not be divisible by 2*p.
+    y_ind = 0
+    while ((y_ind < n) and (v_dual[y_ind] % p) == 0):   ## Check the dot product for the std basis vectors!
+        y_ind += 1
+    if y_ind == n:
+        raise RuntimeError, "Oops!  One of the standard basis vectors should have worked."
+    w = vector([R(i == y_ind)  for i in range(n)])
+    vw_prod = (v * self.matrix()).dot_product(w)
+
+    ## DIAGNOSTIC
+    #if vw_prod == 0:
+    #   print "v = ", v
+    #   print "v_dual = ", v_dual
+    #   print "v_dual[y_ind] = ", v_dual[y_ind]
+    #   print "(v_dual[y_ind] % p) = ", (v_dual[y_ind] % p)
+    #   print "w = ", w
+    #   print "p = ", p
+    #   print "vw_prod = ", vw_prod
+    #   raise RuntimeError, "ERROR: Why is vw_prod = 0?"
+
+    ## DIAGNOSTIC
+    #print "v = ", v
+    #print "w = ", w
+    #print "vw_prod = ", vw_prod
+
+
+    ## Lift the vector v to a vector v1 s.t. Q(v1) = 0 (mod p^2)
+    s = self(v)
+    if (s % p**2 != 0):
+        al = (-s / (p * vw_prod)) % p
+        v1 = v + p * al * w
+        v1w_prod = (v1 * self.matrix()).dot_product(w)
+    else:
+        v1 = v
+        v1w_prod = vw_prod
+
+    ## DIAGNOSTIC
+    #if (s % p**2 != 0):
+    #    print "al = ", al
+    #print "v1 = ", v1
+    #print "v1w_prod = ", v1w_prod
+
+
+    ## Construct a special p-divisible basis to use for the p-neighbor switch
+    good_basis = extend_to_primitive([v1, w])
+    for i in range(2,n):
+        ith_prod = (good_basis[i] * self.matrix()).dot_product(v)
+        c = (ith_prod / v1w_prod) % p
+        good_basis[i] = good_basis[i] - c * w  ## Ensures that this extenstion has <v_i, v> = 0 (mod p)
+
+    ## DIAGNOSTIC
+    #print "original good_basis = ", good_basis
+
+    ## Perform the p-neighbor switch
+    good_basis[0]  = vector([x/p  for x in good_basis[0]])    ## Divide v1 by p
+    good_basis[1]  = good_basis[1] * p                          ## Multiply w by p
+
+    ## Return the associated quadratic form
+    M = matrix(good_basis)
+    new_Q = deepcopy(self)                        ## Note: This avoids a circular import of QuadraticForm!
+    new_Q.__init__(R, M * self.matrix() * M.transpose())
+    return new_Q
+    return QuadraticForm(R, M * self.matrix() * M.transpose())
+
+
+## ----------------------------------------------------------------------------------------------
+
+
+#def find_classes_in_genus(self):
+
+
diff --git a/sage/quadratic_forms/quadratic_form__reduction_theory.py b/sage/quadratic_forms/quadratic_form__reduction_theory.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__reduction_theory.py
@@ -0,0 +1,435 @@
+
+from copy import deepcopy
+from sage.matrix.constructor import matrix
+from sage.calculus.calculus import floor
+from sage.misc.mrange import mrange
+from sage.modules.free_module_element import vector
+from sage.rings.integer_ring import ZZ
+
+
+def reduced_binary_form(self):
+    """
+    Reduce the form ax^2 + bxy+cy^2 to satisfy the reduced condition
+        |b| <= a <= c, with b >= 0 if a = c. 
+    This reduction occurs within the proper class, so all
+    transformations are taken to have det = 1.
+
+    """
+    if self.dim() != 2:
+        raise TypeError, "This must be a binary form for now..."
+
+    R = self.base_ring()
+    interior_reduced_flag = False
+    Q = deepcopy(self)
+    M = matrix(R, 2, 2, [1,0,0,1])
+
+    while (interior_reduced_flag == False):
+        interior_reduced_flag = True
+
+        ## Arrange for a <= c
+        if Q[0,0] > Q[1,1]:
+            M_new = matrix(R,2,2,[0, -1, 1, 0]) 
+            Q = Q(M_new)
+            M = M * M_new
+            interior_reduced_flag = False
+            #print "A"
+
+        ## Arrange for |b| <= a
+        if abs(Q[0,1]) > Q[0,0]:
+            r = R(floor(round(Q[0,1]/(2*Q[0,0]))))
+            M_new = matrix(R,2,2,[1, -r, 0, 1])
+            Q = Q(M_new)
+            M = M * M_new
+            interior_reduced_flag = False
+            #print "B"
+
+    return Q, M
+
+
+
+
+def reduced_ternary_form__Dickson(self):
+    """
+    Find the unique reduced ternary form according to the conditions
+    of Dickson's "Studies in the Theory of Numbers", pp164-171.
+
+        [a f e]
+        [. b d]
+        [. . c]
+
+    """
+    pass
+
+
+
+def reduced_binary_form(self):
+    """
+    Find a form which is reduced in the sense that no further binary
+    form reductions can be done to reduce the original form.
+    """
+    R = self.base_ring()
+    n = self.dim()
+    interior_reduced_flag = False
+    Q = deepcopy(self)
+    M = matrix(R, n, n)
+    for i in range(n):
+        M[i,i] = 1
+
+
+    while (interior_reduced_flag == False):
+        interior_reduced_flag = True
+
+        print Q
+
+        ## Arrange for (weakly) increasing diagonal entries
+        for i in range(n):
+            for j in range(i+1,n):
+                if Q[i,i] > Q[j,j]:
+                    M_new = matrix(R,n,n)
+                    for k in range(n):
+                        M_new[k,k] = 1
+                    M_new[i,j] = -1
+                    M_new[j,i] = 1
+                    M_new[i,i] = 0
+                    M_new[j,j] = 1
+ 
+                    Q = Q(M_new)
+                    M = M * M_new
+                    interior_reduced_flag = False
+                    #print "A"
+
+                ## Arrange for |b| <= a
+                if abs(Q[i,j]) > Q[i,i]:
+                    r = R(floor(round(Q[i,j]/(2*Q[i,i]))))
+
+                    M_new = matrix(R,n,n)
+                    for k in range(n):
+                        M_new[k,k] = 1
+                    M_new[i,j] = -r
+
+                    Q = Q(M_new)
+                    M = M * M_new
+                    interior_reduced_flag = False
+                    #print "B"
+
+    return Q, M
+
+    
+def minkowski_reduction(self):
+    """
+    Find a Minkowski-reduced form equivalent to the given one.  
+    This means that
+    
+        Q(v_k) <= Q(s_1 * v_1 + ... + s_n * v_n) 
+
+    for all s_i where GCD(s_k, ... s_n) = 1.
+
+    Note: When Q has dim <= 4 we can take all s_i in {1, 0, -1}.
+
+    References: 
+        Schulze-Pillot's paper on "An algorithm for computing genera
+            of ternary and quaternary quadratic forms", p138.
+        Donaldson's 1979 paper "Minkowski Reduction of Integral
+            Matrices", p203.
+
+    EXAMPLES:
+        sage: Q = QuadraticForm(ZZ,4,[30,17,11,12,29,25,62,64,25,110])
+        sage: Q
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 30 17 11 12 ]
+        [ * 29 25 62 ]
+        [ * * 64 25 ]
+        [ * * * 110 ]
+        sage: Q.minkowski_reduction()
+        (Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 30 17 11 -5 ]
+        [ * 29 25 4 ]
+        [ * * 64 0 ]
+        [ * * * 77 ]
+        ,
+         [ 1  0  0  0]
+        [ 0  1  0 -1]
+        [ 0  0  1  0]
+        [ 0  0  0  1])
+
+    """
+    R = self.base_ring()
+    n = self.dim()
+    interior_reduced_flag = False
+    Q = deepcopy(self)
+    M = matrix(R, n, n)
+    for i in range(n):
+        M[i,i] = 1
+
+
+    ## Begin the reduction
+    done_flag = False
+    while done_flag == False:
+
+        ## Loop through possible shorted vectors until 
+        done_flag = True
+        #print " j_range = ", range(n-1, -1, -1)
+        for j in range(n-1, -1, -1):
+            for a_first in mrange([2  for i in range(j)]):
+                y = [x-1 for x in a_first] + [1] + [0 for k in range(n-1-j)]
+                e_j = [0  for k in range(n)]
+                e_j[j] = 1
+                #print "j = ", j
+        
+                ## Reduce if a shorter vector is found
+                #print "y = ", y, "   e_j = ", e_j, "\n"
+                if Q(y) < Q(e_j): 
+
+                    ## Create the transformation matrix
+                    M_new = matrix(R, n, n)
+                    for k in range(n):
+                        M_new[k,k] = 1
+                    for k in range(n):
+                        M_new[k,j] = y[k]
+
+                    ## Perform the reduction and restart the loop
+                    #print "Q_before = ", Q
+                    Q = Q(M_new)
+                    M = M * M_new
+                    done_flag = False
+
+                    ## DIAGNOSTIC
+                    #print "Q(y) = ", Q(y)
+                    #print "Q(e_j) = ", Q(e_j)
+                    #print "M_new = ", M_new
+                    #print "Q_after = ", Q
+                    #print
+
+                if not done_flag:
+                    break
+
+            if not done_flag:
+                break
+
+    ## Return the results
+    return Q, M 
+
+
+
+
+def minkowski_reduction_for_4vars__SP(self):
+    """
+    Find a Minkowski-reduced form equivalent to the given one.  
+    This means that
+    
+        Q(v_k) <= Q(s_1 * v_1 + ... + s_n * v_n) 
+
+    for all s_i where GCD(s_k, ... s_n) = 1.
+
+    Note: When Q has dim <= 4 we can take all s_i in {1, 0, -1}.
+
+    References: 
+        Schulze-Pillot's paper on "An algorithm for computing genera
+            of ternary and quaternary quadratic forms", p138.
+        Donaldson's 1979 paper "Minkowski Reduction of Integral
+            Matrices", p203.
+
+    EXAMPLES:
+        sage: Q = QuadraticForm(ZZ,4,[30,17,11,12,29,25,62,64,25,110])
+        sage: Q
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 30 17 11 12 ]
+        [ * 29 25 62 ]
+        [ * * 64 25 ]
+        [ * * * 110 ]
+        sage: Q.minkowski_reduction_for_4vars__SP()
+        (Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 29 -17 25 4 ]
+        [ * 30 -11 5 ]
+        [ * * 64 0 ]
+        [ * * * 77 ]
+        ,
+         [ 0  1  0  0]
+        [ 1  0  0 -1]
+        [ 0  0  1  0]
+        [ 0  0  0  1])
+
+    """
+    R = self.base_ring()
+    n = self.dim()
+    interior_reduced_flag = False
+    Q = deepcopy(self)
+    M = matrix(R, n, n)
+    for i in range(n):
+        M[i,i] = 1
+
+    ## Only allow 4-variable forms
+    if n != 4:
+        raise TypeError, "Oops!  The given quadratic form has " + str(n) +  \
+                " != 4 variables. =|"
+
+
+    ## Step 1: Begin the reduction
+    done_flag = False
+    while done_flag == False:
+
+        ## Loop through possible shorter vectors 
+        done_flag = True
+        #print " j_range = ", range(n-1, -1, -1)
+        for j in range(n-1, -1, -1):
+            for a_first in mrange([2  for i in range(j)]):
+                y = [x-1 for x in a_first] + [1] + [0 for k in range(n-1-j)]
+                e_j = [0  for k in range(n)]
+                e_j[j] = 1
+                #print "j = ", j
+        
+                ## Reduce if a shorter vector is found
+                #print "y = ", y, "   e_j = ", e_j, "\n"
+                if Q(y) < Q(e_j): 
+
+                    ## Further n=4 computations
+                    B_y_vec = Q.matrix() * vector(ZZ, y)
+                        ## SP's B = our self.matrix()/2
+                        ## SP's A = coeff matrix of his B
+                        ## Here we compute the double of both and compare.
+                    B_sum = sum([abs(B_y_vec[i])  for i in range(4)  if i != j])
+                    A_sum = sum([abs(Q[i,j])  for i in range(4)  if i != j])
+                    B_max = max([abs(B_y_vec[i])  for i in range(4)  if i != j])
+                    A_max = max([abs(Q[i,j])  for i in range(4)  if i != j])
+
+                    if (B_sum < A_sum) or ((B_sum == A_sum) and (B_max < A_max)):
+
+                        ## Create the transformation matrix
+                        M_new = matrix(R, n, n)
+                        for k in range(n):
+                            M_new[k,k] = 1
+                        for k in range(n):
+                            M_new[k,j] = y[k]
+
+                        ## Perform the reduction and restart the loop
+                        #print "Q_before = ", Q
+                        Q = Q(M_new)
+                        M = M * M_new
+                        done_flag = False
+
+                        ## DIAGNOSTIC
+                        #print "Q(y) = ", Q(y)
+                        #print "Q(e_j) = ", Q(e_j)
+                        #print "M_new = ", M_new
+                        #print "Q_after = ", Q
+                        #print
+
+                if not done_flag:
+                    break
+
+            if not done_flag:
+                break
+
+    ## Step 2: Order A by certain criteria
+    for i in range(4):
+        for j in range(i+1,4):
+
+            ## Condition (a)
+            if (Q[i,i] > Q[j,j]):
+                Q.swap_variables(i,j,in_place=True)
+                M_new = matrix(R,n,n)
+                M_new[i,j] = -1
+                M_new[j,i] = 1
+                for r in range(4):
+                    if (r == i) or (r == j):
+                        M_new[r,r] = 0
+                    else:
+                        M_new[r,r] = 1
+                M = M * M_new
+
+            elif (Q[i,i] == Q[j,j]):
+                i_sum = sum([abs(Q[i,k])  for k in range(4)  if k != i])
+                j_sum = sum([abs(Q[j,k])  for k in range(4)  if k != j])
+
+                ## Condition (b)
+                if (i_sum > j_sum):
+                    Q.swap_variables(i,j,in_place=True)
+                    M_new = matrix(R,n,n)
+                    M_new[i,j] = -1
+                    M_new[j,i] = 1
+                    for r in range(4):
+                        if (r == i) or (r == j):
+                            M_new[r,r] = 0
+                        else:
+                            M_new[r,r] = 1
+                    M = M * M_new
+
+                elif (i_sum == j_sum):
+                    for k in [2,1,0]:   ## TO DO: These steps are a little redundant...
+                        Q1 = Q.matrix()
+                        
+                        c_flag = True
+                        for l in range(k+1,4):
+                            c_flag = c_flag and (abs(Q1[i,l]) == abs(Q1[j,l]))
+
+                        ## Condition (c)
+                        if c_flag and (abs(Q1[i,k]) > abs(Q1[j,k])):    
+                            Q.swap_variables(i,j,in_place=True)
+                            M_new = matrix(R,n,n)
+                            M_new[i,j] = -1
+                            M_new[j,i] = 1
+                            for r in range(4):
+                                if (r == i) or (r == j):
+                                    M_new[r,r] = 0
+                                else:
+                                    M_new[r,r] = 1
+                            M = M * M_new
+
+
+    ## Step 3: Order the signs
+    for i in range(4):
+        if Q[i,3] < 0:
+            Q.multiply_variable(-1, i, in_place=True)
+            M_new = matrix(R,n,n)
+            for r in range(4):
+                if r == i:
+                    M_new[r,r] = -1
+                else:
+                    M_new[r,r] = 1
+            M = M * M_new
+
+    for i in range(4):
+        j = 3
+        while (Q[i,j] == 0): 
+            j += -1
+        if (Q[i,j] < 0):
+            Q.multiply_variable(-1, i, in_place=True)
+            M_new = matrix(R,n,n)
+            for r in range(4):
+                if r == i:
+                    M_new[r,r] = -1
+                else:
+                    M_new[r,r] = 1
+            M = M * M_new
+
+    if Q[1,2] < 0:
+        ## Test a row 1 sign change
+        if (Q[1,3] <= 0 and \
+            ((Q[1,3] < 0) or (Q[1,3] == 0 and Q[1,2] < 0)  \
+                or (Q[1,3] == 0 and Q[1,2] == 0 and Q[1,1] < 0))):
+            Q.multiply_variable(-1, i, in_place=True)       
+            M_new = matrix(R,n,n)
+            for r in range(4):
+                if r == i:
+                    M_new[r,r] = -1
+                else:
+                    M_new[r,r] = 1
+            M = M * M_new
+
+        elif (Q[2,3] <= 0 and \
+            ((Q[2,3] < 0) or (Q[2,3] == 0 and Q[2,2] < 0)  \
+                or (Q[2,3] == 0 and Q[2,2] == 0 and Q[2,1] < 0))):
+            Q.multiply_variable(-1, i, in_place=True)       
+            M_new = matrix(R,n,n)
+            for r in range(4):
+                if r == i:
+                    M_new[r,r] = -1
+                else:
+                    M_new[r,r] = 1
+            M = M * M_new
+
+        
+    ## Return the results
+    return Q, M 
+
+
diff --git a/sage/quadratic_forms/quadratic_form__siegel_product.py b/sage/quadratic_forms/quadratic_form__siegel_product.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__siegel_product.py
@@ -0,0 +1,212 @@
+
+
+from sage.algebras.quaternion_algebra import fundamental_discriminant
+from sage.rings.integer_ring import ZZ
+from sage.rings.rational_field import QQ
+from sage.rings.arith import kronecker_symbol, bernoulli, prime_divisors
+#from sage.combinat.combinat import bernoulli_polynomial
+from sage.calculus.calculus import sqrt
+#from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
+from sage.misc.functional import ideal
+from sage.quadratic_forms.special_values import QuadraticBernoulliNumber
+
+from sage.misc.misc import verbose
+
+
+
+#/*!  \brief Computes the product of all local densities for comparison with independently computed Eisenstein coefficients.
+# *
+# *  \todo We fixed the generic factors to compensate for using tha matrix of 2Q, but we need to document this better! =) 
+# */
+
+#/////////////////////////////////////////////////////////////////
+#/// 
+#/////////////////////////////////////////////////////////////////
+
+#mpq_class Matrix_mpz::siegel_product(mpz_class u) const {
+
+def siegel_product(self, u):
+    """
+    Computes the infinite product of local densities of the quadratic
+    form for the number u.
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+        sage: Q.theta_by_cholesky(10)
+        1 + 8*q + 24*q^2 + 32*q^3 + 24*q^4 + 48*q^5 + 96*q^6 + 64*q^7 + 24*q^8 + 104*q^9 + 144*q^10
+
+        sage: Q.siegel_product(1)
+        8
+        sage: Q.siegel_product(2)      ## This one is wrong -- expect 24, and the higher powers of 2 don't work... =(
+        24
+        sage: Q.siegel_product(3)
+        32
+        sage: Q.siegel_product(5)
+        48
+        sage: Q.siegel_product(6)
+        96
+        sage: Q.siegel_product(7)
+        64
+        sage: Q.siegel_product(9)
+        104
+
+        sage: Q.local_density(2,1)    ## This is ok
+        1
+        sage: M = 8; len([v  for v in mrange([M,M,M,M])  if Q(v) % M == 1]) / M^3
+        1
+        sage: M = 16; len([v  for v in mrange([M,M,M,M])  if Q(v) % M == 1]) / M^3     ## long time
+        1
+
+        sage: Q.local_density(2,2)    ## This is ok now. =)
+        3/2
+        sage: M = 8; len([v  for v in mrange([M,M,M,M])  if Q(v) % M == 2]) / M^3
+        3/2
+        sage: M = 16; len([v  for v in mrange([M,M,M,M])  if Q(v) % M == 2]) / M^3     ## long time
+        3/2
+
+        sage: [1] + [Q.siegel_product(ZZ(a))  for a in range(1,11)] == Q.theta_by_cholesky(10).list()
+        True
+
+    """
+    ## Protect u (since it fails often if it's an just an int!)
+    u = ZZ(u)
+
+    n = self.dim()
+    d = self.det()       ## ??? Warning: This is a factor of 2^n larger than it should be!
+
+    ## DIAGNOSTIC
+    verbose("n = " + str(n))
+    verbose("d = " + str(d))
+    verbose("In siegel_product:  d = ", d, "\n");
+
+
+    ## Product of "bad" places to omit
+    S = 2 * d * u
+
+    ## DIAGNOSTIC
+    verbose("siegel_product Break 1. \n")
+    verbose(" u = ", u, "\n")
+
+
+    ## Make the odd generic factors
+    if ((n % 2) == 1):
+        m = (n-1) / 2
+        d1 = fundamental_discriminant(((-1)**m) * 2*d * u)     ## Replaced d by 2d here to compensate for the determinant 
+        f = abs(d1)                                            ## gaining an odd power of 2 by using the matrix of 2Q instead 
+                                                               ## of the matrix of Q.
+                                                               ##  --> Old d1 = CoreDiscriminant((mpz_class(-1)^m) * d * u);      
+
+        ## Make the ratio of factorials factor: [(2m)! / m!] * prod_{i=1}^m (2*i-1)
+        factor1 = 1
+        for i in range(1, m+1):
+            factor1 *= 2*i - 1
+        for i in range(m+1, 2*m + 1):
+            factor1 *= i
+    
+        genericfactor = factor1 * ((u / f) ** m) \
+            * QQ(sqrt((2 ** n) *  f) / (u * d)) \
+            * abs(QuadraticBernoulliNumber(m, d1) / bernoulli(2*m))
+
+
+
+    ## DIAGNOSTIC
+    verbose("siegel_product Break 2. \n")
+
+
+    ## Make the even generic factor
+    if ((n % 2) == 0):
+        m = n / 2
+        d1 = fundamental_discriminant(((-1)**m) * d)  
+        f = abs(d1)                                
+
+        ## DIAGNOSTIC
+        #cout << " mpz_class(-1)^m = " << (mpz_class(-1)^m) << " and d = " << d << endl;
+        #cout << " f = " << f << " and d1 = " << d1 << endl;
+
+
+        genericfactor = m / QQ(sqrt(f*d)) \
+            * ((u/2) ** (m-1)) * (f ** m) \
+            / abs(QuadraticBernoulliNumber(m, d1)) \
+            * (2 ** m)                                               ## This last factor compensates for using the matrix of 2*Q
+
+
+    ##return genericfactor
+  
+  
+    ## Omit the generic factors in S and compute them separately
+    omit = 1
+    include = 1
+  
+    S_divisors = prime_divisors(S)
+
+    ## DIAGNOSTIC
+    #cout << "\n S is " << S << endl;
+    #cout << " The Prime divisors of S are :";
+    #PrintV(S_divisors);
+
+
+    for p in S_divisors:    
+        Q_normal = self.local_normal_form(p)
+    
+
+        ## DIAGNOSTIC
+        verbose(" p = " + str(p) + " and its Kronecker symbol (d1/p) = (" + str(d1) + "/" + str(p) + ") is " + str(kronecker_symbol(d1, p)) + "\n")
+
+        omit *= 1 / (1 - (kronecker_symbol(d1, p) / (p**m))) 
+
+
+        ## DIAGNOSTIC
+        verbose(" omit = " + str(omit) + "\n")
+        verbose(" Q_normal is \n" + str(Q_normal) + "\n")
+        verbose(" Q_normal = \n" + str(Q_normal))
+        verbose(" p = " + str(p) + "\n")
+        verbose(" u = " +str(u) + "\n")
+        verbose(" include = " + str(include) + "\n")
+
+
+        include *= Q_normal.local_density(p, u)
+
+
+        ## DIAGNOSTIC
+        #cout << " Including the p = " << p << " factor: " << local_density(Q_normal, p, u) << endl; 
+
+        ## DIAGNSOTIC
+        verbose("    ---  Exiting loop \n")
+
+
+
+
+    #// ****************  Important *******************
+    #// Additional fix (only included for n=4) to deal 
+    #// with the power of 2 introduced at the real place 
+    #// by working with Q instead of 2*Q.  This needs to 
+    #// be done for all other n as well... 
+    #/*
+    #if (n==4) 
+    #  genericfactor = 4 * genericfactor;
+    #*/
+
+
+    ## DIAGNSOTIC
+    #cout << endl;
+    #cout << " generic factor = " << genericfactor << endl;
+    #cout << " omit = " << omit << endl;
+    #cout << " include = " << include << endl;
+    #cout << endl;
+
+
+    ## DIAGNSOTIC
+    #//  cout << "siegel_product Break 3. " << endl;
+
+
+    ## Return the final factor (and divide by 2 if n=2)
+    if (n == 2): 
+        return (genericfactor * omit * include / 2)
+    else:
+        return (genericfactor * omit * include)
+
+
+  
+
+
+
diff --git a/sage/quadratic_forms/quadratic_form__split_local_covering.py b/sage/quadratic_forms/quadratic_form__split_local_covering.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__split_local_covering.py
@@ -0,0 +1,318 @@
+
+#########################################################################
+## Routines that look for a split local covering for a given quadratic ##
+## form in 4 variables.                                                ##
+#########################################################################
+
+from copy import deepcopy
+
+from sage.quadratic_forms.extras import extend_to_primitive
+from sage.quadratic_forms.quadratic_form import QuadraticForm__constructor, is_QuadraticForm
+
+from sage.rings.real_double import RDF
+from sage.matrix.matrix_space import MatrixSpace
+#from sage.matrix.matrix import Matrix
+from sage.matrix.constructor import matrix
+from sage.calculus.calculus import sqrt, floor, ceil
+from sage.rings.integer_ring import ZZ
+from sage.rings.rational_field import QQ
+from sage.misc.functional import round
+from sage.rings.arith import GCD
+
+
+def vectors_by_length(self, bound):
+    """
+    Returns a list of short vectors together with their values.  
+
+    This is a maive algorithm which uses the Cholesky decomposition,
+    but does not use the LLL-reduction algorithm.
+
+    OUTPUT:
+        A list L of length (bound + 1) whose entry L[i] is a list of
+        all vectors of length i.
+
+    Reference: This is a slightly modified version of Cohn's Algorithm
+    2.7.5 in "A Course in Compuational Number Theory", with the
+    increment step moved around and slightly reindexed to allow clean
+    looping.
+
+    Note: We could speed this up for very skew matrices by using LLL
+    first, and then changing coordinates back, but for our purposes
+    the simpler method is efficient enough. =)
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1])
+        sage: Q.vectors_by_length(5)
+        [[[0, 0]],
+         [[0, -1], [-1, 0]],
+         [[-1, -1], [1, -1]],
+         [],
+         [[0, -2], [-2, 0]],
+         [[-1, -2], [1, -2], [-2, -1], [2, -1]]]
+
+        sage: Q1 = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+        sage: Q1.vectors_by_length(5)
+        [[[0, 0, 0, 0]],
+         [[-1, 0, 0, 0]],
+         [],
+         [[0, -1, 0, 0]],
+         [[-1, -1, 0, 0], [1, -1, 0, 0], [-2, 0, 0, 0]],
+         [[0, 0, -1, 0]]]
+
+    """
+    Theta_Precision = bound               ## Unsigned long
+    n = self.dim()
+
+    ## Make the vector of vectors which have a given value
+    ## (So theta_vec[i] will have all vectors v with Q(v) = i.)
+    empty_vec_list = [[] for i in range(Theta_Precision + 1)]
+    theta_vec = [[] for i in range(Theta_Precision + 1)]
+
+    ## Initialize Q with zeros and Copy the Cholesky array into Q
+    Q = self.cholesky_decomposition()
+
+
+    ## 1. Initialize
+    T = n * [RDF(0)]    ## Note: We index the entries as 0 --> n-1
+    U = n * [RDF(0)]
+    i = n-1
+    T[i] = RDF(Theta_Precision)
+    U[i] = RDF(0)
+
+    L = n * [0]
+    x = n * [0]
+    Z = RDF(0)
+
+    ## 2. Compute bounds
+    Z = sqrt(T[i] / Q[i][i])
+    L[i] = ZZ(floor(Z - U[i]))
+    x[i] = ZZ(ceil(-Z - U[i]) - 0)
+
+    done_flag = False
+    Q_val_double = RDF(0)
+    Q_val = 0 ## WARNING: Still need a good way of checking overflow for this value...
+
+    ## Big loop which runs through all vectors
+    while not done_flag:
+
+        ## 3b. Main loop -- try to generate a complete vector x (when i=0)
+        while (i > 0):
+            #print " i = ", i 
+            #print " T[i] = ", T[i] 
+            #print " Q[i][i] = ", Q[i][i] 
+            #print " x[i] = ", x[i] 
+            #print " U[i] = ", U[i] 
+            #print " x[i] + U[i] = ", (x[i] + U[i]) 
+            #print " T[i-1] = ", T[i-1] 
+                
+            T[i-1] = T[i] - Q[i][i] * (x[i] + U[i]) * (x[i] + U[i])
+                
+            #print " T[i-1] = ",  T[i-1]
+            #print " x = ", x
+            #print
+                
+            i = i - 1
+            U[i] = 0
+            for j in range(i+1, n):
+                U[i] = U[i] + Q[i][j] * x[j]
+
+            ## Now go back and compute the bounds...
+            ## 2. Compute bounds
+            Z = sqrt(T[i] / Q[i][i])
+            L[i] = ZZ(floor(Z - U[i]))  
+            x[i] = ZZ(ceil(-Z - U[i]) - 0)  
+
+
+        ## 4. Solution found (This happens when i = 0)
+        #print "-- Solution found! --"
+        #print " x = ", x 
+        #print " Q_val = Q(x) = ", Q_val
+        Q_val_double = Theta_Precision - T[0] + Q[0][0] * (x[0] + U[0]) * (x[0] + U[0])
+        Q_val = ZZ(floor(round(Q_val_double)))
+
+        ## SANITY CHECK: Roundoff Error is < 0.001
+        if abs(Q_val_double -  Q_val) > 0.001:
+            print " x = ", x 
+            print " Float = ", Q_val_double, "   Long = ", Q_val
+            raise RuntimeError, "The roundoff error is bigger than 0.001, so we should use more precision somehwere..."
+
+        #print " Float = ", Q_val_double, "   Long = ", Q_val, "  XX "
+        #print " The float value is ", Q_val_double
+        #print " The associated long value is ", Q_val
+
+        if (Q_val <= Theta_Precision):
+            #print " Have vector ",  x, " with value ", Q_val
+            theta_vec[Q_val].append(deepcopy(x))
+        
+
+        ## 5. Check if x = 0, for exit condition. =)
+        j = 0
+        done_flag = True
+        while (j < n):
+            if (x[j] != 0):
+                done_flag = False
+            j += 1
+
+
+        ## 3a. Increment (and carry if we go out of bounds)
+        x[i] += 1
+        while (x[i] > L[i]) and (i < n-1):
+            i += 1
+            x[i] += 1
+
+
+    #print " Leaving ThetaVectors()"
+    return theta_vec
+
+
+
+
+def complementary_subform_to_vector(self, v):
+    """
+    Finds the (n-1)-dim'l quadratic form orthogonal to the vector v.  
+
+    Note: This is usually not a direct summand!
+
+    Technical Notes: There is a minor difference in the cancellation
+    code here (form the C++ version) since the notation Q[i,j] indexes
+    coefficients of the quadratic polynomial here, not the symmetric
+    matrix.  Also, it produces a better splitting now, for the full
+    lattice (as opposed to a sublattice in the C++ code) since we
+    now extend v to a unimodular matrix.
+
+    EXAMPLES:
+    sage: Q1 = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+    sage: Q1.complementary_subform_to_vector([1,0,0,0])
+    Quadratic form in 3 variables over Integer Ring with coefficients: 
+    [ 3 0 0 ]
+    [ * 5 0 ]
+    [ * * 7 ]
+
+    sage: Q1.complementary_subform_to_vector([1,1,0,0])
+    Quadratic form in 3 variables over Integer Ring with coefficients: 
+    [ 12 0 0 ]
+    [ * 5 0 ]
+    [ * * 7 ]
+
+    sage: Q1.complementary_subform_to_vector([1,1,1,1])
+    Quadratic form in 3 variables over Integer Ring with coefficients: 
+    [ 624 -480 -672 ]
+    [ * 880 -1120 ]
+    [ * * 1008 ]
+
+    """
+    n = self.dim()
+
+    ## Copy the quadratic form
+    Q = deepcopy(self)
+
+    ## Find the first non-zero component of v, and call it nz  (Note: 0 <= nz < n)
+    nz = 0
+    while (nz < n) and (v[nz] == 0):
+        nz += 1
+
+    ## Abort if v is the zero vector
+    if nz == n:
+        raise TypeError, "Oops, v cannot be the zero vector! =("
+
+    ## Make the change of basis matrix
+    new_basis = extend_to_primitive(matrix(ZZ,n,1,v))
+
+    ## Change Q (to Q1) to have v as its nz-th basis vector 
+    Q1 = Q(new_basis)
+     
+    ## Pick out the value Q(v) of the vector
+    d = Q1[0, 0]
+
+    #print Q1
+
+    ## For each row/column, perform elementary operations to cancel them out.
+    for i in range(1,n):
+
+        ## Check if the (i,0)-entry is divisible by d,
+        ## and stretch its row/column if not.
+        if Q1[i,0] % d != 0: 
+            Q1 = Q1.multiply_variable(d / GCD(d, Q1[i, 0]/2), i)
+
+        #print "After scaling at i =", i
+        #print Q1
+
+        ## Now perform the (symmetric) elementary operations to cancel out the (i,0) entries/
+        Q1 = Q1.add_symmetric(-(Q1[i,0]/2) / (GCD(d, Q1[i,0]/2)), i, 0)
+
+        #print "After cancelling at i =", i
+        #print Q1
+
+    ## Check that we're done!
+    done_flag = True
+    for i in range(1, n):
+        if Q1[0,i] != 0:
+            done_flag = False
+
+    if done_flag == False:
+        raise RuntimeError, "There is a problem cancelling out the matrix entries! =O"
+
+
+    ## Return the complementary matrix
+    return Q1.extract_variables(range(1,n))
+
+
+
+def split_local_cover(self):
+    """
+    Tries to find subform of the given (positive definite quaternary)
+    quadratic form Q of the form
+
+        d*x^2 + T(y,z,w)
+
+    where d > 0 is as small as possible.
+
+    This is done by exhaustive search on small vectors, and then
+    comparing the local conditions of its sum with it's complementary
+    lattice and the original quadratic form Q.
+
+    EXAMPLES:
+        sage: Q1 = DiagonalQuadraticForm(ZZ, [7,5,3])
+        sage: Q1.split_local_cover()
+        Quadratic form in 3 variables over Integer Ring with coefficients: 
+        [ 3 0 0 ]
+        [ * 7 0 ]
+        [ * * 5 ]
+
+    """
+    ## 0. If a split local cover already exists, then return it.
+    if hasattr(self, "__split_local_cover"):
+        if is_QuadraticForm(self.__split_local_cover):  ## Here the computation has been done.
+            return self.__split_local_cover
+        elif isinstance(self.__split_local_cover, Integer):    ## Here it indexes the values already tried!
+            current_length = self.__split_local_cover + 1
+            Length_Max = current_length + 5
+    else:
+        current_length = 1
+        Length_Max = 6
+
+    ## 1. Find a range of new vectors
+    all_vectors = self.vectors_by_length(Length_Max)
+    current_vectors = all_vectors[current_length]
+
+    ## Loop until we find a split local cover...
+    while True:
+
+        ## 2. Check if any of the primitive ones produce a split local cover
+        for v in current_vectors:
+            #print "current length = ", current_length
+            #print "v = ", v
+            Q = QuadraticForm__constructor(ZZ, 1, [current_length]) + self.complementary_subform_to_vector(v)
+            #print Q
+            if Q.local_representation_conditions() == self.local_representation_conditions():
+                self.__split_local_cover = Q
+                return Q
+
+        ## 3. Save what we have checked and get more vectors.
+        self.__split_local_cover = current_length
+        current_length += 1
+        if current_length >= len(all_vectors):
+            Length_Max += 5
+            all_vectors = self.vectors_by_length(Length_Max)
+        current_vectors = all_vectors[current_length]
+
diff --git a/sage/quadratic_forms/quadratic_form__ternary_Tornaria.py b/sage/quadratic_forms/quadratic_form__ternary_Tornaria.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__ternary_Tornaria.py
@@ -0,0 +1,285 @@
+
+######################################################################## 
+## Routines from Gonzalo Tornaria (7/9/07) 
+## for computing with ternary quadratic forms.
+#######################################################################
+
+
+#from sage.rings.rational_field import QQ
+
+from sage.rings.integer_ring import ZZ
+from sage.misc.functional import is_odd
+from sage.rings.power_series_ring import PowerSeriesRing
+
+from sage.libs.pari.all import pari
+from sage.misc.misc import prod
+from sage.rings.arith import factor
+
+
+## TO DO -- Add second argument
+#  def __call__(self,v,w=None):
+#    if w==None:
+#        return half(v * self._matrix_() * v) 
+#    else:
+#      return v * self._matrix_() * w
+
+
+
+def disc_Tornaria(self):
+    """
+    Returns the discriminant of the quadratc form, 
+    defined as 
+
+        det(B)      for even dimension
+        det(B)/2    for odd dimension
+
+    where 2Q(x) = x^t * B * x. 
+    """
+    if is_odd(self.dim()):
+      return  self.base_ring()(self.det() / 2)      ## This is not so good for characteristic 2.
+    else:
+      return self.det()
+
+
+#def content(self):
+#    """
+#    Returns the GCD of the coefficients fo the quadratic form.    
+#
+#    Warning: Only works over Euclidean domains... probably just ZZ. =|
+#    """
+#    return gcd(self.__coeffs)
+
+
+#def is_primitive(self):
+#    """
+#    Checks if the form is a multiple of another form... only over ZZ for now.
+#    """
+#    return self.content() == 1
+
+
+
+#def primitive(self):
+#    """
+#    Returns a primitive quadratic forms in the similarity class of the given form.
+#
+#    This only works when we have GCDs... so over ZZ.
+#    """
+#    c=self.content()
+#    new_coeffs = [self.base_ring()(a/c)  for a in self.__coeffs] 
+#    return QuadraticForm(self.base_ring(), self.dim(), new_coeffs)
+
+
+
+#def adjoint(self):
+#    """
+#    This gives the adjoint (integral) quadratic form associated to the
+#    given form, essentially defined by taking the adjoint of the matrix.
+#    """
+#    if is_odd(self.dim()):
+#        return QuadraticForm(self.matrix().adjoint()*2)
+#    else:
+#        return QuadraticForm(self.matrix().adjoint())
+
+
+## Perhaps this is not needed...
+#
+#  def antiadjoint(self):
+#    """
+#    
+#    
+#    """
+#    n=self.dim
+#    try:
+#      d=(polygen(self.R)**(n-1)-self.disc()).roots()[0][0]
+#      if is_odd(n):
+#        return self.adjoint() / d**(n-2) / 4
+#      else:
+#        return self.adjoint() / d**(n-2)
+#    except IndexError:
+#      raise ValueError, "not an adjoint"
+
+
+## See above...
+#
+#  def is_adjoint(self):
+#    try:
+#      self.antiadjoint()
+#    except ValueError:
+#      return False
+#    return True
+
+
+def reciprocal(self):
+    return self.adjoint().primitive() * self.content()
+
+
+def omega(self):
+    """
+    This is the content of the adjont of the primitive associated quadratic form.
+
+    Ref: See Dickson's "Studies in Number Theory".
+    """
+    return self.primitive().adjoint().content()
+
+def delta(self):
+    """
+    This is the omega of the adjoint form, 
+    which is the same as the omega of the reciprocal form.
+    """
+    return self.adjoint().omega()
+
+
+def level__Tornaria(self):
+    """
+    Hopefully this agrees with the usual level...
+    """
+    return self.base_ring()(self.disc()/self.omega()/self.content()**self.dim())
+
+
+def discrec(self):
+    return self.reciprocal().disc()
+
+
+
+
+### Rational equivalence
+
+def hasse_conductor(self):
+    """
+    This is the product of all primes where the Hasse invariant is -1.
+
+    Note: For ternary forms, this is the discriminant of the associated
+    quaternion algebra associated to the quadratic space
+    """
+    # * self.hasse(-1) ???
+    return prod(filter(lambda(p):self.hasse_invariant(p)==-1, \
+             map(lambda(x):x[0],factor(2*self.level()))))
+
+
+### Genus theory
+
+def basiclemma(self,M):
+    a=self(self.basiclemmavec(M))
+    assert gcd(a,M) == 1
+    return a
+
+def basiclemmavec(self,M):
+    """
+    Finds a vector where the value of the quadratic form is coprime to M.
+    """
+    V=FreeModule(self.base_ring(),self.dim())
+    mat = self.matrix()
+    vec = []
+    mod = []
+    M0 = abs(M)
+    if M0 == 1:
+        return V(0)
+
+    for i in range(self.dim()):
+        M1 = prime_to_m_part(M0, self[i,i])
+        if M1 != 1:
+            vec.append(V.i)
+            mod.append(M1)
+        M0 = M0/M1
+        if M0 == 1:
+            return __crt_list(vec,mod)
+
+    for i in range(self.dim()):
+        for j in range(i):
+            M1 = prime_to_m_part(M0, self[i,j])
+            if M1 != 1:
+                vec.append(V.i + V.j)
+                mod.append(M1)
+            M0 = M0/M1
+            if M0 == 1:
+                return __crt_list(vec,mod)
+
+    raise ValueError, "not primitive form"
+
+def __crt_list(ls, ms):
+    """
+    Chinese remainder theorem for lists; find an element l
+    such that l = ls[i] mod ms[i] for all i.
+    """
+    return sum(map(prod,zip,(ls,crt_basis(ms))))
+
+
+### FIXME: get the rules for validity of characters straight...
+### p=2 might be bad!!!
+def xi(self,p):
+    """
+    Return the value of the genus characters Xi_p... which may be missing one character.
+    We allow -1 as a prime.
+
+    Reference: Dickson's "Studies in the Theory of Numbers" 
+    """
+    if self.dim() == 2 and self.disc() % p:
+        raise ValueError, "not a valid character"
+    if self.dim() >= 3 and self.omega() % p:
+        raise ValueError, "not a valid character"
+    if (p == -1) or (p == 2):
+        return kronecker(p, self.basiclemma(2))
+    return kronecker(self.basiclemma(p), p)
+
+
+def xi_rec(self,p):
+    """
+    Returns Xi(p) for the reciprocal form.
+    """
+    return self.reciprocal().xi(p)
+
+
+def lll(self):
+    """
+    Returns an LLL-reduced form of Q (using Pari).
+    """
+    return self(self.matrix().lllgram())
+
+
+def representation_number_list(self, B):
+    """
+    Returns the vector of representation numbers < B.  
+    """
+    return pari(1).concat(self._pari_().qfrep(B-1, 1) * 2)
+
+
+def ThetaByPari(self, B):
+    """
+    Returns the theta function up to O(q^B).
+    """
+    PSR = PowerSeriesRing(ZZ,'q')
+    return PSR(self.representation_number_list(B), B)
+
+
+
+def representation_vector_list(self, B):
+    """
+    Find all vectors v where Q(v) <= B.
+    """
+    n,m,vs = self._pari_().qfminim(2*(B-1), 10**8)
+    if n != 2 * len(vs):
+        raise RuntimeError("insufficient number of vectors")
+    ms = [[] for _ in xrange(m/2+1)]
+    for v in vs:
+        ms[int(self(v))].append(v)
+    return ms
+
+
+
+### zeros
+
+def is_singular_vector(self, v, p=0):
+    """
+    Determines if the vector v is on the conic Q(x) = 0 (mod p), 
+    and that this point is non-singular point of the conic.
+    """
+    if not self.is_zero(v, p):
+        return False
+    vm = vector(self.base_ring(), v) * self.matrix()
+    if p != 0:
+        vm = vm % p
+
+    return (vm == 0)
+
+
+
diff --git a/sage/quadratic_forms/quadratic_form__theta.py b/sage/quadratic_forms/quadratic_form__theta.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__theta.py
@@ -0,0 +1,381 @@
+
+from copy import deepcopy
+
+from sage.rings.real_mpfr import RealField
+from sage.matrix.matrix_space import MatrixSpace
+from sage.rings.power_series_ring import PowerSeriesRing
+from sage.rings.integer_ring import IntegerRing, ZZ
+from sage.calculus.calculus import sqrt, floor, ceil
+
+from sage.interfaces.gp import gp
+
+from sage.modular.dims import sturm_bound
+
+
+def theta_series(self, Max='sturm', var_str='q', safe_flag=True):
+    """
+    Compute the theta series as a power series in the variable given
+    in var_str (which defaults to 'q'), up to the specified precision
+    O(q^max).
+
+    If no precision is specified, then it defaults to computing the
+    precision specified by sturm_bound() + 1, which suffices to
+    uniquely determine the cuspidal part of the theta series.
+    
+    This uses the PARI/GP function qfrep, wrapped by the
+    theta_by_pari() method.  This caches teh result for future
+    computations.
+
+    WARNING: This may not be the correct default bound for
+    odd-dimensional quadratic forms!!  CHECK THIS!!!
+
+    The safe_flag allows us to select whether we want a copy of the
+    output, or the original output.  It is only meningful when a
+    vector is returned, otherwise a copy is automatically made in
+    creating the power series.  By default safe_flag = True, so we
+    return a copy of the cached information.  If this is set to False,
+    then the routine is much faster but the return values are
+    vulnerable to being corrupted by the user.
+
+    """
+    ## Sanity Check: Max is an integer or an allowed string:
+    try:
+        M = ZZ(Max)
+    except:
+        M = -1
+
+    if (Max not in ['sturm']) and (not M >= 0):
+        print Max
+        raise TypeError, "Oops!  Max is not an integer >= 0 or an allowed string."
+
+    if Max == 'sturm':
+        return self.theta_by_pari(sturm_bound(self.level(), self.dim() / ZZ(2)) + 1, var_str, safe_flag)
+    else:
+        return self.theta_by_pari(M, var_str, safe_flag)
+
+
+
+## -------------  Compute the theta function by using the PARI/GP routine qfrep  ------------
+
+def theta_by_pari(self, Max, var_str='q', safe_flag=True):
+    """
+    Use PARI/GP to compute the theta function as a power series (or
+    vector) up to the precision O(q^Max).  This also caches the result
+    for future computations.
+
+    If var_str = '', then we return a vector v where v[i] counts the
+    number of vectors of length i.
+
+    The safe_flag allows us to select whether we want a copy of the
+    output, or the original output.  It is only meningful when a
+    vector is returned, otherwise a copy is automatically made in
+    creating the power series.  By default safe_flag = True, so we
+    return a copy of the cached information.  If this is set to False,
+    then the routine is much faster but the return values are
+    vulnerable to being corrupted by the user.
+
+    
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+        sage: Prec = 100
+        sage: compute = Q.theta_by_pari(Prec, '')
+        sage: exact = [1] + [8 * sum([d  for d in divisors(i)  if d % 4 != 0])  for i in range(1, Prec)] 
+        sage: compute == exact
+        True
+
+    INPUT:
+        Max -- an integer >=0
+        var_str -- a string
+
+    OUTPUT:
+        a power series or a vector
+    """
+    ## Try to use the cached result if it's enough precision
+    try:        
+        if len(self.__theta_vec) >= Max:
+            theta_vec = self.__theta_vec[:Max]
+        else:
+            raise RuntimeError, ""
+    except:
+        ## Generate a PARI matrix string for the associated Hessian matrix
+        M_str = str(gp(self.matrix()))
+        
+        ## Compute the theta function as a vector
+        gp_vec = list(gp.qfrep(M_str, 2*Max-2))
+        
+        ## Create the "halved" representation/theta vector
+        theta_vec = [ZZ(1)] + [ZZ(2) * ZZ(gp_vec[x])  for x in range(1, len(gp_vec), 2)]
+
+        ## Cache the theta vector
+        self.__theta_vec = theta_vec
+
+    
+    ## Return the answer
+    if var_str == '':
+        if safe_flag:
+            return deepcopy(theta_vec)         ## We must make a copy here to insure the integrity of the cached version!
+        else:
+            return theta_vec
+    else:
+        return PowerSeriesRing(ZZ, var_str)(theta_vec)
+
+
+
+## -------------  Compute the theta function by using an explicit Cholesky decomposition ------------
+
+##########################################################################
+## Routines to compute the Fourier expansion of the theta function of Q ##
+## (to a given precision) via a Cholesky decomposition over RR.         ##
+##                                                                      ##
+## The Cholesky code was taken from:                                    ##
+## ~/Documents/290_Project/C/Ver13.2__3-5-2007/Matrix_mpz/Matrix_mpz.cc ##
+##########################################################################
+
+def cholesky_decomposition(self, bit_prec = 53):
+    """
+    Give the Cholesky decomposition of Q as a real matrix of precision
+        bit_prec.
+
+    RESTRICTIONS: Q must be given as a QuadraticForm defnined over ZZ,
+        QQ, or some RealField().  If it is over some real field, then
+        an error is raised if the precision given is not less than the
+        defined precision of the real field defining the quadratic form!
+
+    REFERENCE: From Cohen's "A Course in Computational Algebraic
+        Number Theory" book, p 103.
+
+    INPUT:
+        bit_prec -- a natural number.
+
+    OUTPUT:
+        an upper triangular real matrix of precision bit_prec.
+
+
+    TO DO: If we only care about working over the real double field
+        (RDF), then we can use the cholesky() method present for
+        square matrices over that.
+
+
+    ##///////////////////////////////////////////////////////////////////////////////////////////////// 
+    ##/// Finds the Cholesky decomposition of a quadratic form -- as an upper-triangular matrix!
+    ##/// (It's assumed to be global, hence twice the form it refers to.)  <-- Python revision asks:  Is this true?!? =|
+    ##/////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+    EXAMPLES:
+
+
+    """
+
+    ## Check that the precision passed is allowed.
+    if isinstance(self.base_ring(), RealField) and (self.base_ring().prec() < bit_prec):
+        raise RuntimeError, "Oops! The precision requested is greater than that of the given quadratic form!"
+
+    ## 1. Initialization
+    n = self.dim()
+    R = RealField(bit_prec)
+    MS = MatrixSpace(R, n, n)
+    Q = MS(R(0.5)) * MS(self.matrix())               ## Initialize the real symmetric matrix A with the matrix for Q(x) = x^t * A * x
+
+    ## DIAGNOSTIC
+    #print "After 1:  Q is \n" + str(Q)
+
+    ## 2. Loop on i
+    for i in range(n):
+        for j in range(i+1, n):
+            Q[j,i] = Q[i,j]             ## Is this line redudnant?
+            Q[i,j] = Q[i,j] / Q[i,i]
+
+        ## 3. Main Loop
+        for k in range(i+1, n):
+            for l in range(k, n):
+                Q[k,l] = Q[k,l] - Q[k,i] * Q[i,l]
+
+    ## 4. Zero out the strictly lower-triangular entries
+    for i in range(n):
+        for j in range(i-1):
+            Q[i,j] = 0
+
+    return Q
+
+
+def theta_by_cholesky(self, q_prec):
+    """
+    Uses the real Choelesky decomposition to compute (the q-expansion
+    of) the theta function of the quadratic form as a power series in
+    q with terms correct up to the power q ^ q_prec.  (So its error is
+    O(q ^ (q_prec + 1)).)
+
+    REFERENCE: From Cohen's "A Course in Computational Algebraic
+        Number Theory" book, p 102.
+
+
+    EXAMPLES:
+        ## Check the sum of 4 squares form against Jacobi's formula
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+        sage: Theta = Q.theta_by_cholesky(10)
+        sage: Theta
+        1 + 8*q + 24*q^2 + 32*q^3 + 24*q^4 + 48*q^5 + 96*q^6 + 64*q^7 + 24*q^8 + 104*q^9 + 144*q^10
+        sage: Expected =  [1] + [8*sum([d for d in divisors(n) if d%4 != 0])  for n in range(1,11)]
+        sage: Expected
+        [1, 8, 24, 32, 24, 48, 96, 64, 24, 104, 144]
+        sage: Theta.list() == Expected
+        True
+
+        ## Check the form x^2 + 3y^2 + 5z^2 + 7w^2 represents everything except 2 and 22.
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+        sage: Theta = Q.theta_by_cholesky(50)
+        sage: Theta_list = Theta.list()
+        sage: [m  for m in range(len(Theta_list))  if Theta_list[m] == 0]
+        [2, 22]
+
+    """
+    ## RAISE AN ERROR -- This routine is deprecated!
+    #raise NotImplementedError, "This routine is deprecated.  Try theta_series(), which uses theta_by_pari()."
+
+
+    n = self.dim()
+    theta = [0 for i in range(q_prec+1)]
+    PS = PowerSeriesRing(ZZ, 'q')
+
+    bit_prec = 53                                       ## TO DO: Set this precision to reflect the appropriate roundoff 
+    Cholesky = self.cholesky_decomposition(bit_prec)     ## error estimate, to be confident through our desired q-precision.
+    Q = Cholesky      ##  <----  REDUNDANT!!!
+    R = RealField(bit_prec)
+    half = R(0.5)    
+
+
+
+    ## 1. Initialize
+    i = n - 1
+    T = [R(0)  for j in range(n)]
+    U = [R(0)  for j in range(n)]
+    T[i] = R(q_prec)
+    U[i] = 0
+    L = [0 for j in range (n)]
+    x = [0 for j in range (n)]
+
+
+    ## 2. Compute bounds
+    #Z = sqrt(T[i] / Q[i,i])      ## IMPORTANT NOTE: sqrt preserves the precision of the real number it's given... which is not so good... =|
+    #L[i] = floor(Z - U[i])       ## Note: This is a SAGE Integer
+    #x[i] = ceil(-Z - U[i]) - 1   ## Note: This is a SAGE Integer too
+  
+  
+    done_flag = False
+    from_step4_flag = False
+    from_step3_flag = True        ## We start by pretending this, since then we get to run through 2 and 3a once. =)
+
+    #double Q_val_double;
+    #unsigned long Q_val;                 // WARNING: Still need a good way of checking overflow for this value...
+
+
+  
+    ## Big loop which runs through all vectors
+    while (done_flag == False):
+
+        ## Loop through until we get to i=1 (so we defined a vector x)
+        while from_step3_flag or from_step4_flag:              ## IMPORTANT WARNING:  This replaces a do...while loop, so it may have to be adjusted!
+
+            ## Go to directly to step 3 if we're coming from step 4, otherwise perform step 2.
+            if from_step4_flag:
+                from_step4_flag = False
+            else:
+                ## 2. Compute bounds
+                from_step3_flag = False
+                Z = sqrt(T[i] / Q[i,i])
+                L[i] = floor(Z - U[i])  
+                x[i] = ceil(-Z - U[i]) - 1
+                      
+
+
+            ## 3a. Main loop 
+
+            ## DIAGNOSTIC
+            #print 
+            #print "  L = ", L
+            #print "  x = ", x
+
+            x[i] += 1
+            while (x[i] > L[i]):
+
+                ## DIAGNOSTIC
+                #print "  x = ", x              
+
+                i += 1
+                x[i] += 1
+
+      
+            ## 3b. Main loop 
+            if (i > 0):
+                from_step3_flag = True
+
+                ## DIAGNOSTIC
+                #print " i = " + str(i) 
+                #print " T[i] = " + str(T[i]) 
+                #print " Q[i,i] = " + str(Q[i,i]) 
+                #print " x[i] = " + str(x[i]) 
+                #print " U[i] = " + str(U[i]) 
+                #print " x[i] + U[i] = " + str(x[i] + U[i]) 
+                #print " T[i-1] = " + str(T[i-1]) 
+
+                T[i-1] = T[i] - Q[i,i] * (x[i] + U[i]) * (x[i] + U[i])
+
+                # DIAGNOSTIC
+                #print " T[i-1] = " + str(T[i-1]) 
+                #print
+
+                i += - 1
+                U[i] = 0
+                for j in range(i+1, n):
+                    U[i] += Q[i,j] * x[j]
+        
+      
+
+        ## 4. Solution found (This happens when i=0)
+        from_step4_flag = True
+        Q_val_double = q_prec - T[0] + Q[0,0] * (x[0] + U[0]) * (x[0] + U[0])
+        Q_val = floor(Q_val_double + half)        ## Note: This rounds the value up, since the "round" function returns a float, but floor returns integer. 
+
+
+
+        ## DIAGNOSTIC
+        #print " Q_val_double = ",  Q_val_double
+        #print " Q_val = ",  Q_val
+        #raise RuntimeError
+
+
+        ## OPTIONAL SAFETY CHECK: 
+        eps = 0.000000001
+        if (abs(Q_val_double - Q_val) > eps):
+            raise RuntimeError, "Oh No!  We have a problem with the floating point precision... \n" \
+                + " Q_val_double = " + str(Q_val_double) + "\n" \
+                + " Q_val = " + str(Q_val) + "\n" \
+                + " x = " + str(x) + "\n"
+
+
+        ## DIAGNOSTIC
+        #print " The float value is " + str(Q_val_double)
+        #print " The associated long value is " + str(Q_val)
+        #print
+
+        if (Q_val <= q_prec):
+            theta[Q_val] += 2
+ 
+        ## 5. Check if x = 0, for exit condition. =)
+        done_flag = True
+        for j in range(n):
+            if (x[j] != 0):
+                done_flag = False
+
+  
+    ## Set the value: theta[0] = 1
+    theta[0] = 1
+
+    ## DIAGNOSTIC
+    #print "Leaving ComputeTheta \n" 
+
+
+    ## Return the series, truncated to the desired q-precision
+    return PS(theta)
+
diff --git a/sage/quadratic_forms/quadratic_form__variable_substitutions.py b/sage/quadratic_forms/quadratic_form__variable_substitutions.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/quadratic_form__variable_substitutions.py
@@ -0,0 +1,290 @@
+#*****************************************************************************
+#       Copyright (C) 2007 William Stein and Jonathan Hanke
+#
+#  Distributed under the terms of the GNU General Public License (GPL)
+#
+#    This code is distributed in the hope that it will be useful,
+#    but WITHOUT ANY WARRANTY; without even the implied warranty of
+#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#    General Public License for more details.
+#
+#  The full text of the GPL is available at:
+#
+#                  http://www.gnu.org/licenses/
+#*****************************************************************************
+
+import copy
+
+
+def swap_variables(self, r, s, in_place = False): 
+    """
+    Switch the variables x_r and x_s in the quadratic form
+    (replacing the original form if the in_place flag is True).
+
+    EXAMPLES:
+        sage: Q = QuadraticForm(ZZ, 4, range(1,11))
+        sage: Q
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 1 2 3 4 ]
+        [ * 5 6 7 ]
+        [ * * 8 9 ]
+        [ * * * 10 ]
+
+        sage: Q.swap_variables(0,2)
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 8 6 3 9 ]
+        [ * 5 2 7 ]
+        [ * * 1 4 ]
+        [ * * * 10 ]
+
+        sage: Q.swap_variables(0,2).swap_variables(0,2)
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 1 2 3 4 ]
+        [ * 5 6 7 ]
+        [ * * 8 9 ]
+        [ * * * 10 ]
+
+    """
+    if (in_place == False):
+        Q = copy.deepcopy(self)
+        Q.__init__(self.base_ring(), self.dim(), self.coefficients())
+        Q.swap_variables(r,s,in_place=True)
+        return Q
+
+    else:
+        ## Switch diagonal elements
+        tmp = self[r,r]    
+        self[r,r] = self[s,s]    
+        self[s,s] = tmp    
+
+        ## Switch off-diagonal elements
+        for i in range(self.dim()):
+            if (i != r) and (i != s):
+                tmp = self[r,i]
+                self[r,i] = self[s,i]    
+                self[s,i] = tmp    
+    
+
+def multiply_variable(self, c, i, in_place = False): 
+    """
+    Replace the variables x_i by c*x_i in the quadratic form
+    (replacing the original form if the in_place flag is True).
+
+    Here c must be an element of the base_ring defining the
+    quadratic form.
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,9,5,7])
+        sage: Q.multiply_variable(5,0)
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 25 0 0 0 ]
+        [ * 9 0 0 ]
+        [ * * 5 0 ]
+        [ * * * 7 ]
+
+    """
+    if (in_place == False):
+        Q = copy.deepcopy(self)
+        Q.__init__(self.base_ring(), self.dim(), self.coefficients())
+        Q.multiply_variable(c,i,in_place=True)
+        return Q
+
+    else:
+        ## Stretch the diagonal element
+        tmp = c * c * self[i,i]    
+        self[i,i] = tmp    
+
+        ## Switch off-diagonal elements
+        for k in range(self.dim()):
+            if (k != i):
+                tmp = c * self[k,i]    
+                self[k,i] = tmp
+
+
+def divide_variable(self, c, i, in_place = False): 
+    """
+    Replace the variables x_i by (x_i)/c in the quadratic form
+    (replacing the original form if the in_place flag is True).
+
+    Here c must be an element of the base_ring defining the
+    quadratic form, and the division must be definied in the base
+    ring.
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,9,5,7])
+        sage: Q.divide_variable(3,1)
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 1 0 0 0 ]
+        [ * 1 0 0 ]
+        [ * * 5 0 ]
+        [ * * * 7 ]
+
+    """
+    if (in_place == False):
+        Q = copy.deepcopy(self)
+        Q.__init__(self.base_ring(), self.dim(), self.coefficients())
+        Q.divide_variable(c,i,in_place=True)
+        return Q
+
+    else:
+        ## Stretch the diagonal element
+        tmp = self[i,i] / (c*c)    
+        self[i,i] = tmp    
+
+        ## Switch off-diagonal elements
+        for k in range(self.dim()):
+            if (k != i):
+                tmp = self[k,i] / c    
+                self[k,i] = tmp    
+
+
+def scale_by_factor(self, c, change_value_ring_flag=False):
+    """
+    Scale the values of the quadratic form by the number c, if 
+    this is possible while still being defined over its base ring.  
+
+    If the flag is set to true, then this will alter the value ring 
+    to be the field of fractions of the original ring (if necessary).
+
+    INPUT:
+        c -- a scalar in the fraction field of the value ring of the form.
+
+    OUTPUT:
+        A quadratic form of the same dimension
+        
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [3,9,18,27])
+        sage: Q.scale_by_factor(3)
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 9 0 0 0 ]
+        [ * 27 0 0 ]
+        [ * * 54 0 ]
+        [ * * * 81 ]
+        
+        sage: Q.scale_by_factor(1/3)
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 1 0 0 0 ]
+        [ * 3 0 0 ]
+        [ * * 6 0 ]
+        [ * * * 9 ]
+    """
+    ## Try to scale the coefficients while staying in the ring of values.
+    new_coeff_list = [x*c  for x in self.coefficients()]
+
+    ## Check if we can preserve the value ring and return result. -- USE THE BASE_RING FOR NOW...
+    R = self.base_ring()
+    try:
+        list2 = [R(x)  for x in new_coeff_list]
+        Q = copy.deepcopy(self)
+        Q.__init__(R, self.dim(), list2)
+        return Q
+    except:
+        if (change_value_ring_flag == False):
+            raise TypeError, "Oops! We could not rescale the lattice in this way and preserve its defining ring."
+        else:
+            F = R.fraction_field()
+            list2 = [F(x)  for x in new_coeff_list]
+            Q = copy.deepcopy(self)
+            Q.__init__(self.dim(), F, list2, R)  ## DEFINE THIS!  IT WANTS TO SET THE EQUIVALENCE RING TO R, BUT WITH COEFFS IN F.
+            #Q.set_equivalence_ring(R)
+            return Q
+
+
+def extract_variables(self, var_indices):
+    """
+    Extract the variables (in order) whose indices are listed in
+    var_indices, to give a new quadratic form.
+    """
+    m = len(var_indices)
+    Q = copy.deepcopy(self)
+    Q.__init__(self.base_ring(), m)
+    for i in range(m):
+        for j in range(i, m):
+            Q[i,j] = self[ var_indices[i], var_indices[j] ]
+
+    return Q
+
+
+
+def elementary_substitution(self, c, i, j, in_place = False):     ## CHECK THIS!!!
+    """
+    Perform the substitution x_i --> x_i + c*x_j (replacing the
+    original form if the in_place flag is True).
+
+    EXAMPLES:
+        sage: Q = QuadraticForm(ZZ, 4, range(1,11))
+        sage: Q
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 1 2 3 4 ]
+        [ * 5 6 7 ]
+        [ * * 8 9 ]
+        [ * * * 10 ]
+
+        sage: Q.elementary_substitution(c=1, i=0, j=3)
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 1 2 3 6 ]
+        [ * 5 6 9 ]
+        [ * * 8 12 ]
+        [ * * * 15 ]
+
+
+        sage: R = QuadraticForm(ZZ, 4, range(1,11))
+        sage: R
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 1 2 3 4 ]
+        [ * 5 6 7 ]
+        [ * * 8 9 ]
+        [ * * * 10 ]
+
+        sage: M = Matrix(ZZ, 4, 4, [1,0,0,1,0,1,0,0,0,0,1,0,0,0,0,1])
+        sage: M
+        [1 0 0 1]
+        [0 1 0 0]
+        [0 0 1 0]
+        [0 0 0 1]
+
+        sage: R(M)
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 1 2 3 6 ]
+        [ * 5 6 9 ]
+        [ * * 8 12 ]
+        [ * * * 15 ]
+
+    """
+    if (in_place == False):
+        Q = copy.deepcopy(self)
+        Q.__init__(self.base_ring(), self.dim(), self.coefficients())
+        Q.elementary_substitution(c, i, j, True)
+        return Q
+
+    else:
+        ## Adjust the a_{k,j} coefficients 
+        ij_old = self[i,j]    ## Store this since it's overwritten, but used in the a_{j,j} computation!
+        for k in range(self.dim()):
+            if (k != i) and (k != j):
+                ans = self[j,k] + c*self[i,k]
+                self.__setitem__((j,k), ans)    
+            elif (k == j):
+                ans = self[j,k] + c*ij_old + c*c*self[i,i]    
+                self[j,k] = ans        
+            else:
+                ans = self[j,k] + 2*c*self[i,k]     
+                self[j,k] = ans        
+
+
+
+def add_symmetric(self, c, i, j, in_place = False):
+    """
+    Performs the substitution x_j --> x_j + c*x_i, which has the
+    effect (on associated matrices) of symmetrically adding 
+    c * j-th row/column to the i-th row/column.  
+
+    NOTE: This is meant for compatibility with previous code,
+    which implemented a matrix model for this class.  It is used
+    in the local_normal_form() method.
+    """
+    return self.elementary_substitution(c, j, i, in_place)
+
+
+
+
diff --git a/sage/quadratic_forms/random_quadraticform.py b/sage/quadratic_forms/random_quadraticform.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/random_quadraticform.py
@@ -0,0 +1,110 @@
+from sage.quadratic_forms.quadratic_form import QuadraticForm
+from sage.rings.ring import is_Ring
+
+################################################
+## Routines to create a random quadratic form ##
+################################################
+
+def random_quadraticform(R, n, rand_arg_list=[]):
+    """
+    Create a random quadratic form in n variables defined over the
+    ring R.
+
+    The last (and optional) argument rand_arg_list is a list of at
+    most 3 elements which is passed (as at most 3 separate variables)
+    into the method R.random_element().
+
+    INPUT:
+        R -- a ring.
+        n -- an integer >= 0
+        rand_arg_list -- a list of at most 3 arguments which can be
+            taken by R.random_element()
+
+    OUTPUT:
+        A quadratic form over the ring R.
+
+    EXAMPLES:
+        sage: random_quadraticform(ZZ, 3, [1,5])
+        Quadratic form in 3 variables over Integer Ring with coefficients:
+        [ 3 2 3 ]
+        [ * 1 4 ]
+        [ * * 3 ]
+        
+        sage: random_quadraticform(ZZ, 3, [-5,5])
+        Quadratic form in 3 variables over Integer Ring with coefficients:
+        [ 3 2 -5 ]
+        [ * 2 -2 ]
+        [ * * -5 ]
+        
+        sage: random_quadraticform(ZZ, 3, [-50,50])
+        Quadratic form in 3 variables over Integer Ring with coefficients:
+        [ 1 8 -23 ]
+        [ * 0 0 ]
+        [ * * 6 ]
+    """    
+    ## Sanity Checks: We have a ring and there are at most 3 parameters for randomness!
+    if len(rand_arg_list) > 3:
+        raise TypeError, "Oops!  The list of randomness arguments can have at most 3 elements."
+    if not is_Ring(R):
+        raise TypeError, "Oops!  The first argument must be a ring."
+
+    ## Create a list of upper-triangular entries for the quadratic form
+    L = len(rand_arg_list)
+    nn = int(n*(n+1)/2)
+    if L == 0:
+        rand_list = [R.random_element()  for _ in range(nn)]
+    elif L == 1:
+        rand_list = [R.random_element(rand_arg_list[0])  for _ in range(nn)]
+    elif L == 2:
+        rand_list = [R.random_element(rand_arg_list[0], rand_arg_list[1])  for _ in range(nn)]
+    elif L == 3:
+        rand_list = [R.random_element(rand_arg_list[0], rand_arg_list[1], rand_arg_list[2])  for _ in range(nn)]
+                
+    ## Return  the Quadratic Form
+    return QuadraticForm(R, n, rand_list)
+
+
+def random_quadraticform_with_conditions(R, n, condition_list=[], rand_arg_list=[]):
+    """
+    Create a random quadratic form in n variables defined over the
+    ring R satisfying a list of boolean (i.e. True/False) conditions.
+
+    The conditions c appearing in the list must be boolean functions
+    which can be called either as Q.c() or c(Q), where Q is the ranom
+    quadratic form.
+
+    The last (and optional) argument rand_arg_list is a list of at
+    most 3 elements which is passed (as at most 3 separate variables)
+    into the method R.random_element().
+
+    EXAMPLES:
+        sage: Q = random_quadraticform_with_conditions(ZZ, 3, [QuadraticForm.is_positive_definite], [-5, 5])
+        sage: Q
+        Quadratic form in 3 variables over Integer Ring with coefficients:
+        [ 3 -2 -5 ]
+        [ * 2 2 ]
+        [ * * 3 ]
+
+    """
+    Q = random_quadraticform(R, n, rand_arg_list)
+    Done_Flag = True
+
+    ## Check that all conditions are satisfied
+    while Done_Flag:
+        Done_Flag = False
+        for c in condition_list:
+
+            ## Check if condition c is satisfied
+            try:
+                bool_ans = Q.c()
+            except:
+                bool_ans = c(Q)
+                
+            ## Create a new quadratic form if a condition fails
+            if (bool_ans == False):
+                Q = random_quadraticform(R, n, rand_arg_list)
+                Done_Flag = True
+                break
+
+    ## Return the quadratic form
+    return Q
diff --git a/sage/quadratic_forms/special_values.py b/sage/quadratic_forms/special_values.py
new file mode 100644
--- /dev/null
+++ b/sage/quadratic_forms/special_values.py
@@ -0,0 +1,229 @@
+##########################################################
+## Routines for computing special values of L-functions ##
+##########################################################
+
+from sage.algebras.quaternion_algebra import fundamental_discriminant
+from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
+from sage.rings.arith import kronecker_symbol, bernoulli, factorial
+from sage.combinat.combinat import bernoulli_polynomial
+from sage.rings.rational_field import QQ
+from sage.rings.integer_ring import ZZ
+from sage.functions.constants import pi, I
+from sage.calculus.calculus import sqrt, SymbolicExpressionRing
+from sage.rings.real_mpfr import is_RealField
+from sage.misc.functional import denominator, numerator
+from sage.rings.infinity import infinity
+
+
+## ---------------- The Gamma Function  ------------------
+
+def gamma__exact(n):
+    """
+    Evaluates the exact value of the gamma function at an integer or
+    half-integer argument.
+
+    EXAMPLES:
+        sage: gamma__exact(4)
+        6
+        sage: gamma__exact(3)
+        2
+        sage: gamma__exact(2)
+        1
+        sage: gamma__exact(1)
+        1
+
+        sage: gamma__exact(1/2)
+        sqrt(pi)
+        sage: gamma__exact(3/2)
+        sqrt(pi)/2
+        sage: gamma__exact(5/2)
+        3*sqrt(pi)/4
+        sage: gamma__exact(7/2)
+        15*sqrt(pi)/8
+
+        sage: gamma__exact(-1/2)
+        -2*sqrt(pi)
+        sage: gamma__exact(-3/2)
+        4*sqrt(pi)/3
+        sage: gamma__exact(-5/2)
+        -8*sqrt(pi)/15
+        sage: gamma__exact(-7/2)
+        16*sqrt(pi)/105
+
+    """
+    ## SANITY CHECK
+    if (not n in QQ) or (denominator(n) > 2):
+        raise TypeError, "Oops!  You much give an integer or half-integer argument."
+
+    if (denominator(n) == 1):
+        if n <= 0:
+            return infinity
+        if n > 0:
+            return factorial(n-1) 
+    else:
+        ans = QQ(1)
+        while (n != QQ(1)/2):
+            if (n<0): 
+                ans *= QQ(1)/n
+                n = n + 1
+            elif (n>0):
+                n = n - 1
+                ans *= n 
+            
+        ans *= sqrt(pi)
+        return ans
+
+
+
+## ------------- The Riemann Zeta Function  --------------
+
+def zeta__exact(n):
+    """
+    Returns the exact value fo the Riemann Zeta function
+
+    References:
+        Iwasawa's "Lectures on p-adic L-functions", p13
+            Special value of zeta(2k)
+        Ireland and Rosen's "A Classical Introduction to Modern Number Theory"
+        Washington's "Cyclotomic Fields"
+
+    EXAMPLES:
+        sage: ## Testing the accuracy of the negative special values
+        sage: RR = RealField(100)
+        sage: for i in range(1,10):
+        ...       print "zeta(" + str(1-2*i) + "): ", RR(zeta__exact(1-2*i)) - zeta(RR(1-2*i))
+        zeta(-1):  0.00000000000000000000000000000
+        zeta(-3):  0.00000000000000000000000000000
+        zeta(-5):  0.00000000000000000000000000000
+        zeta(-7):  0.00000000000000000000000000000
+        zeta(-9):  0.00000000000000000000000000000
+        zeta(-11):  0.00000000000000000000000000000
+        zeta(-13):  0.00000000000000000000000000000
+        zeta(-15):  0.00000000000000000000000000000
+        zeta(-17):  0.00000000000000000000000000000
+
+        sage: RR = RealField(100)
+        sage: for i in range(1,10):
+        ...       print "zeta(" + str(1-2*i) + "): ", RR(zeta__exact(1-2*i)) - zeta(RR(1-2*i))
+        zeta(-1):  0.00000000000000000000000000000
+        zeta(-3):  0.00000000000000000000000000000
+        zeta(-5):  0.00000000000000000000000000000
+        zeta(-7):  0.00000000000000000000000000000
+        zeta(-9):  0.00000000000000000000000000000
+        zeta(-11):  0.00000000000000000000000000000
+        zeta(-13):  0.00000000000000000000000000000
+        zeta(-15):  0.00000000000000000000000000000
+        zeta(-17):  0.00000000000000000000000000000
+
+    """
+    if n<0:
+        k = 1-n
+        return -bernoulli(k)/k
+    elif n>1:
+        if (n % 2 == 0):
+            return ZZ(-1)**(n/2 + 1) * ZZ(2)**(n-1) * pi**n * bernoulli(n) / factorial(n)
+        else:
+            raise TypeError, "n must be a critical value! (I.e. even > 0 or odd < 0.)"
+    elif n==1:
+        return infinity
+    elif n==0:
+        return -1/2
+
+## ---------- Dirichlet L-functions with quadratic characters ----------
+
+def QuadraticBernoulliNumber(k, d):
+    """
+    Compute k-th Bernoulli number for the primitive
+    quadratic character associated to chi(x) = (d/x).
+
+    EXAMPLES:
+
+    """
+    ## Ensure the character is primitive
+    d1 = fundamental_discriminant(d)
+    f = abs(d1)
+   
+    ## Make the (usual) k-th Bernoulli polynomial
+    x =  PolynomialRing(QQ, 'x').gen()
+    bp = bernoulli_polynomial(x, k) 
+
+    ## Make the k-th quadratic Bernoulli number
+    total = sum([kronecker_symbol(d1, i) * bp(i/f)  for i in range(f)])
+    total *= (f ** (k-1))
+
+    return total
+
+
+def quadratic_L_function__exact(n, d):
+    """
+    Returns the exact value of a quadratic twist of the Riemann Zeta function by chi_d(x) = (d/x).  
+
+    References:
+        Iwasawa's "Lectures on p-adic L-functions", p16-17
+            Special values of L(1-n, chi) and L(n, chi)
+        Ireland and Rosen's "A Classical Introduction to Modern Number Theory"
+        Washington's "Cyclotomic Fields"
+
+    EXAMPLES:
+        sage: RR = RealField(100)
+        sage: for i in range(5):
+        ...       print "L(" + str(1+2*i) + ", (-4/.)): ", RR(quadratic_L_function__exact(1+2*i, -4)) - quadratic_L_function__numerical(RR(1+2*i),-4, 10000)
+        L(1, (-4/.)):  0.000049999999500000024999996962707
+        L(3, (-4/.)):  0.00000000000049999997000000374637816570842
+        L(5, (-4/.)):  0.0000000000000000000049999992370601592951889007864
+        L(7, (-4/.)):  0.000000000000000000000000000028398992587956424994822228350
+        L(9, (-4/.)):  0.0000000000000000000000000000031554436208840472216469142611
+
+        sage: ## Testing the accuracy of the negative special values
+        sage: ## ---- THIS FAILS SINCE THE DIRICHLET SERIES DOESN'T CONVERGE HERE! ----
+
+    """
+    if n<=0:
+        k = 1-n
+        return -QuadraticBernoulliNumber(k,d)/k
+    elif n>=1:
+        ## Compute the kind of critical values (p10)
+        if kronecker_symbol(fundamental_discriminant(d), -1) == 1:
+            delta = 0
+        else:
+            delta = 1        
+
+        ## Compute the positive special values (p17)
+        if ((n - delta) % 2 == 0):
+            f = abs(fundamental_discriminant(d))
+            if delta == 0:                            
+                GS = sqrt(f)
+            else:
+                GS = I * sqrt(f)
+            SR = SymbolicExpressionRing()
+            ans = SR(ZZ(-1)**(1+(n-delta)/2))
+            ans *= (2*pi/f)**n
+            ans *= GS     ## Evaluate the Gauss sum here! =0
+            ans *= 1/(2 * I**delta)
+            ans *= QuadraticBernoulliNumber(n,d)/factorial(n)
+            return ans
+        else:
+            if delta == 0:
+                raise TypeError, "n must be a critical value!\n" + "(I.e. even > 0 or odd < 0.)"
+            if delta == 1:
+                raise TypeError, "n must be a critical value!\n" + "(I.e. odd > 0 or even <= 0.)"
+
+
+
+def quadratic_L_function__numerical(n, d, num_terms=1000):
+    """
+    Evaluate the Dirichlet L-function (for quadratic character) numerically 
+    (in a very naive way). 
+
+    """
+    ## Set the correct precision if it's given (for n).
+    if is_RealField(n.parent()):
+        R = n.parent()
+    else:
+        R = RealField()
+
+    d1 = fundamental_discriminant(d)
+    ans = R(0)
+    for i in range(1,num_terms):
+        ans += R(kronecker_symbol(d1,i) / R(i)**n)
+    return ans
\ No newline at end of file
