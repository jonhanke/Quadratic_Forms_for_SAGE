# HG changeset patch
# User Gonzalo Tornar√≠a <tornaria@math.utexas.edu>
# Date 1235359398 18000
# Node ID 66bb9f1467f2f32e4fe13b1cd2421177b543dc94
# Parent  4631ee986dba35165e35c3896f512141c576435b
#4470: many fixes and doctests for quadratic forms code

diff --git a/sage/quadratic_forms/all.py b/sage/quadratic_forms/all.py
--- a/sage/quadratic_forms/all.py
+++ b/sage/quadratic_forms/all.py
@@ -1,10 +1,10 @@
 from binary_qf import BinaryQF, BinaryQF_reduced_representatives
 
-from quadratic_form import QuadraticForm, DiagonalQuadraticForm
+from quadratic_form import QuadraticForm, DiagonalQuadraticForm, is_QuadraticForm
 
 from random_quadraticform import random_quadraticform, random_quadraticform_with_conditions
 
-from extras import sgn, IsPadicSquare, random_int_upto, extend_to_primitive, is_triangular_number, hilbert_symbol_rational
+from extras import sgn, IsPadicSquare, random_int_upto, quadratic_nonresidue, extend_to_primitive, is_triangular_number, hilbert_symbol_rational
 
 from special_values import gamma__exact, zeta__exact, QuadraticBernoulliNumber, \
       quadratic_L_function__exact, quadratic_L_function__numerical
diff --git a/sage/quadratic_forms/constructions.py b/sage/quadratic_forms/constructions.py
--- a/sage/quadratic_forms/constructions.py
+++ b/sage/quadratic_forms/constructions.py
@@ -28,7 +28,10 @@
         sage: R = PolynomialRing(ZZ, 'x')
         sage: f = R([1,2,3])
         sage: g = R([2,5])        
-        sage: BezoutianQuadraticForm(f, g)
+        sage: Q = BezoutianQuadraticForm(f, g) ; Q
+        Quadratic form in 2 variables over Integer Ring with coefficients: 
+        [ 1 -12 ]
+        [ * -15 ]
 
     AUTHORS:
         Fernando Rodriguez-Villegas, Jonathan Hanke -- added on 11/9/2008
@@ -51,7 +54,10 @@
     bez_poly = (f(a) * g(b) - f(b) * g(a)) // (b - a)    ## Trucated (exact) division here
     for i in range(n):
         for j in range(i, n):
-            Q[i,j] = bez_poly.coefficient({a:i,b:j})
+            if i == j:
+                Q[i,j] = bez_poly.coefficient({a:i,b:j}) 
+            else:
+                Q[i,j] = bez_poly.coefficient({a:i,b:j}) * 2
 
     return Q
 
@@ -63,7 +69,6 @@
 
     EXAMPLES:
         sage: HyperbolicPlane_quadratic_form(ZZ)
-
         Quadratic form in 2 variables over Integer Ring with coefficients:
         [ 0 1 ]
         [ * 0 ]
diff --git a/sage/quadratic_forms/extras.py b/sage/quadratic_forms/extras.py
--- a/sage/quadratic_forms/extras.py
+++ b/sage/quadratic_forms/extras.py
@@ -3,7 +3,7 @@
 from sage.calculus.calculus import floor
 from sage.matrix.constructor import matrix
 from sage.matrix.matrix import is_Matrix
-from sage.rings.arith import valuation, kronecker_symbol, legendre_symbol, hilbert_symbol
+from sage.rings.arith import valuation, kronecker_symbol, legendre_symbol, hilbert_symbol, is_prime
 from sage.rings.rational_field import QQ
 from sage.rings.integer_ring import ZZ
 from sage.rings.infinity import infinity
@@ -18,6 +18,14 @@
 
     TO DO: This should really be incorporated into the hilbert_symbol()
     routine.
+
+    EXAMPLES:
+        sage: hilbert_symbol_rational(-1, -1, 2) == -1
+        True
+        sage: hilbert_symbol_rational(QQ(-1)/QQ(4), -1, 2) == -1
+        True
+        sage: hilbert_symbol_rational(QQ(-1)/QQ(4), -1, 3) == 1
+        True
     """
     return hilbert_symbol(squarefree_part(a), squarefree_part(b), p)
     
@@ -38,7 +46,14 @@
         1, 0, or -1.
 
     EXAMPLES:
-    
+        sage: sgn(pi) == 1
+        True
+        sage: sgn(5/6) == 1
+        True
+        sage: sgn(0) == 0
+        True
+        sage: sgn(-3) == -1
+        True
     """
     if x > 0:
         return ZZ(1)
@@ -167,7 +182,7 @@
     B = A * V
     B_new = matrix(R, n-k, n)
     for i in range(n-k):
-        B_new[i, i] = 1
+        B_new[i, n-i-1] = 1
     C = B.stack(B_new)
     D = C * V**(-1)
 
@@ -193,26 +208,26 @@
 def random_int_upto(n):
     """
     Returns a random integer x satisfying 0 <= x < n.
+
+    EXAMPLES:
+        sage: x = random_int_upto(10) 
+        sage: x >= 0
+        True
+        sage: x < 10
+        True
     """
     return floor(n * random())
 
 
 
-def sgn(x):
-    """
-    Returns the sign of a real number x.
-    """
-    if x > 0:
-        return 1
-    elif x == 0:
-        return 0
-    else:
-        return -1
-
-
 def quadratic_nonresidue(p):
     """
-    Returns the smalest positive integer quadratic non-residue in Z/pZ for primes p>2.    """
+    Returns the smalest positive integer quadratic non-residue in Z/pZ for primes p>2.
+
+    EXAMPLES:
+        sage: quadratic_nonresidue(5)
+        2
+    """
     p1 = abs(p)
 
     ## Deal with the prime p = 2 and |p| <= 1.
@@ -233,17 +248,30 @@
     """
     Determines whether the (non-zero) rational number m is a square in Q_p.
     When p = infinity this returns the answer for the real numbers.
+
+    EXAMPLES: 
+        sage: IsPadicSquare(2, 7)
+        True
+        sage: IsPadicSquare(98, 7)
+        True
+        sage: IsPadicSquare(2, 5)
+        False
     """
     ## Make sure m is non-zero
     if m == 0:
         raise TypeError, "Oops!  We're not allowed to ask about zero right now..."
 
-    ## TO DO:  Check that p is prime
-
     ## Deal with p = infinity (i.e. the real numbers)
     if p == infinity:
         return (m > 0)
 
+    ## Check that p is prime
+    try:
+        is_prime(p)
+    except:
+        raise TypeError, 'Oops!  p must be "infinity" or a positive prime number.'
+
+
     ## Deal with finite primes
     v1 = valuation(QQ(m).numer(), p) 
     v2 = valuation(QQ(m).denom(), p)
diff --git a/sage/quadratic_forms/quadratic_form.py b/sage/quadratic_forms/quadratic_form.py
--- a/sage/quadratic_forms/quadratic_form.py
+++ b/sage/quadratic_forms/quadratic_form.py
@@ -31,7 +31,7 @@
 from sage.rings.integer_ring import IntegerRing, ZZ
 from sage.rings.rational_field import RationalField, QQ
 from sage.rings.ring import Ring
-from sage.misc.functional import ideal, denominator
+from sage.misc.functional import ideal, denominator, is_even, is_field
 from sage.rings.arith import GCD, LCM, valuation, kronecker_symbol
 from sage.rings.fraction_field import FractionField
 from sage.quadratic_forms.extras import IsPadicSquare
@@ -49,6 +49,15 @@
     Wrapper for the QuadraticForm class constructor.  This is meant
     for internal use within the QuadraticForm class code only.  You
     should instead directly call QuadraticForm().
+
+    EXAMPLES:
+        sage: from sage.quadratic_forms.quadratic_form import QuadraticForm__constructor
+        sage: QuadraticForm__constructor(ZZ, 3)   ## Makes a generic quadratic form over the integers
+        Quadratic form in 3 variables over Integer Ring with coefficients: 
+        [ 0 0 0 ]
+        [ * 0 0 ]
+        [ * * 0 ]
+
     """
     return QuadraticForm(R, n, entries)
 
@@ -56,6 +65,13 @@
 def is_QuadraticForm(Q):
     """
     Determines if the object Q is an element of the QuadraticForm class.
+
+    EXAMPLES:
+        sage: Q = QuadraticForm(ZZ, 2, [1,2,3])
+        sage: is_QuadraticForm(Q)  ##random -- deprecated
+        True
+        sage: is_QuadraticForm(2)  ##random -- deprecated
+        False
     """
     return isinstance(Q, QuadraticForm)
 
@@ -64,6 +80,11 @@
 class QuadraticForm():
     """
     QuadraticForm() -- a quadratic form in n variables with coefficients in the ring R.
+
+    EXAMPLES:
+        sage: s = QuadraticForm(ZZ, 4, range(10))
+        sage: s == loads(dumps(s)) 
+        True
     """
 
     ## Import specialized methods:
@@ -80,7 +101,7 @@
 
     from sage.quadratic_forms.quadratic_form__local_field_invariants \
     import rational_diagonal_form, signature, local_diagonal, hasse_invariant, hasse_invariant__OMeara, \
-        is_anisotropic, is_isotropic, anisotropic_primes, compute_definiteness, \
+        is_hyperbolic, is_anisotropic, is_isotropic, anisotropic_primes, compute_definiteness, \
         is_positive_definite, is_negative_definite, is_indefinite, is_definite    ## Routines to compute p-adic field invariants
 
     from sage.quadratic_forms.quadratic_form__local_density_congruence \
@@ -96,7 +117,7 @@
     import *                                         ## Routines for computing with ternary forms
 
     from sage.quadratic_forms.quadratic_form__theta \
-    import *                                         ## Routines to compute the theta function
+    import theta_series, theta_by_pari, theta_by_cholesky         ## Routines to compute the theta function
 
     from sage.quadratic_forms.quadratic_form__siegel_product \
     import *                                         ## Routines to compute the product of all local densities
@@ -117,10 +138,11 @@
     import *                                       ## Routines to compute local masses for ZZ.
 
     from sage.quadratic_forms.quadratic_form__local_representation_conditions \
-    import *                                       ## Routines to check local representatbility of numbers
+    import *                                       ## Routines to check local representability of numbers
 
-    from sage.quadratic_forms.quadratic_form__split_local_covering \
-    import *                                       ## Routines to make a split local covering of the given quadratic form.
+    from sage.quadratic_forms.quadratic_form__split_local_covering import \
+    cholesky_decomposition, vectors_by_length, \
+    complementary_subform_to_vector, split_local_cover     ## Routines to make a split local covering of the given quadratic form.
 
     from sage.quadratic_forms.quadratic_form__automorphisms \
     import *                                       ## Routines to make automorphisms of the given quadratic form.
@@ -309,16 +331,49 @@
         creation, and not created through the usual QuadraticForm
         methods.  These fields are as good as the external process
         that made them, and are thus not guaranteed to be correct.
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [1,0,5])
+            sage: Q.list_external_initializations()
+            []
+            sage: T = Q.theta_series()
+            sage: Q.list_external_initializations()
+            []
+            sage: Q = QuadraticForm(ZZ, 2, [1,0,5], unsafe_initialization=False, number_of_automorphisms=3, determinant=0)
+            sage: Q.list_external_initializations()
+            []
+
+            sage: Q = QuadraticForm(ZZ, 2, [1,0,5], unsafe_initialization=False, number_of_automorphisms=3, determinant=0)  
+            sage: Q.list_external_initializations()
+            []
+            sage: Q = QuadraticForm(ZZ, 2, [1,0,5], unsafe_initialization=True, number_of_automorphisms=3, determinant=0)  
+            sage: Q.list_external_initializations()
+            ['number_of_automorphisms', 'determinant']            
         """
         return deepcopy(self._external_initialization_list)
 
 
     def _pari_(self):
+        """
+        Return a pari-formatted Hessian matrix for Q.
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [1,0,5])
+            sage: Q._pari_()
+            [2, 0; 0, 10]  
+        """
         return self.matrix()._pari_()
 
+
     def __repr__(self):
         """
-        Print the matrix.
+        Give a text representation for the quadratic form given as an upper-triangular matrix of coefficients.
+
+        EXAMPLES:
+            sage: QuadraticForm(ZZ, 2, [1,3,5])
+            Quadratic form in 2 variables over Integer Ring with coefficients: 
+            [ 1 3 ]
+            [ * 5 ]
         """
         n = self.dim()
         out_str = "Quadratic form in " + str(n) + " variables over " + str(self.base_ring()) + " with coefficients: \n"
@@ -335,7 +390,12 @@
 
     def _latex_(self):
         """
-        Gives a LaTeX representation.
+        Give a LaTeX representation for the quadratic form given as an upper-triangular matrix of coefficients.
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [2,3,5])
+            sage: Q._latex_()
+            'Quadratic form in 2 variables over Integer Ring with coefficients: \\newline\\left[ \\begin{array}{cc}2 & 3 &  * & 5 & \\end{array} \\right]'
         """
         n = self.dim()
         out_str = ""
@@ -623,7 +683,6 @@
             14    
             sage: M = Matrix(ZZ, 3, [1,2,3])
             sage: Q(M)
-
             Quadratic form in 1 variables over Integer Ring with coefficients: 
             [ 14 ]
 
@@ -672,6 +731,18 @@
         INPUT:
             A -- matrix
             R -- ring
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [2,3,5])
+            sage: A = Q.matrix()
+            sage: A
+            [ 4  3]
+            [ 3 10]
+            sage: Q._is_even_symmetric_matrix_(A)
+            True
+            sage: A[0,0] = 1
+            sage: Q._is_even_symmetric_matrix_(A)
+            False
         """
         if not is_Matrix(A):
             raise TypeError, "A is not a matrix."
@@ -702,11 +773,9 @@
                         x = R(A[i,j])
             except:
                 return False
-    
+
         ## Test that the diagonal is even (if 1/2 isn't in R)
-        try:
-            x = R(1/2)
-        except:
+        if not R(2).is_unit():  
             for i in range(n):
                 if not is_even(R(A[i,i])):
                     return False 
@@ -719,6 +788,13 @@
     def matrix(self):
         """
         Returns the Hessian matrix A for which Q(X) = (1/2) * X^t * A * X.
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 3, range(6))
+            sage: Q.matrix()
+            [ 0  1  2]
+            [ 1  6  4]
+            [ 2  4 10]
         """
         return self.Hessian_matrix()
 
@@ -733,12 +809,11 @@
             Quadratic form in 2 variables over Rational Field with coefficients: 
             [ 1 2 ]
             [ * 3 ]
-            sage: Q.matrix()
+            sage: Q.Hessian_matrix()
             [2 2]
             [2 6]
             sage: Q.matrix().base_ring()
-            Rational Field
-    
+            Rational Field    
         """
         mat_entries = []
         for i in range(self.dim()):
@@ -814,6 +889,15 @@
         Returns whether the quadratic form has an integral Gram matrix (with respect to its base ring).
     
         A warning is issued if the form is defined over a field, since in that case the return is trivially true.
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [7,8,9])
+            sage: Q.has_integral_Gram_matrix()
+            True
+
+            sage: Q = QuadraticForm(ZZ, 2, [4,5,6])
+            sage: Q.has_integral_Gram_matrix()
+            False
         """
         ## Warning over fields
         if is_field(self.base_ring()):
@@ -833,11 +917,20 @@
         """
         Returns the greatest common divisor of the coefficients of the
         quadratic form (as a polynomial).
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 4, range(1, 21, 2))
+            sage: Q.gcd()
+            1
+
+            sage: Q = QuadraticForm(ZZ, 4, range(0, 20, 2))
+            sage: Q.gcd()
+            2
         """
         if self.base_ring() != ZZ:
             raise TypeError, "Oops! The given quadratic form must be defined over ZZ."
 
-        return gcd(self.coefficients())
+        return GCD(self.coefficients())
 
 
     def is_primitive(self):
@@ -845,6 +938,14 @@
         Determines if the given integer-valued form is primitive
         (i.e. not an integer (>1) multiple of another integer-valued
         quadratic form).
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [2,3,4])
+            sage: Q.is_primitive()
+            True
+            sage: Q = QuadraticForm(ZZ, 2, [2,4,8])
+            sage: Q.is_primitive()
+            False
         """
         return (self.gcd() == 1)
 
@@ -852,6 +953,18 @@
     def primitive(self):
         """
         Returns a primitive version of an integer-valued quadratic form, defined over ZZ.
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [2,3,4])
+            sage: Q.primitive()
+            Quadratic form in 2 variables over Integer Ring with coefficients: 
+            [ 2 3 ]
+            [ * 4 ]
+            sage: Q = QuadraticForm(ZZ, 2, [2,4,8])
+            sage: Q.primitive()
+            Quadratic form in 2 variables over Integer Ring with coefficients: 
+            [ 1 2 ]
+            [ * 4 ]
         """
         if self.base_ring() != ZZ:
             raise TypeError, "Oops! The given quadratic form must be defined over ZZ."
@@ -867,6 +980,14 @@
         the smallest discriminant integer-valued quadratic form whose
         matrix is a scalar multiple of the inverse of the matrix of
         the given quadratic form.
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [1,2,3])
+            sage: Q.adjoint_primitive()
+            Quadratic form in 2 variables over Integer Ring with coefficients: 
+            [ 3 -2 ]
+            [ *  1 ]
+
         """
         return QuadraticForm(self.Hessian_matrix().adjoint()).primitive()        
     
@@ -875,6 +996,11 @@
     def dim(self):
         """
         Gives the number of variables of the quadratic form.
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [1,2,3])
+            sage: Q.dim()
+            2
         """
         return self.__n
 
@@ -882,6 +1008,11 @@
     def base_ring(self):
         """
         Gives the ring over which the quadratic form is defined.
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [1,2,3])
+            sage: Q.base_ring()
+            Integer Ring
         """
         return self.__base_ring
 
@@ -890,6 +1021,11 @@
         """
         Gives the matrix of upper triangular coefficients, 
         by reading across the rows from the main diagonal.
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [1,2,3])
+            sage: Q.coefficients()
+            [1, 2, 3]
         """
         return self.__coeffs
 
@@ -901,6 +1037,11 @@
 
         (Note: This is always defined over the same ring as the
         quadratic form.)
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [1,2,3])
+            sage: Q.det()
+            8
         """
         try:
             return self.__det
@@ -918,11 +1059,16 @@
         
     def Gram_det(self):
         """
-        Gives the determinant of the Gram matrix of 2*Q.
+        Gives the determinant of the Gram matrix of Q.
 
         (Note: This is defined over the fraction field of the ring of
         the quadratic form, but is oftewn not defined over the same
         ring as the quadratic form.)
+
+        EXAMPLES:
+            sage: Q = QuadraticForm(ZZ, 2, [1,2,3])
+            sage: Q.Gram_det()
+            2
         """
         return self.det() / ZZ(2**self.dim())
             
diff --git a/sage/quadratic_forms/quadratic_form__automorphisms.py b/sage/quadratic_forms/quadratic_form__automorphisms.py
--- a/sage/quadratic_forms/quadratic_form__automorphisms.py
+++ b/sage/quadratic_forms/quadratic_form__automorphisms.py
@@ -258,25 +258,36 @@
     48
     sage: 2^3 * factorial(3)
     48
-
-    sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
-    sage: Q.number_of_automorphisms()
-    384
-    sage: 2^4 * factorial(4)
-    384
+    sage: len(Q.automorphisms())
+    48
 
     sage: Q = DiagonalQuadraticForm(ZZ, [1,3,5,7])
     sage: Q.number_of_automorphisms()
     16
+    sage: aut = Q.automorphisms()
+    sage: len(aut)
+    16
+    sage: print([Q(M) == Q for M in aut])
+    [True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]
 
-    #sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1,1])
-    #sage: time Q.number_of_automorphisms()
-    #CPU times: user 119.44 s, sys: 0.87 s, total: 120.31 s
-    #Wall time: 121.80
-    #3840
-    #sage: 2^5 * factorial(5)
-    #3840
+    sage: Q = QuadraticForm(ZZ, 3, [2, 1, 2, 2, 1, 3])
+    sage: Q.automorphisms()
+    [[1 0 0]
+    [0 1 0]
+    [0 0 1], [-1  0  0]
+    [ 0 -1  0]
+    [ 0  0 -1]]
+
+    sage: Q = DiagonalQuadraticForm(ZZ, [1, -1])
+    sage: Q.automorphisms()
+    Traceback (most recent call last):
+    ...
+    ValueError: not a definite form in QuadraticForm.automorphisms()
     """
+    ## only for definite forms
+    if not self.is_definite():
+        raise ValueError, "not a definite form in QuadraticForm.automorphisms()"
+
     ## Check for a cached value
     try:
         return self.__automorphisms
@@ -294,6 +305,7 @@
 
     ## Make the matrix A:e_i |--> v_i to our new basis.
     A = Matrix(basis).transpose()
+    Ainv = A.inverse()
     #A1 = A.inverse() * A.det()
     #Q1 = A1.transpose() * self.matrix() * A1       ## This is the matrix of Q
     #Q = self.matrix() * A.det()**2
@@ -321,7 +333,7 @@
         #print M
         #print
         if M.transpose() * Q3 * M == Q2:       ## THIS DOES THE SAME THING! =(
-            Auto_list.append(M)
+            Auto_list.append(M * Ainv)
 
 
     ## Cache the answer and return the list
@@ -352,7 +364,23 @@
         48
         sage: Q.list_external_initializations()
         []
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+        sage: Q.number_of_automorphisms()
+        384
+        sage: 2^4 * factorial(4)
+        384
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, -1])
+        sage: Q.number_of_automorphisms()
+        Traceback (most recent call last):
+        ...
+        ValueError: not a definite form in QuadraticForm.number_of_automorphisms()
     """
+    ## only for definite forms
+    if not self.is_definite():
+        raise ValueError, "not a definite form in QuadraticForm.number_of_automorphisms()"
+
     ## Try to use the cached version if we can
     if not recompute:
         try:
@@ -377,6 +405,12 @@
 def number_of_automorphisms__souvigner(self):
     """
     Uses the Souvigner code to compute the number of automorphisms.    
+
+    sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1,1])
+    sage: Q.number_of_automorphisms__souvigner()
+    3840
+    sage: 2^5 * factorial(5)
+    3840
     """
     ## Write an input text file
     F_filename = '/tmp/tmp_isom_input' + str(random()) + ".txt"
@@ -453,18 +487,18 @@
 
 
 
-
-def Nipp_automorphism_testing(self):
-    """
-    Testing the automorphism routine agains Nipp's Tables
-
-        --- MOVE THIS ELSEWHERE!!! ---
-
-    """
-    for i in range(20):
-        Q = QuadraticForm(ZZ, 4, Nipp[i][2])
-        my_num = Q.number_of_automorphisms()
-        nipp_num = Nipp.number_of_automorphisms(i)
-        print "    i = " + str(i) + "  my_num = " + str(my_num) + "  nipp_num = " + str(nipp_num)
+### TODO
+# def Nipp_automorphism_testing(self):
+#     """
+#     Testing the automorphism routine agains Nipp's Tables
+# 
+#         --- MOVE THIS ELSEWHERE!!! ---
+# 
+#     """
+#     for i in range(20):
+#         Q = QuadraticForm(ZZ, 4, Nipp[i][2])
+#         my_num = Q.number_of_automorphisms()
+#         nipp_num = Nipp.number_of_automorphisms(i)
+#         print "    i = " + str(i) + "  my_num = " + str(my_num) + "  nipp_num = " + str(nipp_num)
+#     
     
-    
diff --git a/sage/quadratic_forms/quadratic_form__equivalence_testing.py b/sage/quadratic_forms/quadratic_form__equivalence_testing.py
--- a/sage/quadratic_forms/quadratic_form__equivalence_testing.py
+++ b/sage/quadratic_forms/quadratic_form__equivalence_testing.py
@@ -3,9 +3,11 @@
 from sage.rings.arith import hilbert_symbol, prime_divisors, is_prime, valuation, GCD, legendre_symbol
 from sage.rings.integer_ring import ZZ
 
+from quadratic_form import is_QuadraticForm
 from extras import hilbert_symbol_rational
 from quadratic_form__genus import CS_genus_symbol_list
 
+
 from sage.misc.misc import SAGE_ROOT
 
 import tempfile, os
@@ -21,6 +23,15 @@
 def is_globally_equivalent__souvigner(self, other, return_transformation=False):
     """
     Uses the Souvigner code to compute the number of automorphisms.    
+
+        sage: Q = QuadraticForm(ZZ, 3, [1, 0, -1, 2, -1, 5])
+        sage: Q1 = QuadraticForm(ZZ, 3, [8, 6, 5, 3, 4, 2])
+        sage: M = Q.is_globally_equivalent__souvigner(Q1, True) ; M
+        [ 0  0 -1]
+        [ 1  0  0]
+        [-1  1  1]
+        sage: Q1(M) == Q
+        True
     """
     ## Write an input text file
     F_filename = '/tmp/tmp_isom_input' + str(random()) + ".txt"
@@ -55,7 +66,7 @@
     #os.system("less " + F.name)
 
     ## Call the Souvigner automorphism code
-    souvigner_isom_path = SAGE_ROOT + "/devel/sage-qfdevel/sage/quadratic_forms/automorphisms/ISOM32" 
+    souvigner_isom_path = SAGE_ROOT + "/local/bin/Souvigner_ISOM" 
     G1 = tempfile.NamedTemporaryFile(prefix='tmp_isom_ouput', suffix=".txt")
     #print "Output filename = ", G1.name
     #print  "Executing the shell command:   " + souvigner_isom_path + " '" +  F.name + "' > '" + G1.name + "'"
@@ -91,7 +102,11 @@
             G1.close()
             G2.close()
             os.system("rm -f " + F_filename)
-            return True, M
+            if return_transformation:
+                return M.transpose()
+            else:
+                return True
+            #return True, M
 
     ## Raise and error if we're here:
     raise RuntimeError, "Oops! There is a problem..."
@@ -116,16 +131,42 @@
         sage: Q1 = Q(M)
         sage: Q.is_globally_equivalent_to(Q1)
         True
-        sage: Q.is_globally_equivalent_to(Q1, return_matrix=True)
-        [1 2 0 0]
-        [0 1 0 0]
-        [0 0 1 0]
-        [0 0 0 1]
-        sage: Q.is_globally_equivalent_to(Q1, return_matrix=True) == M
+        sage: MM = Q.is_globally_equivalent_to(Q1, return_matrix=True)
+        sage: Q(MM) == Q1
         True
+        sage: Q1 = QuadraticForm(ZZ, 3, [1, 0, -1, 2, -1, 5])
+        sage: Q2 = QuadraticForm(ZZ, 3, [2, 1, 2, 2, 1, 3])
+        sage: Q3 = QuadraticForm(ZZ, 3, [8, 6, 5, 3, 4, 2])
+        sage: Q1.is_globally_equivalent_to(Q2)
+        False
+        sage: Q1.is_globally_equivalent_to(Q3)
+        True
+        sage: M = Q1.is_globally_equivalent_to(Q3, True) ; M
+        [-1 -1  0]
+        [ 1  1  1]
+        [-1  0  0]
+        sage: Q1(M) == Q3
+        True
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, -1])
+        sage: Q.is_globally_equivalent_to(Q)
+        Traceback (most recent call last):
+        ...
+        ValueError: not a definite form in QuadraticForm.is_globally_equivalent_to()
     """
+    ## only for definite forms
+    if not self.is_definite():
+        raise ValueError, "not a definite form in QuadraticForm.is_globally_equivalent_to()"
+
+    ## Check that other is a QuadraticForm
+    #if not isinstance(other, QuadraticForm):
+    if not is_QuadraticForm(other): 
+        raise TypeError, "Oops!  You must compare two quadratic forms, but the argument is not a quadratic form. =("
+
+
     ## Now use the Souvigner code by default! =)
-    return self.is_globally_equivalent__souvigner(other)
+    return other.is_globally_equivalent__souvigner(self, return_matrix)    ## Note: We switch this because teh Souvigner code has the opposite mapping convention to us.  (It takes the second argument to the first!)
+
+
 
     ## ----------------------------------  Unused Code below  ---------------------------------------------------------
 
@@ -182,8 +223,16 @@
     p-adic integers for every prime p.
 
     This works by comparing the local Jordan decompositions at every
-    prime, and the dimension and signarure at the real place.
-    
+    prime, and the dimension and signature at the real place.
+
+    EXAMPLES:
+
+        sage: Q1 = QuadraticForm(ZZ, 3, [1, 0, -1, 2, -1, 5])
+        sage: Q2 = QuadraticForm(ZZ, 3, [2, 1, 2, 2, 1, 3])
+        sage: Q1.is_globally_equivalent_to(Q2)
+        False
+        sage: Q1.is_locally_equivalent_to(Q2)
+        True
     """
     ## TO IMPLEMENT:
     if self.det() == 0:
@@ -226,6 +275,24 @@
     """
     Determines if the given quadratic form has a Jordan decomposition
     equivalent to that of self.
+
+    sage: Q1 = QuadraticForm(ZZ, 3, [1, 0, -1, 1, 0, 3])
+    sage: Q2 = QuadraticForm(ZZ, 3, [1, 0, 0, 2, -2, 6])
+    sage: Q3 = QuadraticForm(ZZ, 3, [1, 0, 0, 1, 0, 11])
+    sage: [Q1.level(), Q2.level(), Q3.level()]
+    [44, 44, 44]
+    sage: Q1.has_equivalent_Jordan_decomposition_at_prime(Q2,2)
+    False
+    sage: Q1.has_equivalent_Jordan_decomposition_at_prime(Q2,11)
+    False
+    sage: Q1.has_equivalent_Jordan_decomposition_at_prime(Q3,2)
+    False
+    sage: Q1.has_equivalent_Jordan_decomposition_at_prime(Q3,11)
+    True 
+    sage: Q2.has_equivalent_Jordan_decomposition_at_prime(Q3,2)
+    True 
+    sage: Q2.has_equivalent_Jordan_decomposition_at_prime(Q3,11)
+    False
     """
     ## Sanity Checks
     #if not isinstance(other, QuadraticForm):
@@ -275,7 +342,7 @@
                 return False
 
         ## DIAGNOSTIC
-        print "Passed the Jordan invariant test."
+        #print "Passed the Jordan invariant test."
 
 
         ## Use O'Meara's isometry test 93:29 on p277.
@@ -284,7 +351,7 @@
         ## List of norms, scales, and dimensions for each i
         scale_list = [ZZ(2)**self_jordan[i][0]  for i in range(t)]
         norm_list = [ZZ(2)**(self_jordan[i][0] + valuation(GCD(self_jordan[i][1].coefficients()), 2))  for i in range(t)]
-        dim_list = [GCD(self_jordan[i][1].dim())  for i in range(t)]
+        dim_list = [(self_jordan[i][1].dim())  for i in range(t)]
 
         ## List of Hessian determinants and Hasse invariants for each Jordan (sub)chain
         ## (Note: This is not the same as O'Meara's Gram determinants, but ratios are the same!)  -- NOT SO GOOD...
@@ -313,14 +380,14 @@
 
 
         ## DIAGNOSTIC
-        print "scale_list = ", scale_list
-        print "norm_list = ", norm_list
-        print "dim_list = ", dim_list
-        print
-        print "self_chain_det_list = ", self_chain_det_list
-        print "other_chain_det_list = ", other_chain_det_list
-        print "self_hasse_chain_list = ", self_hasse_chain_list
-        print "other_hasse_chain_det_list = ", other_hasse_chain_list
+        #print "scale_list = ", scale_list
+        #print "norm_list = ", norm_list
+        #print "dim_list = ", dim_list
+        #print
+        #print "self_chain_det_list = ", self_chain_det_list
+        #print "other_chain_det_list = ", other_chain_det_list
+        #print "self_hasse_chain_list = ", self_hasse_chain_list
+        #print "other_hasse_chain_det_list = ", other_hasse_chain_list
 
         
         ## Test O'Meara's two conditions
@@ -331,7 +398,7 @@
             if modulus > 8:
                    modulus = 8 
             if (modulus > 1) and (((self_chain_det_list[i] / other_chain_det_list[i]) % modulus) != 1):
-                print "Failed when i =", i, " in condition 1."
+                #print "Failed when i =", i, " in condition 1."
                 return False
             
             ## Check O'Meara's conditon (ii) when appropriate
@@ -340,7 +407,7 @@
                 ##  Corrected ## if self_hasse_chain_list[i] * other_hasse_chain_list[i] * hilbert_symbol(-self_chain_det_list[i], norm_list[i], 2) != 1:
                 if self_hasse_chain_list[i] * hilbert_symbol_rational(norm_list[i] * other_chain_det_list[i], -self_chain_det_list[i], 2) \
                        != other_hasse_chain_list[i] * hilbert_symbol_rational(norm_list[i], -other_chain_det_list[i], 2):      ## Nipp conditions
-                    print "Failed when i =", i, " in condition 2."
+                    #print "Failed when i =", i, " in condition 2."
                     return False
 
 
diff --git a/sage/quadratic_forms/quadratic_form__local_density_congruence.py b/sage/quadratic_forms/quadratic_form__local_density_congruence.py
--- a/sage/quadratic_forms/quadratic_form__local_density_congruence.py
+++ b/sage/quadratic_forms/quadratic_form__local_density_congruence.py
@@ -383,6 +383,132 @@
 
 
 
+
+def local_good_density_congruence_even__experimental(self, p, m, Zvec, NZvec):
+    """
+    Finds the Good-type local density of Q representing m at p.  
+    (Assuming that p = 2 and Q is given in local normal form.) 
+
+    mpq_class Matrix_mpz::local_good_density_congruence_even(const mpz_class & p, const mpz_class & m, 
+                                             const valarray<size_t> & Zvec, const valarray<size_t> & NZvec) const
+    """
+    #print " Break 0" 
+    #print "\n Q is : " + str(Q)
+
+    n = self.dim()
+  
+  
+    ## Assuming Q is diagonal, trim it to ensure it's non-degenerate mod 8      <--- ??? Do we really assume that Q is diagonal?!?!?  =(
+    Qtrimvec = [] 
+
+    #print " Break 0.1" 
+
+    ## Find the indices of the non-zero blocks mod 8
+    for i in range(n):
+ 
+        ## DIAGNOSTIC
+        verbose(" i = " + str(i))
+        verbose(" n = " + str(n))
+        verbose(" Qtrimvec = " + str(Qtrimvec))
+
+        nz_flag = False
+
+        if  ((self[i,i] % 8) != 0):  
+            nz_flag = True
+        else:
+            #print " here 1" 
+            if ((i == 0) and ((self[i,i+1] % 8) != 0)):
+                nz_flag = True
+            else:
+                #print " here 2" << endl;
+                if ((i == n-1) and ((self[i-1,i] % 8) != 0)):
+                    nz_flag = True
+                else:
+                    #print " here 3" << endl;
+                    if ( (i > 0)  and  (i < n-1)  and  (((self[i,i+1] % 8) != 0) or ((self[i-1,i] % 8) != 0)) ):
+                        nz_flag = True
+
+      
+        if (nz_flag == True):
+            Qtrimvec += [i]
+
+
+    #print " Break 1" 
+
+
+    ## DEBUGGING: Quick tests to make sure the form isn't zero mod 8
+    if (Qtrimvec == []):
+        raise RuntimeError, "Oh no!  The quadratic form should always be non-degenerate mod 8... =("
+  
+
+    Qtrim = self.extract_variables(Qtrimvec) 
+
+
+    ## DEBUGGING: Quick tests to make sure the extracted form isn't zero mod 8
+    assert(Qtrim.dim() > 0);
+
+    #print " Break 2" 
+
+
+    ## Construct the big and small matrices: 
+    ## -------------------------------------
+
+    ## Construct new congruence condition indices for the trimmed matrix
+    trimZvec = self.reindex_vector_from_extraction(Zvec, Qtrimvec) 
+    trimNZvec = self.reindex_vector_from_extraction(NZvec, Qtrimvec)
+
+    ## Make the trimmed congruence vector 
+    new_vec = list(Set(Zvec + NZvec))
+    trim_vec = self.reindex_vector_from_extraction(new_vec, Qtrimvec)
+
+    ## DIAGNOSTIC
+    verbose("")
+    verbose("Zvec = " + str(Zvec))
+    verbose("NZvec = " + str(NZvec))
+    verbose("new_vec = " + str(new_vec))
+    verbose("")
+
+
+    ## DIAGNOSTIC
+    verbose("\n Q is : " + str(self))
+    verbose(" m is : " + str(m))
+    verbose(" Qtrim is : " + str(Qtrim))
+    verbose(" Qtrimvec is : " + str(Qtrimvec))
+    verbose(" trimZvec is : " + str(trimZvec))
+    verbose(" trimNZvec is : " + str(trimNZvec))
+
+
+    ## DEBUGGING: Check that partlyfreenum is in range...
+    if not (len(new_vec) >= len(trim_vec)):
+        raise RuntimeError, "Oh no!  Some variable called 'partlyfreenum' is out of range. =("
+
+  
+    ## Compute the number of different free components 
+    partlyfreenum = len(new_vec) - len(trim_vec)
+    veryfreenum = (n - len(Qtrimvec)) - partlyfreenum
+
+
+    ## In the free part, each component with a congruence condition contrubite a factor of 4, 
+    ## while components with no congruence conditions contribute a factor of 8.
+
+    total = (4 ** partlyfreenum) * (8 ** veryfreenum) \
+        * Qtrim.count_local_good_type(2, 3, m, trimZvec, trimNZvec) 
+    good_density = ZZ(total) / ZZ(8**(n-1))
+  
+  
+    ## DIAGNOSTIC
+    verbose(" partlyfreenum = " + str(partlyfreenum))
+    verbose(" veryfreenum = " + str(veryfreenum))
+    verbose(" Qtrim.count_local_good_type(2, 3, m, trimZvec, trimNZvec) = " + str(Qtrim.count_local_good_type(2, 3, m, trimZvec, trimNZvec)))
+    verbose(" total = " + str(total))
+    verbose("    total has type ", type(total))
+    verbose(" denominator = " + str(8**(n-1)))
+    verbose(" Good Density = " + str(good_density))
+
+    return good_density 
+
+
+
     ############################################
      ## Note: Assumes all forms are primitive       <== What does this mean?!?
     ############################################
diff --git a/sage/quadratic_forms/quadratic_form__local_field_invariants.py b/sage/quadratic_forms/quadratic_form__local_field_invariants.py
--- a/sage/quadratic_forms/quadratic_form__local_field_invariants.py
+++ b/sage/quadratic_forms/quadratic_form__local_field_invariants.py
@@ -242,7 +242,11 @@
             - direct sum formulas (Lemma 2.3 on p58)
 
     EXAMPLES:
-        sage: Q = QuadraticForm(ZZ, [1,1])
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1])
+
+        sage: Q.is_hyperbolic("infinity")
+        False
+
         sage: Q.is_hyperbolic(2)
         False
 
@@ -271,7 +275,14 @@
     ## (Note: since the dimension is even, the extra powers of 2 in 
     ##        self.det() := Det(2*Q) don't affect the answer!) 
     m = ZZ(self.dim() / 2) 
-    return IsPadicSquare(self.det() * (-1)**m, p) and (self.hasse_invariant(p) == (-1)**m)
+    if p == "infinity":
+        return (self.signature() == 0)
+
+    elif p == 2:
+        return IsPadicSquare(self.det() * (-1)**m, p) and (self.hasse_invariant(p) == (-1)**m)    ## Actually, this -1 is the Hilbert symbol (-1,-1)_p
+
+    else:
+        return IsPadicSquare(self.det() * (-1)**m, p) and (self.hasse_invariant(p) == 1)
 
 
 
@@ -417,35 +428,34 @@
         self.__definiteness_string = "zero"
         return
 
-    ## Deal with degernerate forms
+    ## Deal with degenerate forms
     if self.det() == 0:
         self.__definiteness_string = "degenerate"
         return
    
 
     ## Check the sign of the ratios of consecutive determinants of the upper triangular r x r submatrices
-    ul = self[0,0]
-    subdet_list = [ul]
-    for r in range(1,n):
-        I = range(r+1)
+    first_coeff = self[0,0]
+    for r in range(1,n+1):
+        I = range(r)
         new_det = M.matrix_from_rows_and_columns(I, I).det()
 
-        ## Sanity Check for degenerateness
-        if new_det == 0:
-            raise RuntimeError, "This shouldn't happen, since degernerate forms are not allowed at this point."
-
-        ## Check for indefiniteness
-        subdet_list.append(new_det)
-        if not ((subdet_list[-1] / subdet_list[-2]) * ul > 0):
+        ## Check for a (non-degenerate) zero -- so it's indefinite 
+        if new_det == 0:        
             self.__definiteness_string = "indefinite"
             return
-        
+
+        ## Check for a change of signs in the upper r x r submatrix -- so it's indefinite
+        if sgn(first_coeff)**r != sgn(new_det):
+            self.__definiteness_string = "indefinite"
+            return
+
     ## Here all ratios of determinants have the correct sign, so the matrix is (pos or neg) definite.
-    if ul > 0:
+    if first_coeff > 0:
         self.__definiteness_string = "pos_def"
     else:
         self.__definiteness_string = "neg_def"
-
+        
 
 
 
@@ -551,7 +561,7 @@
         def_str = self.__definiteness_string
 
     ## Return the answer
-    return def_str == "indef"
+    return def_str == "indefinite"
 
 
 def is_definite(self):
diff --git a/sage/quadratic_forms/quadratic_form__local_normal_form.py b/sage/quadratic_forms/quadratic_form__local_normal_form.py
--- a/sage/quadratic_forms/quadratic_form__local_normal_form.py
+++ b/sage/quadratic_forms/quadratic_form__local_normal_form.py
@@ -289,6 +289,12 @@
 
 
         sage: Q2 = QuadraticForm(ZZ, 2, [1,1,1])
+        sage: Q2.jordan_blocks_by_scale_and_unimodular(2)
+        [(-1,
+          Quadratic form in 2 variables over Integer Ring with coefficients:
+        [ 2 2 ]
+        [ * 2 ]
+        )]
         sage: Q = Q2 + Q2.scale_by_factor(2)
         sage: Q.jordan_blocks_by_scale_and_unimodular(2)
         [(-1,
@@ -358,7 +364,7 @@
         i += block_size
 
     ## Add the last block
-    tmp_Jordan_list += [(start_scale, Q1.extract_variables(range(start_ind, n)).scale_by_factor(1/ZZ(p**(start_scale))))]
+    tmp_Jordan_list += [(start_scale, Q1.extract_variables(range(start_ind, n)).scale_by_factor(ZZ(1) / QQ(p)**(start_scale)))]
 
 
     ## Cache the result
@@ -389,12 +395,20 @@
     EXAMPLES:
         sage: Q = QuadraticForm(ZZ, 3, [2, -2, 0, 3, -5, 4])
         sage: Q.jordan_blocks_in_unimodular_list_by_scale_power(2)
-        [Quadratic form in 2 variables over Integer Ring with coefficients:
-        [ 3 0 ]
-        [ * 15 ]
+        Traceback (most recent call last):
+        ...
+        TypeError: Oops!  The given quadratic form has a Jordan component with a negative scale exponent!
+        This routine requires an integer-matrix quadratic form for the output indexing to work properly!
+
+        sage: Q.scale_by_factor(2).jordan_blocks_in_unimodular_list_by_scale_power(2)
+        [Quadratic form in 2 variables over Integer Ring with coefficients: 
+        [ 0 2 ]
+        [ * 0 ]
         ,
-         Quadratic form in 1 variables over Integer Ring with coefficients:
-        [ 27 ]
+        Quadratic form in 0 variables over Integer Ring with coefficients: 
+        ,
+        Quadratic form in 1 variables over Integer Ring with coefficients: 
+        [ 345 ]
         ]
 
         sage: Q.jordan_blocks_in_unimodular_list_by_scale_power(3)
diff --git a/sage/quadratic_forms/quadratic_form__local_representation_conditions.py b/sage/quadratic_forms/quadratic_form__local_representation_conditions.py
--- a/sage/quadratic_forms/quadratic_form__local_representation_conditions.py
+++ b/sage/quadratic_forms/quadratic_form__local_representation_conditions.py
@@ -41,7 +41,7 @@
              Reals:   [0, +Infinity]
              p = 2:   [0, 0, 0, +Infinity, 0, 0, 0, 0]
         sage: E = [m  for m in range(100)  if not Q3.is_locally_represented_number(m)]
-        sage: E1 = [m  for m in range(100)  if m / 2**(2*floor(valuation(m,2)/2)) % 8 == 7]
+        sage: E1 = [m  for m in range(1,100)  if m / 2**(2*floor(valuation(m,2)/2)) % 8 == 7]
         sage: E == E1
         True
         sage: E
@@ -87,6 +87,14 @@
         they don't already exist).  The recompute_flag overrides the
         previously computed conditions if they exist, and stores the
         new conditions.
+
+        EXAMPLES:
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+            sage: from sage.quadratic_forms.quadratic_form__local_representation_conditions import QuadraticFormLocalRepresentationConditions
+            sage: QuadraticFormLocalRepresentationConditions(Q)
+            This form represents the p-adic integers Z_p for all primes p except 
+            [].  For these and the reals, we have:
+                 Reals:   [0, +Infinity]
         """
 
         ## Check that the form Q is integer-valued (we can relax this later)
@@ -183,6 +191,14 @@
 
         TO DO:  Improve the output for the real numbers, and special output for locally unversality. 
         Also give names to the squareclasses, so it's clear what the output means! =)
+
+        EXAMPLES:
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,1])
+            sage: from sage.quadratic_forms.quadratic_form__local_representation_conditions import QuadraticFormLocalRepresentationConditions
+            sage: C = QuadraticFormLocalRepresentationConditions(Q)
+            sage: C.__repr__()
+            'This 2-dimensional form represents the p-adic integers of even\nvaluation for all primes p except [2].\nFor these and the reals, we have:\n     Reals:   [0, +Infinity]\n     p = 2:   [0, +Infinity, 0, +Infinity, 0, +Infinity, 0, +Infinity]\n'
+
         """
         if self.dim == 0:
             out_str = "This 0-dimensional form only represents zero."
@@ -259,6 +275,11 @@
             a list of integers
 
         EXAMPLES:
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1])                                                                                                      
+            sage: from sage.quadratic_forms.quadratic_form__local_representation_conditions import QuadraticFormLocalRepresentationConditions
+            sage: C = QuadraticFormLocalRepresentationConditions(Q)
+            sage: C.squareclass_vector(5)
+            [1, 2, 5, 10]
         """
         if p == infinity:
             return [1, -1]
@@ -273,6 +294,15 @@
     def local_conditions_vector_for_prime(self, p):
         """
         Returns a local representation vector for the (possibly infinite) prime p.
+
+        EXAMPLES:
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1])
+            sage: from sage.quadratic_forms.quadratic_form__local_representation_conditions import QuadraticFormLocalRepresentationConditions
+            sage: C = QuadraticFormLocalRepresentationConditions(Q)
+            sage: C.local_conditions_vector_for_prime(2)
+            [2, 0, 0, 0, +Infinity, 0, 0, 0, 0]
+            sage: C.local_conditions_vector_for_prime(3)
+            [3, 0, 0, 0, 0, None, None, None, None]
         """
         ## Check if p is non-generic
         if p in self.exceptional_primes:
@@ -313,6 +343,17 @@
     def is_universal_at_prime(self, p):
         """
         Determines if the (integer-valued/rational) quadratic form represents all of Z_p.
+
+        EXAMPLES:
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1])
+            sage: from sage.quadratic_forms.quadratic_form__local_representation_conditions import QuadraticFormLocalRepresentationConditions
+            sage: C = QuadraticFormLocalRepresentationConditions(Q)
+            sage: C.is_universal_at_prime(2)
+            False
+            sage: C.is_universal_at_prime(3)
+            True
+            sage: C.is_universal_at_prime(infinity)
+            False
         """
         ## Check if the prime behaves generically for n >= 3.
         if (self.dim >= 3) and not (p in self.exceptional_primes):
@@ -333,7 +374,7 @@
         v = self.local_conditions_vector_for_prime(p)
         Zp_univ_flag = True
         for nu in v[1:]:
-            if not ((nu >= 0) or (nu == None)):
+            if (nu != None) and ((nu != 0) or (nu == infinity)):
                 Zp_univ_flag = False
         return Zp_univ_flag
 
@@ -341,6 +382,19 @@
     def is_universal_at_all_finite_primes(self):
         """
         Determines if the quadratic form represents Z_p for all finite/non-archimedian primes.
+
+        EXAMPLES:
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1])
+            sage: from sage.quadratic_forms.quadratic_form__local_representation_conditions import QuadraticFormLocalRepresentationConditions
+            sage: C = QuadraticFormLocalRepresentationConditions(Q)
+            sage: C.is_universal_at_all_finite_primes()
+            False
+
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+            sage: from sage.quadratic_forms.quadratic_form__local_representation_conditions import QuadraticFormLocalRepresentationConditions
+            sage: C = QuadraticFormLocalRepresentationConditions(Q)
+            sage: C.is_universal_at_all_finite_primes()
+            True
         """
         ## Check if dim <= 2.
         if self.dim <= 2:
@@ -349,7 +403,7 @@
         ## Check that all non-generic finite primes are universal
         univ_flag = True
         for p in self.exceptional_primes[1:]:      ## Omit p = "infinity" here
-            univ_flag = univ_flag and is_universal_at_prime(p)
+            univ_flag = univ_flag and self.is_universal_at_prime(p)
         return univ_flag
 
 
@@ -357,6 +411,23 @@
         """
         Determines if the quadratic form represents Z_p for all
         finite/non-archimedian primes, and represents all real numbers.
+        EXAMPLES:
+            sage: from sage.quadratic_forms.quadratic_form__local_representation_conditions import QuadraticFormLocalRepresentationConditions
+
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1])
+            sage: C = QuadraticFormLocalRepresentationConditions(Q)
+            sage: C.is_universal_at_all_places()
+            False
+
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
+            sage: C = QuadraticFormLocalRepresentationConditions(Q)
+            sage: C.is_universal_at_all_places()
+            False
+
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1,-1])
+            sage: C = QuadraticFormLocalRepresentationConditions(Q)
+            sage: C.is_universal_at_all_places()
+            True
         """
         ## Check if dim <= 2.
         if self.dim <= 2:
@@ -374,6 +445,22 @@
         """
         Determines if the rational number m is locally represented by the
         quadratic form at the (possibly infinite) prime p.
+
+        EXAMPLES:
+            sage: from sage.quadratic_forms.quadratic_form__local_representation_conditions import QuadraticFormLocalRepresentationConditions
+
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1])
+            sage: C = QuadraticFormLocalRepresentationConditions(Q)
+            sage: C.is_locally_represented_at_place(7, 2)
+            False
+            sage: C.is_locally_represented_at_place(1, 3)
+            True
+            sage: C.is_locally_represented_at_place(-1, infinity)
+            False
+            sage: C.is_locally_represented_at_place(1, infinity)
+            True
+            sage: C.is_locally_represented_at_place(0, infinity)
+            True
         """
         ## Sanity Check
         if not m in QQ:
@@ -419,7 +506,21 @@
 
     def is_locally_represented(self, m):
         """
-        Determines if the rational number m is locally represented by the quadratic form.
+        Determines if the rational number m is locally represented by the quadratic form (allowing vectors with coeffs in Z_p at all places).
+
+        EXAMPLES:
+            sage: from sage.quadratic_forms.quadratic_form__local_representation_conditions import QuadraticFormLocalRepresentationConditions
+
+            sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1])
+            sage: C = QuadraticFormLocalRepresentationConditions(Q)
+            sage: C.is_locally_represented(7)
+            False
+            sage: C.is_locally_represented(28)
+            False
+            sage: C.is_locally_represented(11)
+            True
+            sage: C.is_locally_represented(QQ(1)/QQ(2))
+            False
         """
         ## Representing zero
         if m == 0:
diff --git a/sage/quadratic_forms/quadratic_form__mass__Conway_Sloane_masses.py b/sage/quadratic_forms/quadratic_form__mass__Conway_Sloane_masses.py
--- a/sage/quadratic_forms/quadratic_form__mass__Conway_Sloane_masses.py
+++ b/sage/quadratic_forms/quadratic_form__mass__Conway_Sloane_masses.py
@@ -47,6 +47,22 @@
         [ * 2 3 ]
         [ * * 1 ]
         sage: Q.parity()
+        'even'
+
+        sage: Q = QuadraticForm(ZZ, 3, [4, -2, 0, 2, 2, 2]); Q
+        Quadratic form in 3 variables over Integer Ring with coefficients:
+        [ 4 -2 0 ]
+        [ * 2 2 ]
+        [ * * 2 ]
+        sage: Q.parity()
+        'even'
+
+        sage: Q = QuadraticForm(ZZ, 3, [4, -2, 0, 2, 2, 1]); Q
+        Quadratic form in 3 variables over Integer Ring with coefficients:
+        [ 4 -2 0 ]
+        [ * 2 2 ]
+        [ * * 1 ]
+        sage: Q.parity()
         'odd'
 
     """
@@ -91,6 +107,15 @@
     form represents no odd integers.  For more details, see parity().
 
     Requires that Q is defined over ZZ.
+
+    EXAMPLES:
+
+        sage: Q = QuadraticForm(ZZ, 2, [1, 0, 1])
+        sage: Q.is_even()
+        False
+        sage: Q = QuadraticForm(ZZ, 2, [1, 1, 1])
+        sage: Q.is_even()
+        True
     """
     return self.parity(allow_rescaling_flag) == "even"
 
@@ -101,6 +126,15 @@
     form represents some odd integers.  For more details, see parity().
 
     Requires that Q is defined over ZZ.
+
+    EXAMPLES:
+
+        sage: Q = QuadraticForm(ZZ, 2, [1, 0, 1])
+        sage: Q.is_odd()
+        True
+        sage: Q = QuadraticForm(ZZ, 2, [1, 1, 1])
+        sage: Q.is_odd()
+        False
     """
     return self.parity(allow_rescaling_flag) == "odd"
 
@@ -460,7 +494,7 @@
 
         sage: Q = DiagonalQuadraticForm(ZZ, [7,1,1])
         sage: Q.conway_mass()
-        1/16
+        3/16
 
         sage: Q = QuadraticForm(ZZ, 3, [7, 2, 2, 2, 0, 2]) + DiagonalQuadraticForm(ZZ, [1])
         sage: Q.conway_mass()
diff --git a/sage/quadratic_forms/quadratic_form__mass__Siegel_densities.py b/sage/quadratic_forms/quadratic_form__mass__Siegel_densities.py
--- a/sage/quadratic_forms/quadratic_form__mass__Siegel_densities.py
+++ b/sage/quadratic_forms/quadratic_form__mass__Siegel_densities.py
@@ -139,6 +139,16 @@
 
     OUTPUT:
         a rational number.
+
+    EXAMPLES:
+        sage: Q = QuadraticForm(ZZ, 3, [1,0,0,1,0,1])
+        sage: Q.Pall_mass_density_at_odd_prime(3)
+        [(0, Quadratic form in 3 variables over Integer Ring with coefficients: 
+        [ 1 0 0 ]
+        [ * 1 0 ]
+        [ * * 1 ]
+        )] [(0, 3, 8)] [8/9] 8/9
+        8/9
     """
     ## Check that p is a positive prime -- unnecessary since it's done implicitly in the next step. =)
     if p<=2:
@@ -375,4 +385,4 @@
     ct = sum([1  for x in mrange([2**k] * (n**2))  if Q1(MS(x)) == Q1])   ## Count the solutions mod 2^k
     two_mass = ZZ(1)/2 * (ZZ(ct) / ZZ(2)**(k*n*(n-1)/2))
     return two_mass 
-    
\ No newline at end of file
+    
diff --git a/sage/quadratic_forms/quadratic_form__reduction_theory.py b/sage/quadratic_forms/quadratic_form__reduction_theory.py
--- a/sage/quadratic_forms/quadratic_form__reduction_theory.py
+++ b/sage/quadratic_forms/quadratic_form__reduction_theory.py
@@ -7,13 +7,22 @@
 from sage.rings.integer_ring import ZZ
 
 
-def reduced_binary_form(self):
+def reduced_binary_form1(self):
     """
     Reduce the form ax^2 + bxy+cy^2 to satisfy the reduced condition
         |b| <= a <= c, with b >= 0 if a = c. 
     This reduction occurs within the proper class, so all
     transformations are taken to have det = 1.
 
+    EXAMPLES:
+
+        sage: QuadraticForm(ZZ,2,[5,5,2]).reduced_binary_form1()
+        (Quadratic form in 2 variables over Integer Ring with coefficients: 
+        [ 2 -1 ]
+        [ * 2 ]
+        ,
+        [ 0 -1]
+        [ 1  1])
     """
     if self.dim() != 2:
         raise TypeError, "This must be a binary form for now..."
@@ -57,8 +66,15 @@
         [. b d]
         [. . c]
 
+    EXAMPLES:
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, 1, 1])
+        sage: Q.reduced_ternary_form__Dickson()
+        Traceback (most recent call last):
+        ...
+        NotImplementedError: TO DO
     """
-    pass
+    raise NotImplementedError, "TO DO"
 
 
 
@@ -66,6 +82,16 @@
     """
     Find a form which is reduced in the sense that no further binary
     form reductions can be done to reduce the original form.
+
+    EXAMPLES:
+
+        sage: QuadraticForm(ZZ,2,[5,5,2]).reduced_binary_form()
+        (Quadratic form in 2 variables over Integer Ring with coefficients: 
+        [ 2 -1 ]
+        [ * 2 ]
+        ,
+        [ 0 -1]
+        [ 1  1])
     """
     R = self.base_ring()
     n = self.dim()
@@ -79,7 +105,7 @@
     while (interior_reduced_flag == False):
         interior_reduced_flag = True
 
-        print Q
+        #print Q
 
         ## Arrange for (weakly) increasing diagonal entries
         for i in range(n):
diff --git a/sage/quadratic_forms/quadratic_form__siegel_product.py b/sage/quadratic_forms/quadratic_form__siegel_product.py
--- a/sage/quadratic_forms/quadratic_form__siegel_product.py
+++ b/sage/quadratic_forms/quadratic_form__siegel_product.py
@@ -32,8 +32,8 @@
 
     EXAMPLES:
         sage: Q = DiagonalQuadraticForm(ZZ, [1,1,1,1])
-        sage: Q.theta_by_cholesky(10)
-        1 + 8*q + 24*q^2 + 32*q^3 + 24*q^4 + 48*q^5 + 96*q^6 + 64*q^7 + 24*q^8 + 104*q^9 + 144*q^10
+        sage: Q.theta_series(11)
+        1 + 8*q + 24*q^2 + 32*q^3 + 24*q^4 + 48*q^5 + 96*q^6 + 64*q^7 + 24*q^8 + 104*q^9 + 144*q^10 + O(q^11)
 
         sage: Q.siegel_product(1)
         8
@@ -64,7 +64,7 @@
         sage: M = 16; len([v  for v in mrange([M,M,M,M])  if Q(v) % M == 2]) / M^3     ## long time
         3/2
 
-        sage: [1] + [Q.siegel_product(ZZ(a))  for a in range(1,11)] == Q.theta_by_cholesky(10).list()
+        sage: [1] + [Q.siegel_product(ZZ(a))  for a in range(1,11)] == Q.theta_series(11).list()
         True
 
     """
diff --git a/sage/quadratic_forms/quadratic_form__split_local_covering.py b/sage/quadratic_forms/quadratic_form__split_local_covering.py
--- a/sage/quadratic_forms/quadratic_form__split_local_covering.py
+++ b/sage/quadratic_forms/quadratic_form__split_local_covering.py
@@ -9,6 +9,7 @@
 from sage.quadratic_forms.extras import extend_to_primitive
 from sage.quadratic_forms.quadratic_form import QuadraticForm__constructor, is_QuadraticForm
 
+from sage.rings.real_mpfr import RealField
 from sage.rings.real_double import RDF
 from sage.matrix.matrix_space import MatrixSpace
 #from sage.matrix.matrix import Matrix
@@ -20,6 +21,75 @@
 from sage.rings.arith import GCD
 
 
+def cholesky_decomposition(self, bit_prec = 53):
+    """
+    Give the Cholesky decomposition of Q as a real matrix of precision
+        bit_prec.
+
+    RESTRICTIONS: Q must be given as a QuadraticForm defnined over ZZ,
+        QQ, or some RealField().  If it is over some real field, then
+        an error is raised if the precision given is not less than the
+        defined precision of the real field defining the quadratic form!
+
+    REFERENCE: From Cohen's "A Course in Computational Algebraic
+        Number Theory" book, p 103.
+
+    INPUT:
+        bit_prec -- a natural number.
+
+    OUTPUT:
+        an upper triangular real matrix of precision bit_prec.
+
+
+    TO DO: If we only care about working over the real double field
+        (RDF), then we can use the cholesky() method present for
+        square matrices over that.
+
+
+    ##///////////////////////////////////////////////////////////////////////////////////////////////// 
+    ##/// Finds the Cholesky decomposition of a quadratic form -- as an upper-triangular matrix!
+    ##/// (It's assumed to be global, hence twice the form it refers to.)  <-- Python revision asks:  Is this true?!? =|
+    ##/////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+    EXAMPLES:
+
+
+    """
+
+    ## Check that the precision passed is allowed.
+    if isinstance(self.base_ring(), RealField) and (self.base_ring().prec() < bit_prec):
+        raise RuntimeError, "Oops! The precision requested is greater than that of the given quadratic form!"
+
+    ## 1. Initialization
+    n = self.dim()
+    R = RealField(bit_prec)
+    MS = MatrixSpace(R, n, n)
+    Q = MS(R(0.5)) * MS(self.matrix())               ## Initialize the real symmetric matrix A with the matrix for Q(x) = x^t * A * x
+
+    ## DIAGNOSTIC
+    #print "After 1:  Q is \n" + str(Q)
+
+    ## 2. Loop on i
+    for i in range(n):
+        for j in range(i+1, n):
+            Q[j,i] = Q[i,j]             ## Is this line redundant?
+            Q[i,j] = Q[i,j] / Q[i,i]
+
+        ## 3. Main Loop
+        for k in range(i+1, n):
+            for l in range(k, n):
+                Q[k,l] = Q[k,l] - Q[k,i] * Q[i,l]
+
+    ## 4. Zero out the strictly lower-triangular entries
+    for i in range(n):
+        for j in range(i-1):
+            Q[i,j] = 0
+
+    return Q
+
+
+
 def vectors_by_length(self, bound):
     """
     Returns a list of short vectors together with their values.  
diff --git a/sage/quadratic_forms/quadratic_form__ternary_Tornaria.py b/sage/quadratic_forms/quadratic_form__ternary_Tornaria.py
--- a/sage/quadratic_forms/quadratic_form__ternary_Tornaria.py
+++ b/sage/quadratic_forms/quadratic_form__ternary_Tornaria.py
@@ -13,7 +13,12 @@
 
 from sage.libs.pari.all import pari
 from sage.misc.misc import prod
-from sage.rings.arith import factor
+from sage.rings.arith import factor, gcd, prime_to_m_part, CRT_list
+from sage.rings.arith import hilbert_symbol, kronecker_symbol
+
+from sage.quadratic_forms.quadratic_form import QuadraticForm__constructor as QuadraticForm
+from sage.modules.free_module import FreeModule
+from sage.modules.free_module_element import vector
 
 
 ## TO DO -- Add second argument
@@ -25,31 +30,60 @@
 
 
 
-def disc_Tornaria(self):
+def disc(self):
     """
-    Returns the discriminant of the quadratc form, 
+    Returns the discriminant of the quadratic form, 
     defined as 
 
-        det(B)      for even dimension
-        det(B)/2    for odd dimension
+        (-1)^n * det(B)      for even dimension 2n
+        det(B)/2             for odd dimension
 
     where 2Q(x) = x^t * B * x. 
+
+    This agrees with the usual discriminant for binary and ternary quadratic forms.
+
+    EXAMPLES:
+
+        sage: DiagonalQuadraticForm(ZZ, [1]).disc()
+        1
+        sage: DiagonalQuadraticForm(ZZ, [1,1]).disc()
+        -4
+        sage: DiagonalQuadraticForm(ZZ, [1,1,1]).disc()
+        4
+        sage: DiagonalQuadraticForm(ZZ, [1,1,1,1]).disc()
+        16
     """
     if is_odd(self.dim()):
       return  self.base_ring()(self.det() / 2)      ## This is not so good for characteristic 2.
     else:
-      return self.det()
+      return (-1)**(self.dim()/2) * self.det()
 
 
-#def content(self):
-#    """
-#    Returns the GCD of the coefficients fo the quadratic form.    
-#
-#    Warning: Only works over Euclidean domains... probably just ZZ. =|
-#    """
-#    return gcd(self.__coeffs)
+def content(self):
+    """
+    Returns the GCD of the coefficients fo the quadratic form.    
 
+    Warning: Only works over Euclidean domains... probably just ZZ. =|
 
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, 1])
+        sage: Q.matrix().gcd()
+        2
+        sage: Q.content()
+        1
+        sage: DiagonalQuadraticForm(ZZ, [1, 1]).is_primitive()
+        True
+        sage: DiagonalQuadraticForm(ZZ, [2, 4]).is_primitive()
+        False
+        sage: DiagonalQuadraticForm(ZZ, [2, 4]).primitive()
+        Quadratic form in 2 variables over Integer Ring with coefficients: 
+        [ 1 0 ]
+        [ * 2 ]
+    """
+    return self.gcd()
+
+
+## in quadratic_form.py
 #def is_primitive(self):
 #    """
 #    Checks if the form is a multiple of another form... only over ZZ for now.
@@ -58,6 +92,7 @@
 
 
 
+## in quadratic_form.py
 #def primitive(self):
 #    """
 #    Returns a primitive quadratic forms in the similarity class of the given form.
@@ -70,47 +105,101 @@
 
 
 
-#def adjoint(self):
-#    """
-#    This gives the adjoint (integral) quadratic form associated to the
-#    given form, essentially defined by taking the adjoint of the matrix.
-#    """
-#    if is_odd(self.dim()):
-#        return QuadraticForm(self.matrix().adjoint()*2)
-#    else:
-#        return QuadraticForm(self.matrix().adjoint())
+def adjoint(self):
+    """
+    This gives the adjoint (integral) quadratic form associated to the
+    given form, essentially defined by taking the adjoint of the matrix.
 
+    EXAMPLES:
 
-## Perhaps this is not needed...
-#
-#  def antiadjoint(self):
-#    """
-#    
-#    
-#    """
-#    n=self.dim
-#    try:
-#      d=(polygen(self.R)**(n-1)-self.disc()).roots()[0][0]
-#      if is_odd(n):
-#        return self.adjoint() / d**(n-2) / 4
-#      else:
-#        return self.adjoint() / d**(n-2)
-#    except IndexError:
-#      raise ValueError, "not an adjoint"
+        sage: Q = QuadraticForm(ZZ, 2, [1,2,5])
+        sage: Q.adjoint()
+        Quadratic form in 2 variables over Integer Ring with coefficients: 
+        [ 5 -2 ]
+        [ * 1 ]
 
+        sage: Q = QuadraticForm(ZZ, 3, [1, 0, -1, 2, -1, 5])
+        sage: Q.adjoint()
+        Quadratic form in 3 variables over Integer Ring with coefficients: 
+        [ 39 2 8 ]
+        [ * 19 4 ]
+        [ * * 8 ]
 
-## See above...
-#
-#  def is_adjoint(self):
-#    try:
-#      self.antiadjoint()
-#    except ValueError:
-#      return False
-#    return True
+    """
+    if is_odd(self.dim()):
+        return QuadraticForm(self.matrix().adjoint()*2)
+    else:
+        return QuadraticForm(self.matrix().adjoint())
+
+
+def antiadjoint(self):
+    """
+    This gives an (integral) form such that its adjoint is the given form.
+    sage: Q = QuadraticForm(ZZ, 3, [1, 0, -1, 2, -1, 5])
+    sage: Q.adjoint().antiadjoint()
+    Quadratic form in 3 variables over Integer Ring with coefficients: 
+    [ 1 0 -1 ]
+    [ * 2 -1 ]
+    [ * * 5 ]
+    sage: Q.antiadjoint()
+    Traceback (most recent call last):
+    ...
+    ValueError: not an adjoint
+    """
+    try:
+      n = self.dim()
+      R = self.base_ring()
+      d = R(self.disc()**(ZZ(1)/(n-1)))
+      if is_odd(n):
+        return self.adjoint().scale_by_factor( R(1) / 4 / d**(n-2) )
+      else:
+        return self.adjoint().scale_by_factor( R(1) / d**(n-2) )
+    except TypeError:
+      raise ValueError, "not an adjoint"
+
+
+def is_adjoint(self):
+    """
+    Determines if the given form is the adjoint of another form
+
+    EXAMPLES:
+    
+        sage: Q = QuadraticForm(ZZ, 3, [1, 0, -1, 2, -1, 5])
+        sage: Q.is_adjoint()
+        False
+        sage: Q.adjoint().is_adjoint()
+        True
+    """
+    try:
+      self.antiadjoint()
+    except ValueError:
+      return False
+    return True
 
 
 def reciprocal(self):
-    return self.adjoint().primitive() * self.content()
+    """
+    This gives the reciprocal quadratic form associated to the given form.
+    This is defined as the multiple of the primitive adjoint with the same
+    content as the given form.
+
+    EXAMPLES:
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,37])
+        sage: Q.reciprocal()
+        Quadratic form in 3 variables over Integer Ring with coefficients: 
+        [ 37 0 0 ]
+        [ * 37 0 ]
+        [ * * 1 ]
+        sage: Q.reciprocal().reciprocal()
+        Quadratic form in 3 variables over Integer Ring with coefficients: 
+        [ 1 0 0 ]
+        [ * 1 0 ]
+        [ * * 37 ]
+        sage: Q.reciprocal().reciprocal() == Q
+        True
+    """
+    return self.adjoint().primitive() . scale_by_factor( self.content() )
 
 
 def omega(self):
@@ -118,6 +207,12 @@
     This is the content of the adjont of the primitive associated quadratic form.
 
     Ref: See Dickson's "Studies in Number Theory".
+
+    EXAMPLES:
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,37])
+        sage: Q.omega()
+        4
     """
     return self.primitive().adjoint().content()
 
@@ -125,18 +220,55 @@
     """
     This is the omega of the adjoint form, 
     which is the same as the omega of the reciprocal form.
+
+    EXAMPLES:
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,37])
+        sage: Q.delta()
+        148
     """
     return self.adjoint().omega()
 
 
 def level__Tornaria(self):
     """
-    Hopefully this agrees with the usual level...
+    Returns the level of the quadratic form, 
+    defined as 
+
+        level(B)    for even dimension
+        level(B)/4  for odd dimension
+
+    where 2Q(x) = x^t * B * x. 
+
+    This agrees with the usual level for even dimension...
+
+    EXAMPLES:
+        sage: DiagonalQuadraticForm(ZZ, [1]).level__Tornaria()
+        1
+        sage: DiagonalQuadraticForm(ZZ, [1,1]).level__Tornaria()
+        4
+        sage: DiagonalQuadraticForm(ZZ, [1,1,1]).level__Tornaria()
+        1
+        sage: DiagonalQuadraticForm(ZZ, [1,1,1,1]).level__Tornaria()
+        4
     """
-    return self.base_ring()(self.disc()/self.omega()/self.content()**self.dim())
+    return self.base_ring()(abs(self.disc())/self.omega()/self.content()**self.dim())
 
 
 def discrec(self):
+    """
+    Returns the discriminant of the reciprocal form.
+
+    EXAMPLES:
+
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,1,37])
+        sage: Q.disc()
+        148
+        sage: Q.discrec()
+        5476
+        sage: [4 * 37, 4 * 37^2]
+        [148, 5476]
+    """
     return self.reciprocal().disc()
 
 
@@ -146,19 +278,47 @@
 
 def hasse_conductor(self):
     """
-    This is the product of all primes where the Hasse invariant is -1.
+    This is the product of all primes where the Hasse invariant equals -(-1,-D).
 
-    Note: For ternary forms, this is the discriminant of the associated
+    Note: For ternary forms, this is the discriminant of the
     quaternion algebra associated to the quadratic space
+
+    EXAMPLES:
+
+        sage: Q = QuadraticForm(ZZ, 3, [1, 0, -1, 2, -1, 5])
+        sage: Q.hasse_invariant(2)
+        -1
+        sage: hilbert_symbol(-1, -37, 2)
+        -1
+        sage: Q.hasse_invariant(37)
+        -1
+        sage: hilbert_symbol(-1, -37, 37)
+        1
+        sage: Q.hasse_conductor()
+        37
+
+        sage: DiagonalQuadraticForm(ZZ, [1, 1, 1]).hasse_conductor()
+        2
+        sage: QuadraticForm(ZZ, 3, [2, -2, 0, 2, 0, 5]).hasse_conductor()
+        30
     """
-    # * self.hasse(-1) ???
-    return prod(filter(lambda(p):self.hasse_invariant(p)==-1, \
+    D = self.disc()
+    return prod(filter(lambda(p):self.hasse_invariant(p)==-hilbert_symbol(-1,-D,p), \
              map(lambda(x):x[0],factor(2*self.level()))))
 
 
 ### Genus theory
 
 def basiclemma(self,M):
+    """
+    Finds a number represented by self and coprime to M.
+
+    EXAMPLES:
+
+        sage: Q = QuadraticForm(ZZ, 2, [2, 1, 3])
+        sage: Q.basiclemma(6)
+        71
+    """
     a=self(self.basiclemmavec(M))
     assert gcd(a,M) == 1
     return a
@@ -166,6 +326,14 @@
 def basiclemmavec(self,M):
     """
     Finds a vector where the value of the quadratic form is coprime to M.
+
+    EXAMPLES:
+
+        sage: Q = QuadraticForm(ZZ, 2, [2, 1, 5])
+        sage: Q.basiclemmavec(10)
+        (6, 5)
+        sage: Q(_)
+        227
     """
     V=FreeModule(self.base_ring(),self.dim())
     mat = self.matrix()
@@ -178,11 +346,11 @@
     for i in range(self.dim()):
         M1 = prime_to_m_part(M0, self[i,i])
         if M1 != 1:
-            vec.append(V.i)
+            vec.append(V.gen(i))
             mod.append(M1)
         M0 = M0/M1
         if M0 == 1:
-            return __crt_list(vec,mod)
+            return CRT_list(vec,mod)
 
     for i in range(self.dim()):
         for j in range(i):
@@ -196,13 +364,6 @@
 
     raise ValueError, "not primitive form"
 
-def __crt_list(ls, ms):
-    """
-    Chinese remainder theorem for lists; find an element l
-    such that l = ls[i] mod ms[i] for all i.
-    """
-    return sum(map(prod,zip,(ls,crt_basis(ms))))
-
 
 ### FIXME: get the rules for validity of characters straight...
 ### p=2 might be bad!!!
@@ -212,19 +373,47 @@
     We allow -1 as a prime.
 
     Reference: Dickson's "Studies in the Theory of Numbers" 
+
+    EXAMPLES:
+
+        sage: Q1 = QuadraticForm(ZZ, 3, [1, 1, 1, 14, 3, 14])
+        sage: Q2 = QuadraticForm(ZZ, 3, [2, -1, 0, 2, 0, 50])
+        sage: [Q1.omega(), Q2.omega()]
+        [5, 5]
+        sage: [Q1.hasse_invariant(5), Q2.hasse_invariant(5)]    # equivalent over Q_5
+        [1, 1]
+        sage: [Q1.xi(5), Q2.xi(5)]                              # not equivalent over Z_5
+        [1, -1]
     """
     if self.dim() == 2 and self.disc() % p:
         raise ValueError, "not a valid character"
     if self.dim() >= 3 and self.omega() % p:
         raise ValueError, "not a valid character"
     if (p == -1) or (p == 2):
-        return kronecker(p, self.basiclemma(2))
-    return kronecker(self.basiclemma(p), p)
+        return kronecker_symbol(p, self.basiclemma(2))
+    return kronecker_symbol(self.basiclemma(p), p)
 
 
 def xi_rec(self,p):
     """
     Returns Xi(p) for the reciprocal form.
+
+    EXAMPLES:
+
+        sage: Q1 = QuadraticForm(ZZ, 3, [1, 1, 1, 14, 3, 14])
+        sage: Q2 = QuadraticForm(ZZ, 3, [2, -1, 0, 2, 0, 50])
+        sage: [Q1.hasse_conductor(), Q2.hasse_conductor()]   # equivalent over Q
+        [3, 3]
+        sage: Q1.is_locally_equivalent_to(Q2)                # not in the same genus
+        False
+        sage: [Q1.delta(), Q2.delta()]
+        [480, 480]
+        sage: factor(480)
+        2^5 * 3 * 5
+        sage: map(Q1.xi_rec, [-1,2,3,5])
+        [-1, -1, -1, 1]
+        sage: map(Q2.xi_rec, [-1,2,3,5])
+        [-1, -1, -1, -1]
     """
     return self.reciprocal().xi(p)
 
@@ -232,54 +421,135 @@
 def lll(self):
     """
     Returns an LLL-reduced form of Q (using Pari).
+
+    EXAMPLES:
+
+        sage: Q = QuadraticForm(ZZ, 4, range(1,11))
+        sage: Q.is_definite()
+        True
+        sage: Q.lll()
+        Quadratic form in 4 variables over Integer Ring with coefficients: 
+        [ 1 0 -1 0 ]
+        [ * 4 3 3 ]
+        [ * * 6 3 ]
+        [ * * * 6 ]
     """
-    return self(self.matrix().lllgram())
+    return self(self.matrix().LLL_gram())
 
 
 def representation_number_list(self, B):
     """
     Returns the vector of representation numbers < B.  
+    
+    EXAMPLES:
+
+        sage: Q = DiagonalQuadraticForm(ZZ,[1,1,1,1,1,1,1,1])
+        sage: Q.representation_number_list(10)
+        [1, 16, 112, 448, 1136, 2016, 3136, 5504, 9328, 12112]
     """
-    return pari(1).concat(self._pari_().qfrep(B-1, 1) * 2)
+    ans = pari(1).concat(self._pari_().qfrep(B-1, 1) * 2)
+    return ans._sage_()
 
 
-def ThetaByPari(self, B):
+def representation_vector_list(self, B, maxvectors = 10**8):
     """
-    Returns the theta function up to O(q^B).
+    Find all vectors v where Q(v) < B.
+
+    EXAMPLES:
+    
+        sage: Q = DiagonalQuadraticForm(ZZ, [1, 1])
+        sage: Q.representation_vector_list(10)
+        [[(0, 0)],
+         [(0, 1), (0, -1), (1, 0), (-1, 0)],
+         [(1, 1), (-1, -1), (-1, 1), (1, -1)],
+         [],
+         [(0, 2), (0, -2), (2, 0), (-2, 0)],
+         [(1, 2), (-1, -2), (-1, 2), (1, -2), (2, 1), (-2, -1), (-2, 1), (2, -1)],
+         [],
+         [],
+         [(2, 2), (-2, -2), (-2, 2), (2, -2)],
+         [(0, 3), (0, -3), (3, 0), (-3, 0)]]
+        sage: map(len, _)
+        [1, 4, 4, 0, 4, 8, 0, 0, 4, 4]
+        sage: Q.representation_number_list(10)
+        [1, 4, 4, 0, 4, 8, 0, 0, 4, 4]
     """
-    PSR = PowerSeriesRing(ZZ,'q')
-    return PSR(self.representation_number_list(B), B)
-
-
-
-def representation_vector_list(self, B):
-    """
-    Find all vectors v where Q(v) <= B.
-    """
-    n,m,vs = self._pari_().qfminim(2*(B-1), 10**8)
+    n, m, vs = self._pari_().qfminim(2*(B-1), maxvectors)
     if n != 2 * len(vs):
         raise RuntimeError("insufficient number of vectors")
-    ms = [[] for _ in xrange(m/2+1)]
-    for v in vs:
-        ms[int(self(v))].append(v)
+    ms = [[] for _ in xrange(B)]
+    ms[0] = [vector([0] * self.dim())]
+    for v in vs._sage_().columns():
+        ms[int(self(v))] += [v, -v]
     return ms
 
 
-
 ### zeros
 
-def is_singular_vector(self, v, p=0):
+def is_zero(self, v, p=0):
+    """
+    Determines if the vector v is on the conic Q(x) = 0 (mod p).
+
+    EXAMPLES:
+
+        sage: Q1 = QuadraticForm(ZZ, 3, [1, 0, -1, 2, -1, 5])
+        sage: Q1.is_zero([0,1,0], 2)
+        True
+        sage: Q1.is_zero([1,1,1], 2)
+        True
+        sage: Q1.is_zero([1,1,0], 2)
+        False
+    """
+    norm = self(v)
+    if p != 0:
+        norm = norm % p
+    return  norm == 0
+
+def is_zero_nonsingular(self, v, p=0):
     """
     Determines if the vector v is on the conic Q(x) = 0 (mod p), 
     and that this point is non-singular point of the conic.
+
+    EXAMPLES:
+
+        sage: Q1 = QuadraticForm(ZZ, 3, [1, 0, -1, 2, -1, 5])
+        sage: Q1.is_zero_nonsingular([1,1,1], 2)
+        True
+        sage: Q1.is_zero([1, 19, 2], 37)
+        True
+        sage: Q1.is_zero_nonsingular([1, 19, 2], 37)
+        False
     """
     if not self.is_zero(v, p):
         return False
     vm = vector(self.base_ring(), v) * self.matrix()
     if p != 0:
         vm = vm % p
+    return (vm != 0)
 
+def is_zero_singular(self, v, p=0):
+    """
+    Determines if the vector v is on the conic Q(x) = 0 (mod p), 
+    and that this point is singular point of the conic.
+
+    EXAMPLES:
+
+        sage: Q1 = QuadraticForm(ZZ, 3, [1, 0, -1, 2, -1, 5])
+        sage: Q1.is_zero([1,1,1], 2)
+        True
+        sage: Q1.is_zero_singular([1,1,1], 2)
+        False
+        sage: Q1.is_zero_singular([1, 19, 2], 37)
+        True
+    """
+    if not self.is_zero(v, p):
+        return False
+    vm = vector(self.base_ring(), v) * self.matrix()
+    if p != 0:
+        vm = vm % p
     return (vm == 0)
 
 
 
+
+
diff --git a/sage/quadratic_forms/quadratic_form__theta.py b/sage/quadratic_forms/quadratic_form__theta.py
--- a/sage/quadratic_forms/quadratic_form__theta.py
+++ b/sage/quadratic_forms/quadratic_form__theta.py
@@ -12,23 +12,16 @@
 from sage.modular.dims import sturm_bound
 
 
-def theta_series(self, Max='sturm', var_str='q', safe_flag=True):
+def theta_series(self, Max=10, var_str='q', safe_flag=True):
     """
     Compute the theta series as a power series in the variable given
     in var_str (which defaults to 'q'), up to the specified precision
     O(q^max).
 
-    If no precision is specified, then it defaults to computing the
-    precision specified by sturm_bound() + 1, which suffices to
-    uniquely determine the cuspidal part of the theta series.
-    
     This uses the PARI/GP function qfrep, wrapped by the
-    theta_by_pari() method.  This caches teh result for future
+    theta_by_pari() method.  This caches the result for future
     computations.
 
-    WARNING: This may not be the correct default bound for
-    odd-dimensional quadratic forms!!  CHECK THIS!!!
-
     The safe_flag allows us to select whether we want a copy of the
     output, or the original output.  It is only meningful when a
     vector is returned, otherwise a copy is automatically made in
@@ -37,6 +30,18 @@
     then the routine is much faster but the return values are
     vulnerable to being corrupted by the user.
 
+    TO DO: Allow the option Max='mod_form' to give enough coefficients
+    to ensure we determine the theta series as a modular form.  This
+    is related to the Sturm bound, but we'll need to be careful about
+    this (particularly for half-integral weights!).
+
+    EXAMPLES:
+        sage: Q = DiagonalQuadraticForm(ZZ, [1,3,5,7])
+        sage: Q.theta_series()
+        1 + 2*q + 2*q^3 + 6*q^4 + 2*q^5 + 4*q^6 + 6*q^7 + 8*q^8 + 14*q^9 + O(q^10)
+
+        sage: Q.theta_series(25)
+        1 + 2*q + 2*q^3 + 6*q^4 + 2*q^5 + 4*q^6 + 6*q^7 + 8*q^8 + 14*q^9 + 4*q^10 + 12*q^11 + 18*q^12 + 12*q^13 + 12*q^14 + 8*q^15 + 34*q^16 + 12*q^17 + 8*q^18 + 32*q^19 + 10*q^20 + 28*q^21 + 16*q^23 + 44*q^24 + O(q^25)
     """
     ## Sanity Check: Max is an integer or an allowed string:
     try:
@@ -44,12 +49,13 @@
     except:
         M = -1
 
-    if (Max not in ['sturm']) and (not M >= 0):
+    if (Max not in ['mod_form']) and (not M >= 0):
         print Max
         raise TypeError, "Oops!  Max is not an integer >= 0 or an allowed string."
 
-    if Max == 'sturm':
-        return self.theta_by_pari(sturm_bound(self.level(), self.dim() / ZZ(2)) + 1, var_str, safe_flag)
+    if Max == 'mod_form':
+        raise NotImplementedError, "Oops!  We have to figure out the correect number of Fourier coefficients to use..."
+        #return self.theta_by_pari(sturm_bound(self.level(), self.dim() / ZZ(2)) + 1, var_str, safe_flag)
     else:
         return self.theta_by_pari(M, var_str, safe_flag)
 
@@ -91,25 +97,13 @@
         a power series or a vector
     """
     ## Try to use the cached result if it's enough precision
-    try:        
-        if len(self.__theta_vec) >= Max:
-            theta_vec = self.__theta_vec[:Max]
-        else:
-            raise RuntimeError, ""
-    except:
-        ## Generate a PARI matrix string for the associated Hessian matrix
-        M_str = str(gp(self.matrix()))
-        
-        ## Compute the theta function as a vector
-        gp_vec = list(gp.qfrep(M_str, 2*Max-2))
-        
-        ## Create the "halved" representation/theta vector
-        theta_vec = [ZZ(1)] + [ZZ(2) * ZZ(gp_vec[x])  for x in range(1, len(gp_vec), 2)]
-
+    if hasattr(self, '__theta_vec') and len(self.__theta_vec) >= Max:
+        theta_vec = self.__theta_vec[:Max]
+    else:
+        theta_vec = self.representation_number_list(Max)
         ## Cache the theta vector
         self.__theta_vec = theta_vec
 
-    
     ## Return the answer
     if var_str == '':
         if safe_flag:
@@ -117,12 +111,13 @@
         else:
             return theta_vec
     else:
-        return PowerSeriesRing(ZZ, var_str)(theta_vec)
+        return PowerSeriesRing(ZZ, var_str)(theta_vec, Max)
 
 
 
 ## -------------  Compute the theta function by using an explicit Cholesky decomposition ------------
 
+
 ##########################################################################
 ## Routines to compute the Fourier expansion of the theta function of Q ##
 ## (to a given precision) via a Cholesky decomposition over RR.         ##
@@ -131,72 +126,6 @@
 ## ~/Documents/290_Project/C/Ver13.2__3-5-2007/Matrix_mpz/Matrix_mpz.cc ##
 ##########################################################################
 
-def cholesky_decomposition(self, bit_prec = 53):
-    """
-    Give the Cholesky decomposition of Q as a real matrix of precision
-        bit_prec.
-
-    RESTRICTIONS: Q must be given as a QuadraticForm defnined over ZZ,
-        QQ, or some RealField().  If it is over some real field, then
-        an error is raised if the precision given is not less than the
-        defined precision of the real field defining the quadratic form!
-
-    REFERENCE: From Cohen's "A Course in Computational Algebraic
-        Number Theory" book, p 103.
-
-    INPUT:
-        bit_prec -- a natural number.
-
-    OUTPUT:
-        an upper triangular real matrix of precision bit_prec.
-
-
-    TO DO: If we only care about working over the real double field
-        (RDF), then we can use the cholesky() method present for
-        square matrices over that.
-
-
-    ##///////////////////////////////////////////////////////////////////////////////////////////////// 
-    ##/// Finds the Cholesky decomposition of a quadratic form -- as an upper-triangular matrix!
-    ##/// (It's assumed to be global, hence twice the form it refers to.)  <-- Python revision asks:  Is this true?!? =|
-    ##/////////////////////////////////////////////////////////////////////////////////////////////////
-
-
-    EXAMPLES:
-
-
-    """
-
-    ## Check that the precision passed is allowed.
-    if isinstance(self.base_ring(), RealField) and (self.base_ring().prec() < bit_prec):
-        raise RuntimeError, "Oops! The precision requested is greater than that of the given quadratic form!"
-
-    ## 1. Initialization
-    n = self.dim()
-    R = RealField(bit_prec)
-    MS = MatrixSpace(R, n, n)
-    Q = MS(R(0.5)) * MS(self.matrix())               ## Initialize the real symmetric matrix A with the matrix for Q(x) = x^t * A * x
-
-    ## DIAGNOSTIC
-    #print "After 1:  Q is \n" + str(Q)
-
-    ## 2. Loop on i
-    for i in range(n):
-        for j in range(i+1, n):
-            Q[j,i] = Q[i,j]             ## Is this line redudnant?
-            Q[i,j] = Q[i,j] / Q[i,i]
-
-        ## 3. Main Loop
-        for k in range(i+1, n):
-            for l in range(k, n):
-                Q[k,l] = Q[k,l] - Q[k,i] * Q[i,l]
-
-    ## 4. Zero out the strictly lower-triangular entries
-    for i in range(n):
-        for j in range(i-1):
-            Q[i,j] = 0
-
-    return Q
 
 
 def theta_by_cholesky(self, q_prec):
@@ -379,3 +308,5 @@
     ## Return the series, truncated to the desired q-precision
     return PS(theta)
 
+
+
diff --git a/sage/quadratic_forms/random_quadraticform.py b/sage/quadratic_forms/random_quadraticform.py
--- a/sage/quadratic_forms/random_quadraticform.py
+++ b/sage/quadratic_forms/random_quadraticform.py
@@ -24,19 +24,19 @@
         A quadratic form over the ring R.
 
     EXAMPLES:
-        sage: random_quadraticform(ZZ, 3, [1,5])
+        sage: random_quadraticform(ZZ, 3, [1,5])    ## RANDOM
         Quadratic form in 3 variables over Integer Ring with coefficients:
         [ 3 2 3 ]
         [ * 1 4 ]
         [ * * 3 ]
         
-        sage: random_quadraticform(ZZ, 3, [-5,5])
+        sage: random_quadraticform(ZZ, 3, [-5,5])    ## RANDOM
         Quadratic form in 3 variables over Integer Ring with coefficients:
         [ 3 2 -5 ]
         [ * 2 -2 ]
         [ * * -5 ]
         
-        sage: random_quadraticform(ZZ, 3, [-50,50])
+        sage: random_quadraticform(ZZ, 3, [-50,50])    ## RANDOM
         Quadratic form in 3 variables over Integer Ring with coefficients:
         [ 1 8 -23 ]
         [ * 0 0 ]
@@ -79,7 +79,7 @@
 
     EXAMPLES:
         sage: Q = random_quadraticform_with_conditions(ZZ, 3, [QuadraticForm.is_positive_definite], [-5, 5])
-        sage: Q
+        sage: Q    ## RANDOM
         Quadratic form in 3 variables over Integer Ring with coefficients:
         [ 3 -2 -5 ]
         [ * 2 2 ]
diff --git a/sage/quadratic_forms/special_values.py b/sage/quadratic_forms/special_values.py
--- a/sage/quadratic_forms/special_values.py
+++ b/sage/quadratic_forms/special_values.py
@@ -5,6 +5,7 @@
 from sage.algebras.quaternion_algebra import fundamental_discriminant
 from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing
 from sage.rings.arith import kronecker_symbol, bernoulli, factorial
+from sage.rings.all import RealField
 from sage.combinat.combinat import bernoulli_polynomial
 from sage.rings.rational_field import QQ
 from sage.rings.integer_ring import ZZ
@@ -136,7 +137,18 @@
     Compute k-th Bernoulli number for the primitive
     quadratic character associated to chi(x) = (d/x).
 
+    References:  Iwasawa's "Lectures on p-adic L-functions", pp7-16.
+
     EXAMPLES:
+        sage: ## Makes a set of odd fund discriminants < -3
+        sage: Fund_odd_test_set = [D  for D in range(-163, -3, 4)  if is_fundamental_discriminant(D)]  
+
+        sage: ## In general, we have B_{1, \chi_d} = -2h/w  for odd fund disc < 0
+        sage: for D in Fund_odd_test_set: 
+        ...      if len(BinaryQF_reduced_representatives(D)) != -QuadraticBernoulliNumber(1, D): 
+        ...          print "Oops!  There is an error at D = ", D 
+
+
 
     """
     ## Ensure the character is primitive
@@ -165,17 +177,8 @@
         Washington's "Cyclotomic Fields"
 
     EXAMPLES:
-        sage: RR = RealField(100)
-        sage: for i in range(5):
-        ...       print "L(" + str(1+2*i) + ", (-4/.)): ", RR(quadratic_L_function__exact(1+2*i, -4)) - quadratic_L_function__numerical(RR(1+2*i),-4, 10000)
-        L(1, (-4/.)):  0.000049999999500000024999996962707
-        L(3, (-4/.)):  0.00000000000049999997000000374637816570842
-        L(5, (-4/.)):  0.0000000000000000000049999992370601592951889007864
-        L(7, (-4/.)):  0.000000000000000000000000000028398992587956424994822228350
-        L(9, (-4/.)):  0.0000000000000000000000000000031554436208840472216469142611
-
-        sage: ## Testing the accuracy of the negative special values
-        sage: ## ---- THIS FAILS SINCE THE DIRICHLET SERIES DOESN'T CONVERGE HERE! ----
+        sage: bool(quadratic_L_function__exact(1, -4) == pi/4)
+        True
 
     """
     if n<=0:
@@ -215,6 +218,26 @@
     Evaluate the Dirichlet L-function (for quadratic character) numerically 
     (in a very naive way). 
 
+    EXAMPLES:
+        sage:  ## Test several values for a given character
+        sage: RR = RealField(100)
+        sage: for i in range(5):
+        ...       print "L(" + str(1+2*i) + ", (-4/.)): ", RR(quadratic_L_function__exact(1+2*i, -4)) - quadratic_L_function__numerical(RR(1+2*i),-4, 10000)
+        L(1, (-4/.)):  0.000049999999500000024999996962707
+        L(3, (-4/.)):  4.9999997000000374637816570842e-13
+        L(5, (-4/.)):  4.9999992370601592951889007864e-21
+        L(7, (-4/.)):  2.8398992587956424994822228350e-29
+        L(9, (-4/.)):  3.1554436208840472216469142611e-30
+
+        sage: ## Testing the accuracy of the negative special values
+        sage: ## ---- THIS FAILS SINCE THE DIRICHLET SERIES DOESN'T CONVERGE HERE! ----
+
+        sage: ## Test several characters agree with the exact value, to a given accuracy.
+        sage: for d in range(-20,0):
+        ...       if abs(RR(quadratic_L_function__numerical(1, d, 10000) - quadratic_L_function__exact(1, d))) > 0.001:
+        ...           print "Oops!  We have a problem at d = ", d, "    exact = ", RR(quadratic_L_function__exact(1, d)), "    numerical = ", RR(quadratic_L_function__numerical(1, d))  
+        ...           
+
     """
     ## Set the correct precision if it's given (for n).
     if is_RealField(n.parent()):
@@ -226,4 +249,4 @@
     ans = R(0)
     for i in range(1,num_terms):
         ans += R(kronecker_symbol(d1,i) / R(i)**n)
-    return ans
\ No newline at end of file
+    return ans
